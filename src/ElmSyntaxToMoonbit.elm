module ElmSyntaxToMoonbit exposing
    ( modules, moonbitDeclarationsToModuleString
    , MoonbitStatement(..), MoonbitExpression(..), MoonbitPattern(..), MoonbitType(..)
    )

{-| Transpiling [`elm-syntax`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/)
declarations to moonbit.

@docs modules, moonbitDeclarationsToModuleString
@docs MoonbitStatement, MoonbitExpression, MoonbitPattern, MoonbitType

If you need more fine-grained helpers,
[open an issue](https://github.com/lue-bird/elm-syntax-format/issues/new)

-}

import Bitwise
import Elm.Syntax.Declaration
import Elm.Syntax.Expression
import Elm.Syntax.File
import Elm.Syntax.Module
import Elm.Syntax.Node
import Elm.Syntax.Range
import Elm.Syntax.TypeAnnotation
import ElmSyntaxTypeInfer
import FastDict
import FastSet
import Graph
import Print exposing (Print)
import Unicode


{-| The sub-set of moonbit type syntax used in generated code
-}
type MoonbitType
    = -- _ TODO remove
      MoonbitTypeInfer
    | MoonbitTypeConstruct
        { qualification : List String
        , name : String
        , arguments : List MoonbitType
        , isEq : Bool
        , isShow : Bool
        }
    | -- technically a subset of MoonbitTypeConstruct but with extra metadata
      MoonbitTypeRecordStruct
        { name : String
        , fields : FastDict.Dict String MoonbitType
        }
    | MoonbitTypeTuple
        { part0 : MoonbitType
        , part1 : MoonbitType
        , part2Up : List MoonbitType
        }
    | MoonbitTypeVariable String
    | MoonbitTypeFunction
        { input : List MoonbitType
        , output : MoonbitType
        }


{-| The sub-set of moonbit pattern syntax used in generated code
-}
type MoonbitPattern
    = MoonbitPatternIgnore
    | MoonbitPatternInteger Int
    | MoonbitPatternChar Char
    | MoonbitPatternString String
    | MoonbitPatternVariable
        { name : String
        , -- should not be necessary
          type_ : MoonbitType
        }
    | MoonbitPatternAlias
        { variable : String
        , -- should not be necessary
          type_ : MoonbitType
        , pattern : MoonbitPattern
        }
    | MoonbitPatternStructNotExhaustive
        { name : String
        , fields : FastDict.Dict String MoonbitPattern
        }
    | MoonbitPatternVariant
        { originTypeName : List String
        , name : String
        , values : List { label : Maybe String, pattern : MoonbitPattern }
        }
    | MoonbitPatternTuple
        { part0 : MoonbitPattern
        , part1 : MoonbitPattern
        , part2Up : List MoonbitPattern
        }


{-| The sub-set of moonbit expression syntax used in generated code
-}
type MoonbitExpression
    = MoonbitExpressionUnit
    | MoonbitExpressionDouble Float
    | MoonbitExpressionInt64 Int
    | MoonbitExpressionChar Char
    | MoonbitExpressionString String
    | MoonbitExpressionSelf
    | MoonbitExpressionReference
        { qualification : List String
        , name : String
        }
    | MoonbitExpressionBinaryOperation
        { operator : String
        , left : MoonbitExpression
        , right : MoonbitExpression
        }
    | MoonbitExpressionReferenceVariant
        { originTypeName : List String
        , name : String
        }
    | MoonbitExpressionReferenceMethod
        { subject : MoonbitExpression
        , method : String
        }
    | MoonbitExpressionNegateOperation MoonbitExpression
    | MoonbitExpressionStructAccess
        { struct : MoonbitExpression
        , field : String
        }
    | -- type hint or casting
      MoonbitExpressionAs
        { expression : MoonbitExpression
        , type_ : MoonbitType
        }
    | MoonbitExpressionTuple
        { part0 : MoonbitExpression
        , part1 : MoonbitExpression
        , part2Up : List MoonbitExpression
        }
    | MoonbitExpressionArrayLiteral (List MoonbitExpression)
    | MoonbitExpressionStruct
        { name : String
        , fields : FastDict.Dict String MoonbitExpression
        }
    | MoonbitExpressionCall
        { called : MoonbitExpression
        , arguments : List MoonbitExpression
        }
    | MoonbitExpressionClosure
        { parameters :
            List
                { binding : Maybe String
                , type_ : Maybe MoonbitType
                }
        , resultType : Maybe MoonbitType
        , result : MoonbitExpression
        }
    | MoonbitExpressionIfElse
        { condition : MoonbitExpression
        , onTrue : MoonbitExpression
        , onFalse : MoonbitExpression
        }
    | MoonbitExpressionMatch
        { matched : MoonbitExpression
        , cases :
            List
                { pattern : MoonbitPattern
                , guardConditions : List MoonbitExpression
                , result : MoonbitExpression
                }
        }
    | MoonbitExpressionAfterStatement
        { statement : MoonbitStatement
        , result : MoonbitExpression
        }


{-| The sub-set of moonbit statement syntax used in generated moonbit code

TODO remove the unused ones like assignment, uninitialized

-}
type MoonbitStatement
    = MoonbitStatementLetDestructuring
        { pattern : MoonbitPattern
        , expression : MoonbitExpression
        }
    | MoonbitStatementLetDeclaration
        { name : String
        , result : MoonbitExpression
        , resultType : Maybe MoonbitType
        }
    | MoonbitStatementFnDeclaration
        { name : String
        , parameters : List { binding : Maybe String, type_ : MoonbitType }
        , result : MoonbitExpression
        , resultType : MoonbitType
        , typeParameters : List String
        }
    | MoonbitStatementLetDeclarationUninitialized
        { name : String
        , type_ : MoonbitType
        }
    | MoonbitStatementBindingAssignment
        { name : String
        , assignedValue : MoonbitExpression
        }


{-| Calculate valid mappings of qualifications + name
to origin module based on a module's imports.

Requires all exposed names
so we can resolve `exposing (..)` and `ChoiceType(..)`.

-}
modulesPlusImplicitlyImportedToModuleContext :
    { ports :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            }
    , types :
        FastDict.Dict
            {- module origin -} String
            ElmSyntaxTypeInfer.ModuleTypes
    , valueAndFunctionAnnotations :
        FastDict.Dict
            {- module origin -} String
            (FastDict.Dict
                String
                ElmSyntaxTypeInfer.Type
            )
    }
    ->
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict String ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
modulesPlusImplicitlyImportedToModuleContext context =
    (implicitlyImportedModules ++ (context.types |> FastDict.keys))
        |> -- this can have duplicate names but since we below use
           -- Dict.insert and looking up each module's information is cheap
           -- we can save the hassle of deduplicating here
           List.foldl
            (\moduleName soFar ->
                let
                    moduleDeclaredPorts :
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                    moduleDeclaredPorts =
                        case context.ports |> FastDict.get moduleName of
                            Nothing ->
                                portsOutgoingDictEmptyPortsIncomingDictEmpty

                            Just moduleExposedNames ->
                                { portsIncoming = moduleExposedNames.portsIncoming
                                , portsOutgoing = moduleExposedNames.portsOutgoing
                                }
                in
                soFar
                    |> FastDict.insert moduleName
                        { portsIncoming =
                            moduleDeclaredPorts.portsIncoming
                        , portsOutgoing =
                            moduleDeclaredPorts.portsOutgoing
                        , valueAndFunctionAnnotations =
                            case context.valueAndFunctionAnnotations |> FastDict.get moduleName of
                                Nothing ->
                                    case context.types |> FastDict.get moduleName of
                                        Nothing ->
                                            FastDict.empty

                                        Just moduleTypes ->
                                            moduleTypes.signatures

                                Just moduleDeclaredValueAndFunctionAnnotations ->
                                    moduleDeclaredValueAndFunctionAnnotations
                        , typeAliases =
                            case context.types |> FastDict.get moduleName of
                                Nothing ->
                                    FastDict.empty

                                Just moduleTypes ->
                                    moduleTypes.typeAliases
                        }
            )
            FastDict.empty


implicitlyImportedModules : List String
implicitlyImportedModules =
    [ "Basics"
    , "List"
    , "Maybe"
    , "Result"
    , "String"
    , "Char"
    , "Tuple"
    , "Debug"
    , "Platform"
    , "Platform.Cmd"
    , "Platform.Sub"
    ]


typeContainedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    ->
        FastSet.Set
            {- sorted field names -} (List String)
typeContainedRecords (Elm.Syntax.Node.Node _ syntaxType) =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            FastSet.empty

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            FastSet.union
                (inType |> typeContainedRecords)
                (outType |> typeContainedRecords)

        Elm.Syntax.TypeAnnotation.Tupled typeTupleParts ->
            typeTupleParts
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Typed _ arguments ->
            arguments
                |> listMapToFastSetsAndUnify
                    typeContainedRecords

        Elm.Syntax.TypeAnnotation.Record fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> listMapToFastSetsAndUnify
                        (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                            value |> typeContainedRecords
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ fields) ->
            fields
                |> listMapToFastSetsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, value )) ->
                        value |> typeContainedRecords
                    )


syntaxExpressionContainedConstructedRecords :
    Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression
    ->
        FastSet.Set
            {- sorted field names -} (List String)
syntaxExpressionContainedConstructedRecords syntaxExpressionNode =
    -- IGNORE TCO
    case syntaxExpressionNode |> Elm.Syntax.Node.value of
        Elm.Syntax.Expression.RecordExpr fields ->
            FastSet.insert
                (fields
                    |> List.map
                        (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ name, _ )) ->
                            name
                        )
                    |> List.sort
                )
                (fields
                    |> listMapToFastSetsAndUnify
                        (\(Elm.Syntax.Node.Node _ ( _, fieldValue )) ->
                            fieldValue |> syntaxExpressionContainedConstructedRecords
                        )
                )

        Elm.Syntax.Expression.UnitExpr ->
            FastSet.empty

        Elm.Syntax.Expression.Floatable _ ->
            FastSet.empty

        Elm.Syntax.Expression.Integer _ ->
            FastSet.empty

        Elm.Syntax.Expression.Hex _ ->
            FastSet.empty

        Elm.Syntax.Expression.CharLiteral _ ->
            FastSet.empty

        Elm.Syntax.Expression.Literal _ ->
            FastSet.empty

        Elm.Syntax.Expression.FunctionOrValue _ _ ->
            FastSet.empty

        Elm.Syntax.Expression.PrefixOperator _ ->
            FastSet.empty

        Elm.Syntax.Expression.RecordAccessFunction _ ->
            FastSet.empty

        Elm.Syntax.Expression.Operator _ ->
            -- invalid syntax
            FastSet.empty

        Elm.Syntax.Expression.GLSLExpression _ ->
            FastSet.empty

        Elm.Syntax.Expression.ParenthesizedExpression inParens ->
            syntaxExpressionContainedConstructedRecords inParens

        Elm.Syntax.Expression.RecordAccess record _ ->
            syntaxExpressionContainedConstructedRecords record

        Elm.Syntax.Expression.Negation inNegation ->
            syntaxExpressionContainedConstructedRecords inNegation

        Elm.Syntax.Expression.LambdaExpression lambda ->
            syntaxExpressionContainedConstructedRecords lambda.expression

        Elm.Syntax.Expression.OperatorApplication _ _ left right ->
            FastSet.union
                (left |> syntaxExpressionContainedConstructedRecords)
                (right |> syntaxExpressionContainedConstructedRecords)

        Elm.Syntax.Expression.IfBlock condition onTrue onFalse ->
            (condition |> syntaxExpressionContainedConstructedRecords)
                |> FastSet.union (onTrue |> syntaxExpressionContainedConstructedRecords)
                |> FastSet.union (onFalse |> syntaxExpressionContainedConstructedRecords)

        Elm.Syntax.Expression.TupledExpression parts ->
            parts
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.ListExpr elements ->
            elements
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.Application applicationParts ->
            applicationParts
                |> listMapToFastSetsAndUnify
                    syntaxExpressionContainedConstructedRecords

        Elm.Syntax.Expression.RecordUpdateExpression _ fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\(Elm.Syntax.Node.Node _ ( _, fieldValue )) ->
                        fieldValue |> syntaxExpressionContainedConstructedRecords
                    )

        Elm.Syntax.Expression.CaseExpression caseOf ->
            caseOf.expression
                |> syntaxExpressionContainedConstructedRecords
                |> FastSet.union
                    (caseOf.cases
                        |> listMapToFastSetsAndUnify
                            (\( _, fieldValue ) ->
                                fieldValue |> syntaxExpressionContainedConstructedRecords
                            )
                    )

        Elm.Syntax.Expression.LetExpression letIn ->
            letIn.expression
                |> syntaxExpressionContainedConstructedRecords
                |> FastSet.union
                    (letIn.declarations
                        |> listMapToFastSetsAndUnify
                            (\declaration ->
                                case Elm.Syntax.Node.value declaration of
                                    Elm.Syntax.Expression.LetFunction function ->
                                        function.declaration
                                            |> Elm.Syntax.Node.value
                                            |> .expression
                                            |> syntaxExpressionContainedConstructedRecords

                                    Elm.Syntax.Expression.LetDestructuring _ destructuredExpression ->
                                        destructuredExpression |> syntaxExpressionContainedConstructedRecords
                            )
                    )


choiceTypeDeclaration :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , moonbitEnumTypes :
        FastDict.Dict
            String
            { isShow : Bool
            , isEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    ->
        { parameters : List String
        , variants : FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
        }
    ->
        { parameters : List String
        , variants : FastDict.Dict String (List MoonbitType)
        , isShow : Bool
        , isEq : Bool
        }
choiceTypeDeclaration context syntaxChoiceType =
    let
        moonbitVariants : FastDict.Dict String (List MoonbitType)
        moonbitVariants =
            syntaxChoiceType.variants
                |> FastDict.foldl
                    (\elmVariantName variantValues soFar ->
                        soFar
                            |> FastDict.insert
                                (elmVariantName |> toPascalCaseMoonbitName)
                                (variantValues
                                    |> List.map
                                        (\value ->
                                            value |> type_ context
                                        )
                                )
                    )
                    FastDict.empty
    in
    { parameters =
        syntaxChoiceType.parameters
            |> List.map toPascalCaseMoonbitName
    , variants = moonbitVariants
    , isShow =
        moonbitVariants
            |> fastDictAll
                (\_ values ->
                    values
                        |> List.all
                            (\value ->
                                value |> moonbitTypeIsShow { variablesAreShow = True }
                            )
                )
    , isEq =
        moonbitVariants
            |> fastDictAll
                (\_ values ->
                    values
                        |> List.all
                            (\value ->
                                value |> moonbitTypeIsEq { variablesAreEq = True }
                            )
                )
    }


printTypeParameters : List String -> Print
printTypeParameters typeParameters =
    case typeParameters of
        [] ->
            Print.empty

        parameter0 :: parameter1Up ->
            Print.exactly
                ("["
                    ++ ((parameter0 :: parameter1Up)
                            |> String.join ", "
                       )
                    ++ "]"
                )


printMoonbitEnumDeclaration :
    { name : String
    , parameters : List String
    , variants :
        FastDict.Dict String (List MoonbitType)
    }
    -> Print
printMoonbitEnumDeclaration moonbitEnumType =
    Print.exactly
        ("pub(all) enum " ++ moonbitEnumType.name)
        |> Print.followedBy
            (printTypeParameters
                moonbitEnumType.parameters
            )
        |> Print.followedBy (Print.exactly " {")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (moonbitEnumType.variants
                            |> FastDict.toList
                            |> Print.listMapAndIntersperseAndFlatten
                                (\( name, values ) ->
                                    printMoonbitEnumVariantDeclaration
                                        { name = name
                                        , values = values
                                        }
                                )
                                Print.linebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (Print.exactly
                ("} derive("
                    ++ ([ if
                            moonbitEnumType.variants
                                |> fastDictAll
                                    (\_ values ->
                                        values
                                            |> List.all
                                                (\value ->
                                                    value |> moonbitTypeIsShow { variablesAreShow = True }
                                                )
                                    )
                          then
                            Just "Show"

                          else
                            Nothing
                        , if
                            moonbitEnumType.variants
                                |> fastDictAll
                                    (\_ values ->
                                        values
                                            |> List.all
                                                (\value ->
                                                    value |> moonbitTypeIsEq { variablesAreEq = True }
                                                )
                                    )
                          then
                            Just "Eq"

                          else
                            Nothing
                        ]
                            |> List.filterMap identity
                            |> String.join ", "
                       )
                    ++ ")"
                )
            )


moonbitTypeIsShow : { variablesAreShow : Bool } -> MoonbitType -> Bool
moonbitTypeIsShow context moonbitType =
    -- IGNORE TCO
    case moonbitType of
        MoonbitTypeInfer ->
            False

        MoonbitTypeVariable _ ->
            context.variablesAreShow

        MoonbitTypeFunction _ ->
            False

        MoonbitTypeTuple parts ->
            (parts.part0 |> moonbitTypeIsShow context)
                && (parts.part1 |> moonbitTypeIsShow context)
                && (parts.part2Up
                        |> List.all
                            (\part ->
                                part |> moonbitTypeIsShow context
                            )
                   )

        MoonbitTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> moonbitTypeIsShow context
                    )

        MoonbitTypeConstruct typeConstruct ->
            typeConstruct.isShow
                && (typeConstruct.arguments
                        |> List.all
                            (\argument ->
                                argument |> moonbitTypeIsShow context
                            )
                   )


moonbitTypeIsEq : { variablesAreEq : Bool } -> MoonbitType -> Bool
moonbitTypeIsEq context moonbitType =
    -- IGNORE TCO
    case moonbitType of
        MoonbitTypeInfer ->
            -- not decide-able at least
            False

        MoonbitTypeFunction _ ->
            False

        MoonbitTypeVariable _ ->
            context.variablesAreEq

        MoonbitTypeTuple parts ->
            (parts.part0 |> moonbitTypeIsEq context)
                && (parts.part1 |> moonbitTypeIsEq context)
                && (parts.part2Up
                        |> List.all
                            (\part ->
                                part |> moonbitTypeIsEq context
                            )
                   )

        MoonbitTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> moonbitTypeIsEq context
                    )

        MoonbitTypeConstruct typeConstruct ->
            typeConstruct.isEq
                && (typeConstruct.arguments
                        |> List.all
                            (\argument ->
                                argument |> moonbitTypeIsEq context
                            )
                   )


printMoonbitStructDeclaration :
    { name : String
    , parameters : List String
    , fields : FastDict.Dict String MoonbitType
    }
    -> Print
printMoonbitStructDeclaration moonbitEnumType =
    Print.exactly
        ("pub(all) struct "
            ++ moonbitEnumType.name
            ++ (case moonbitEnumType.parameters of
                    [] ->
                        ""

                    parameter0 :: parameter1Up ->
                        "["
                            ++ ((parameter0 :: parameter1Up)
                                    |> String.join ", "
                               )
                            ++ "]"
               )
            ++ " {"
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (moonbitEnumType.fields
                            |> FastDict.toList
                            |> Print.listMapAndIntersperseAndFlatten
                                (\( name, value ) ->
                                    let
                                        valuePrint : Print
                                        valuePrint =
                                            value |> printMoonbitTypeNotParenthesized
                                    in
                                    Print.exactly (name ++ ":")
                                        |> Print.followedBy
                                            (Print.withIndentAtNextMultipleOf4
                                                (Print.spaceOrLinebreakIndented
                                                    (valuePrint |> Print.lineSpread)
                                                    |> Print.followedBy valuePrint
                                                )
                                            )
                                )
                                Print.linebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy (Print.exactly "} derive(Show, Eq)")


printMoonbitEnumVariantDeclaration :
    { name : String
    , values : List MoonbitType
    }
    -> Print
printMoonbitEnumVariantDeclaration moonbitVariant =
    case moonbitVariant.values of
        [] ->
            Print.exactly moonbitVariant.name

        value0 :: value1Up ->
            let
                valuePrints : List Print
                valuePrints =
                    (value0 :: value1Up)
                        |> List.map printMoonbitTypeNotParenthesized

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    valuePrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            Print.exactly (moonbitVariant.name ++ "(")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (valuePrints
                                    |> Print.listMapAndIntersperseAndFlatten
                                        (\valuePrint ->
                                            Print.withIndentAtNextMultipleOf4
                                                valuePrint
                                        )
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented fullLineSpread)
                |> Print.followedBy printExactlyParenClosing


typeAliasDeclaration :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , moonbitEnumTypes :
        FastDict.Dict
            String
            { isShow : Bool
            , isEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    ->
        { parameters : List String
        , type_ : ElmSyntaxTypeInfer.Type
        }
    ->
        { parameters : List String
        , type_ : MoonbitType
        }
typeAliasDeclaration context inferredTypeAlias =
    let
        aliasedAsMoonbitType : MoonbitType
        aliasedAsMoonbitType =
            inferredTypeAlias.type_
                |> inferredTypeExpandInnerAliases context.typeAliasesInModule
                |> type_ context
    in
    { parameters =
        inferredTypeAlias.parameters
            |> List.map toPascalCaseMoonbitName
    , type_ = aliasedAsMoonbitType
    }


printMoonbitTypeAliasDeclaration :
    { name : String
    , parameters : List String
    , type_ : MoonbitType
    }
    -> Print
printMoonbitTypeAliasDeclaration moonbitTypeAliasDeclaration =
    Print.exactly "pub typealias"
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (moonbitTypeAliasDeclaration.type_
                            |> printMoonbitTypeNotParenthesized
                        )
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (Print.exactly ("as " ++ moonbitTypeAliasDeclaration.name))
                    |> Print.followedBy
                        (printTypeParameters
                            moonbitTypeAliasDeclaration.parameters
                        )
                )
            )


type_ :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , moonbitEnumTypes :
        FastDict.Dict
            String
            { isShow : Bool
            , isEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.Type
    -> MoonbitType
type_ context inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            MoonbitTypeVariable
                (variable.name
                    |> toPascalCaseMoonbitName
                )

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            typeNotVariable context
                inferredTypeNotVariable


typeNotVariable :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , moonbitEnumTypes :
        FastDict.Dict
            String
            { isShow : Bool
            , isEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> MoonbitType
typeNotVariable context inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            MoonbitTypeConstruct
                { qualification = []
                , name = "Unit"
                , arguments = []
                , isEq = True
                , isShow = True
                }

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                moonbitArguments : List MoonbitType
                moonbitArguments =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> type_ context
                            )
            in
            case
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                }
                    |> typeConstructReferenceToCoreMoonbit
            of
                Just coreMoonbit ->
                    MoonbitTypeConstruct
                        { arguments = moonbitArguments
                        , name = coreMoonbit.name
                        , qualification = coreMoonbit.qualification
                        , isShow = coreMoonbit.isShow
                        , isEq = coreMoonbit.isEq
                        }

                Nothing ->
                    let
                        moonbitName : String
                        moonbitName =
                            { moduleOrigin = typeConstruct.moduleOrigin
                            , name = typeConstruct.name
                            }
                                |> elmReferenceToPascalCaseMoonbitName

                        isTypeAlias : Bool
                        isTypeAlias =
                            case context.typeAliasesInModule typeConstruct.moduleOrigin of
                                Nothing ->
                                    False

                                Just inModule ->
                                    inModule |> FastDict.member typeConstruct.name
                    in
                    if isTypeAlias then
                        let
                            typeAliasExpanded : ElmSyntaxTypeInfer.Type
                            typeAliasExpanded =
                                ElmSyntaxTypeInfer.TypeConstruct typeConstruct
                                    |> inferredTypeNotVariableExpandInnerAliases
                                        context.typeAliasesInModule

                            expandedMoonbitType : MoonbitType
                            expandedMoonbitType =
                                typeAliasExpanded
                                    |> type_ context
                        in
                        MoonbitTypeConstruct
                            { arguments = moonbitArguments
                            , qualification = []
                            , name = moonbitName
                            , isShow =
                                expandedMoonbitType
                                    |> moonbitTypeIsShow { variablesAreShow = True }
                            , isEq =
                                expandedMoonbitType
                                    |> moonbitTypeIsEq { variablesAreEq = True }
                            }

                    else
                        case context.moonbitEnumTypes |> FastDict.get moonbitName of
                            -- it's a (mutually) recursive enum, so it must have referenced parts
                            -- and therefore also has a lifetime parameter
                            Nothing ->
                                MoonbitTypeConstruct
                                    { arguments = moonbitArguments
                                    , qualification = []
                                    , name = moonbitName
                                    , isShow = {- TODO this is a wrong assumption -} True
                                    , isEq = {- TODO this is a wrong assumption -} True
                                    }

                            Just originMoonbitEnumType ->
                                MoonbitTypeConstruct
                                    { arguments = moonbitArguments
                                    , qualification = []
                                    , name = moonbitName
                                    , isShow = originMoonbitEnumType.isShow
                                    , isEq = originMoonbitEnumType.isEq
                                    }

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            MoonbitTypeTuple
                { part0 =
                    typeTuple.part0 |> type_ context
                , part1 =
                    typeTuple.part1 |> type_ context
                , part2Up = []
                }

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            MoonbitTypeTuple
                { part0 =
                    typeTriple.part0 |> type_ context
                , part1 =
                    typeTriple.part1 |> type_ context
                , part2Up =
                    [ typeTriple.part2 |> type_ context ]
                }

        ElmSyntaxTypeInfer.TypeRecord recordFields ->
            MoonbitTypeRecordStruct
                { name =
                    generatedRecordStructTypeName
                        (recordFields |> FastDict.keys)
                , fields =
                    recordFields
                        |> FastDict.foldr
                            (\elmFieldName valueType soFar ->
                                soFar
                                    |> FastDict.insert
                                        (elmFieldName |> toSnakeCaseMoonbitName)
                                        (valueType |> type_ context)
                            )
                            FastDict.empty
                }

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            MoonbitTypeFunction
                { input = [ typeFunction.input |> type_ context ]
                , output = typeFunction.output |> type_ context
                }

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            -- Err
            --     ((typeRange |> rangeToInfoString)
            --         ++ " extensible record types are not supported"
            --     )
            MoonbitTypeRecordStruct
                { name =
                    generatedRecordStructTypeName
                        (typeRecordExtension.fields
                            |> FastDict.keys
                        )
                , fields =
                    typeRecordExtension.fields
                        |> FastDict.foldr
                            (\elmFieldName valueType soFar ->
                                soFar
                                    |> FastDict.insert
                                        (elmFieldName |> toSnakeCaseMoonbitName)
                                        (valueType |> type_ context)
                            )
                            FastDict.empty
                }


printMoonbitTypeNotParenthesized : MoonbitType -> Print
printMoonbitTypeNotParenthesized moonbitType =
    -- IGNORE TCO
    case moonbitType of
        MoonbitTypeInfer ->
            Print.exactly "_"

        MoonbitTypeVariable variable ->
            Print.exactly variable

        MoonbitTypeConstruct typeConstruct ->
            printMoonbitTypeConstruct
                { qualification = typeConstruct.qualification
                , name = typeConstruct.name
                , arguments = typeConstruct.arguments
                }

        MoonbitTypeRecordStruct recordStruct ->
            printMoonbitTypeConstruct
                { qualification = []
                , name = recordStruct.name
                , arguments = recordStruct.fields |> FastDict.values
                }

        MoonbitTypeTuple parts ->
            printMoonbitTypeTuple parts

        MoonbitTypeFunction typeFunction ->
            printMoonbitTypeFunction typeFunction


printMoonbitTypeFunctionInput : List MoonbitType -> Print
printMoonbitTypeFunctionInput input =
    let
        input0PartPrints : List Print
        input0PartPrints =
            input
                |> List.map printMoonbitTypeNotParenthesized

        input0LineSpread : Print.LineSpread
        input0LineSpread =
            input0PartPrints
                |> Print.lineSpreadListMapAndCombine Print.lineSpread
    in
    printParenthesized
        (input0PartPrints
            |> Print.listMapAndIntersperseAndFlatten
                (\inputPart -> inputPart)
                (printExactlyComma
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented input0LineSpread)
                )
        )


inferredTypeToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeToFunction typeAliasesInModule inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeNotVariable aliasTypeNotVariable ->
            inferredTypeNotVariableToFunction typeAliasesInModule
                aliasTypeNotVariable


inferredTypeNotVariableToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeNotVariableToFunction typeAliasesInModule inferredTypeNotFunction =
    case inferredTypeNotFunction of
        ElmSyntaxTypeInfer.TypeUnit ->
            Nothing

        ElmSyntaxTypeInfer.TypeTuple _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeTriple _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeRecord _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
            Nothing

        ElmSyntaxTypeInfer.TypeFunction inferredTypeFunction ->
            Just inferredTypeFunction

        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
            inferredTypeConstructToFunction typeAliasesInModule
                inferredTypeConstruct


inferredTypeConstructToFunction :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    ->
        { moduleOrigin : String
        , name : String
        , arguments : List ElmSyntaxTypeInfer.Type
        }
    -> Maybe { input : ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeConstructToFunction typeAliasesInModule inferredTypeConstruct =
    case
        typeAliasesInModule inferredTypeConstruct.moduleOrigin
            |> Maybe.andThen
                (\byName ->
                    byName |> FastDict.get inferredTypeConstruct.name
                )
    of
        Nothing ->
            Nothing

        Just referencedTypeAlias ->
            case referencedTypeAlias.type_ of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- identity type alias
                    case inferredTypeConstruct.arguments of
                        [] ->
                            Nothing

                        typeAliasArgument :: _ ->
                            inferredTypeToFunction typeAliasesInModule
                                typeAliasArgument

                ElmSyntaxTypeInfer.TypeNotVariable aliasTypeNotVariable ->
                    inferredTypeNotVariableToFunction typeAliasesInModule
                        aliasTypeNotVariable


inferredTypeExpandToFunction :
    ElmSyntaxTypeInfer.Type
    -> { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeExpandToFunction inferredType =
    inferredTypeExpandFunctionIntoReverse [] inferredType


inferredTypeExpandFunctionIntoReverse :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
inferredTypeExpandFunctionIntoReverse soFarReverse inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            { inputs = soFarReverse |> List.reverse
            , output = inferredType
            }

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            case inferredTypeNotVariable of
                ElmSyntaxTypeInfer.TypeFunction function ->
                    inferredTypeExpandFunctionIntoReverse
                        (function.input :: soFarReverse)
                        function.output

                ElmSyntaxTypeInfer.TypeUnit ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeConstruct _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeTuple _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeTriple _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeRecord _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }

                ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                    { inputs = soFarReverse |> List.reverse
                    , output = inferredType
                    }


printMoonbitTypeTuple :
    { part0 : MoonbitType, part1 : MoonbitType, part2Up : List MoonbitType }
    -> Print
printMoonbitTypeTuple parts =
    let
        part0Print : Print
        part0Print =
            parts.part0 |> printMoonbitTypeNotParenthesized

        part1Print : Print
        part1Print =
            parts.part1 |> printMoonbitTypeNotParenthesized

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printMoonbitTypeNotParenthesized

        lineSpread : Print.LineSpread
        lineSpread =
            (part0Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part1Print |> Print.lineSpread
                    )
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine Print.lineSpread
                    )
    in
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                ((part0Print :: part1Print :: part2UpPrints)
                    |> Print.listMapAndIntersperseAndFlatten
                        (\partPrint -> partPrint)
                        (printExactlyComma
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented lineSpread)
                        )
                )
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosing


printMoonbitTypeConstruct :
    { qualification : List String
    , name : String
    , arguments : List MoonbitType
    }
    -> Print
printMoonbitTypeConstruct typeConstruct =
    let
        referencePrint : Print
        referencePrint =
            Print.exactly
                (qualifiedMoonbitReferenceToString
                    { qualification = typeConstruct.qualification
                    , name = typeConstruct.name
                    }
                )
    in
    case
        typeConstruct.arguments
            |> List.map printMoonbitTypeNotParenthesized
    of
        [] ->
            referencePrint

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    argument0 :: argument1Up

                fullLineSpread : Print.LineSpread
                fullLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            referencePrint
                |> Print.followedBy (Print.exactly "[")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented fullLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented fullLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented fullLineSpread)
                |> Print.followedBy
                    (Print.exactly "]")


int64Literal : Int -> String
int64Literal int =
    (int |> String.fromInt) ++ "L"


doubleLiteral : Float -> String
doubleLiteral float =
    let
        asString : String
        asString =
            float |> String.fromFloat
    in
    if asString |> String.contains "e" then
        float |> floatToDecimalString

    else if asString |> String.contains "." then
        asString

    else
        asString ++ ".0"


{-| Transforms a `Float` in scientific notation into its decimal representation
as a `String`.

    x = 1e30
    toDecimal x -- outputs "1000000000000000000000000000000"

    x = 1.2345e-30
    toDecimal x -- outputs "0.0000000000000000000000000000012345"

The implementation is a modified version of `myrho/elm-round`'s `Round.toDecimal`
which is licensed under:

BSD 3-Clause License

Copyright (c) 2018, Matthias Rella
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-}
floatToDecimalString : Float -> String
floatToDecimalString float =
    case float |> Basics.abs |> String.fromFloat |> String.split "e" of
        beforeExponentAsString :: exponentAsString :: _ ->
            let
                exponent : Int
                exponent =
                    (if String.startsWith "+" exponentAsString then
                        String.dropLeft 1 exponentAsString

                     else
                        exponentAsString
                    )
                        |> String.toInt
                        |> Maybe.withDefault 0

                total : String
                total =
                    case beforeExponentAsString |> String.split "." of
                        beforeComma :: afterComma :: _ ->
                            beforeComma ++ afterComma

                        [ beforeComma ] ->
                            beforeComma ++ "0"

                        [] ->
                            "0"

                zeroed : String
                zeroed =
                    if exponent < 0 then
                        String.repeat (Basics.abs exponent) "0"
                            ++ total
                            |> String.uncons
                            |> Maybe.map (\( a, b ) -> String.fromChar a ++ "." ++ b)
                            |> Maybe.withDefault "0"

                    else
                        String.padRight (exponent + 1) '0' total
            in
            (if float < 0 then
                "-"

             else
                ""
            )
                ++ zeroed

        [ floatAsString ] ->
            (if float < 0 then
                "-"

             else
                ""
            )
                ++ floatAsString

        [] ->
            ""


printMoonbitCharLiteral : Char -> Print
printMoonbitCharLiteral char =
    Print.exactly ("'" ++ (char |> charToEscaped) ++ "'")


charToEscaped : Char -> String
charToEscaped character =
    case character of
        '\'' ->
            "\\'"

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u{" ++ characterHex otherCharacter ++ "}"

            else
                String.fromChar otherCharacter


printMoonbitStringLiteral : String -> Print
printMoonbitStringLiteral stringContent =
    let
        singleDoubleQuotedStringContentEscaped : String
        singleDoubleQuotedStringContentEscaped =
            stringContent
                |> String.foldl
                    (\contentChar soFar ->
                        soFar ++ singleDoubleQuotedStringCharToEscaped contentChar ++ ""
                    )
                    ""
    in
    Print.exactly ("\"" ++ singleDoubleQuotedStringContentEscaped ++ "\"")


singleDoubleQuotedStringCharToEscaped : Char -> String
singleDoubleQuotedStringCharToEscaped character =
    case character of
        '"' ->
            "\\\""

        '\\' ->
            "\\\\"

        '\t' ->
            "\\t"

        '\n' ->
            "\\n"

        '\u{000D}' ->
            "\\r"

        otherCharacter ->
            if characterIsNotPrint otherCharacter then
                "\\u{" ++ characterHex otherCharacter ++ "}"

            else
                String.fromChar otherCharacter


hexDigitIntToString : Int -> String
hexDigitIntToString int =
    case int of
        0 ->
            "0"

        1 ->
            "1"

        2 ->
            "2"

        3 ->
            "3"

        4 ->
            "4"

        5 ->
            "5"

        6 ->
            "6"

        7 ->
            "7"

        8 ->
            "8"

        9 ->
            "9"

        10 ->
            "A"

        11 ->
            "B"

        12 ->
            "C"

        13 ->
            "D"

        14 ->
            "E"

        -- 15
        _ ->
            "F"


characterHex : Char -> String
characterHex character =
    let
        charCode : Int
        charCode =
            Char.toCode character
    in
    String.toUpper
        (hexDigitIntToString
            (charCode
                |> Bitwise.and 0xF000
                |> Bitwise.shiftRightBy 12
            )
            ++ hexDigitIntToString
                (charCode
                    |> Bitwise.and 0x0F00
                    |> Bitwise.shiftRightBy 8
                )
            ++ hexDigitIntToString
                (charCode
                    |> Bitwise.and 0xF0
                    |> Bitwise.shiftRightBy 4
                )
            ++ hexDigitIntToString
                (charCode |> Bitwise.and 0x0F)
            ++ ""
        )


characterIsNotPrint : Char -> Bool
characterIsNotPrint character =
    if
        -- Unicode.getCategory is very expensive so we shortcut if at all possible
        charIsLatinAlphaNumOrUnderscoreFast character
            || (case character of
                    ' ' ->
                        True

                    '.' ->
                        True

                    '!' ->
                        True

                    '?' ->
                        True

                    '-' ->
                        True

                    ':' ->
                        True

                    _ ->
                        False
               )
    then
        False

    else
        case Unicode.getCategory character of
            Nothing ->
                True

            Just category ->
                case category of
                    Unicode.SeparatorLine ->
                        True

                    Unicode.SeparatorParagraph ->
                        True

                    Unicode.OtherControl ->
                        True

                    Unicode.OtherFormat ->
                        True

                    Unicode.OtherSurrogate ->
                        True

                    Unicode.OtherPrivateUse ->
                        True

                    Unicode.OtherNotAssigned ->
                        True

                    Unicode.LetterUppercase ->
                        False

                    Unicode.LetterLowercase ->
                        False

                    Unicode.LetterTitlecase ->
                        False

                    Unicode.MarkNonSpacing ->
                        False

                    Unicode.MarkSpacingCombining ->
                        False

                    Unicode.MarkEnclosing ->
                        False

                    Unicode.NumberDecimalDigit ->
                        False

                    Unicode.NumberLetter ->
                        False

                    Unicode.NumberOther ->
                        False

                    Unicode.SeparatorSpace ->
                        True

                    Unicode.LetterModifier ->
                        False

                    Unicode.LetterOther ->
                        False

                    Unicode.PunctuationConnector ->
                        False

                    Unicode.PunctuationDash ->
                        False

                    Unicode.PunctuationOpen ->
                        False

                    Unicode.PunctuationClose ->
                        False

                    Unicode.PunctuationInitialQuote ->
                        False

                    Unicode.PunctuationFinalQuote ->
                        False

                    Unicode.PunctuationOther ->
                        False

                    Unicode.SymbolMath ->
                        False

                    Unicode.SymbolCurrency ->
                        False

                    Unicode.SymbolModifier ->
                        False

                    Unicode.SymbolOther ->
                        False


charCodeIsLower : Int -> Bool
charCodeIsLower code =
    0x61 <= code && code <= 0x7A


charCodeIsUpper : Int -> Bool
charCodeIsUpper code =
    code <= 0x5A && 0x41 <= code


charCodeIsDigit : Int -> Bool
charCodeIsDigit code =
    code <= 0x39 && 0x30 <= code


charIsLatinAlphaNumOrUnderscoreFast : Char -> Bool
charIsLatinAlphaNumOrUnderscoreFast c =
    let
        code : Int
        code =
            Char.toCode c
    in
    charCodeIsLower code
        || charCodeIsUpper code
        || charCodeIsDigit code
        || -- (c == '_')
           (code == 95)


toSnakeCaseMoonbitName : String -> String
toSnakeCaseMoonbitName name =
    name
        |> toSnakeCase
        |> variableNameDisambiguateFromMoonbitKeywords


toSnakeCase : String -> String
toSnakeCase string =
    string
        |> stringFirstCharToLower
        |> String.toList
        |> List.map
            (\char ->
                if char |> Char.isUpper then
                    "_" ++ (char |> Char.toLower |> String.fromChar)

                else
                    char |> String.fromChar
            )
        |> String.concat


toPascalCaseMoonbitName : String -> String
toPascalCaseMoonbitName name =
    name
        |> String.replace "_" "0"
        |> stringFirstCharToUpper
        |> variableNameDisambiguateFromMoonbitKeywords


stringFirstCharToUpper : String -> String
stringFirstCharToUpper string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( firstChar, tail ) ->
            String.cons (firstChar |> Char.toUpper) tail


stringFirstCharToLower : String -> String
stringFirstCharToLower string =
    case string |> String.uncons of
        Nothing ->
            ""

        Just ( firstChar, tail ) ->
            String.cons (firstChar |> Char.toLower) tail


moonbitPatternListEmpty : MoonbitPattern
moonbitPatternListEmpty =
    MoonbitPatternVariant
        { originTypeName = [ "list", "List" ]
        , name = "Empty"
        , values = []
        }


moonbitPatternListMore : MoonbitPattern -> MoonbitPattern -> MoonbitPattern
moonbitPatternListMore head tail =
    MoonbitPatternVariant
        { originTypeName = [ "list", "List" ]
        , name = "More"
        , values =
            [ { label = Nothing, pattern = head }
            , { label = Just "tail", pattern = tail }
            ]
        }


pattern :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , moonbitEnumTypes :
        FastDict.Dict
            String
            { isShow : Bool
            , isEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
    ->
        { pattern : MoonbitPattern
        , guardConditions : List MoonbitExpression
        }
pattern context patternInferred =
    -- IGNORE TCO
    case patternInferred.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            { pattern = MoonbitPatternIgnore
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternUnit ->
            { pattern = MoonbitPatternIgnore
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternChar charValue ->
            { pattern = MoonbitPatternChar charValue
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternString stringValue ->
            let
                generatedStringBindingName : String
                generatedStringBindingName =
                    stringAsGeneratedMoonbitPatternBindingName stringValue
            in
            { pattern =
                MoonbitPatternVariable
                    { name = generatedStringBindingName
                    , type_ = moonbitTypeStringString
                    }
            , guardConditions =
                [ MoonbitExpressionCall
                    { called = moonbitExpressionReferenceStringEqualsStr
                    , arguments =
                        [ MoonbitExpressionReference
                            { qualification = [], name = generatedStringBindingName }
                        , MoonbitExpressionString stringValue
                        ]
                    }
                ]
            }

        ElmSyntaxTypeInfer.PatternInt intValue ->
            { pattern = MoonbitPatternInteger intValue.value
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternVariable variableName ->
            { pattern =
                MoonbitPatternVariable
                    { name = variableName |> toSnakeCaseMoonbitName
                    , type_ = patternInferred.type_ |> type_ context
                    }
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            pattern context inParens

        ElmSyntaxTypeInfer.PatternTuple parts ->
            let
                moonbitPart0 :
                    { pattern : MoonbitPattern
                    , guardConditions : List MoonbitExpression
                    }
                moonbitPart0 =
                    parts.part0 |> pattern context

                moonbitPart1 :
                    { pattern : MoonbitPattern
                    , guardConditions : List MoonbitExpression
                    }
                moonbitPart1 =
                    parts.part1 |> pattern context
            in
            { pattern =
                MoonbitPatternTuple
                    { part0 = moonbitPart0.pattern
                    , part1 = moonbitPart1.pattern
                    , part2Up = []
                    }
            , guardConditions =
                moonbitPart0.guardConditions
                    ++ moonbitPart1.guardConditions
            }

        ElmSyntaxTypeInfer.PatternTriple parts ->
            let
                moonbitPart0 :
                    { pattern : MoonbitPattern
                    , guardConditions : List MoonbitExpression
                    }
                moonbitPart0 =
                    parts.part0 |> pattern context

                moonbitPart1 :
                    { pattern : MoonbitPattern
                    , guardConditions : List MoonbitExpression
                    }
                moonbitPart1 =
                    parts.part1 |> pattern context

                moonbitPart2 :
                    { pattern : MoonbitPattern
                    , guardConditions : List MoonbitExpression
                    }
                moonbitPart2 =
                    parts.part2 |> pattern context
            in
            { pattern =
                MoonbitPatternTuple
                    { part0 = moonbitPart0.pattern
                    , part1 = moonbitPart1.pattern
                    , part2Up = [ moonbitPart2.pattern ]
                    }
            , guardConditions =
                moonbitPart0.guardConditions
                    ++ moonbitPart1.guardConditions
                    ++ moonbitPart2.guardConditions
            }

        ElmSyntaxTypeInfer.PatternRecord patternFields ->
            let
                allRecordFieldsIncludingOmitted : FastDict.Dict String ElmSyntaxTypeInfer.Type
                allRecordFieldsIncludingOmitted =
                    case patternInferred.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredTypeRecord) ->
                            inferredTypeRecord

                        _ ->
                            -- error?
                            patternFields
                                |> List.map
                                    (\patternField ->
                                        ( patternField.value
                                        , ElmSyntaxTypeInfer.TypeNotVariable
                                            ElmSyntaxTypeInfer.TypeUnit
                                        )
                                    )
                                |> FastDict.fromList
            in
            { pattern =
                MoonbitPatternStructNotExhaustive
                    { name =
                        generatedRecordStructTypeName
                            (allRecordFieldsIncludingOmitted
                                |> FastDict.keys
                            )
                    , fields =
                        patternFields
                            |> List.foldl
                                (\field soFar ->
                                    let
                                        moonbitFieldName : String
                                        moonbitFieldName =
                                            field.value |> toSnakeCaseMoonbitName
                                    in
                                    soFar
                                        |> FastDict.insert moonbitFieldName
                                            (MoonbitPatternVariable
                                                { name = moonbitFieldName
                                                , type_ =
                                                    case allRecordFieldsIncludingOmitted |> FastDict.get field.value of
                                                        Nothing ->
                                                            MoonbitTypeInfer

                                                        Just inferredType ->
                                                            inferredType |> type_ context
                                                }
                                            )
                                )
                                FastDict.empty
                    }
            , guardConditions = []
            }

        ElmSyntaxTypeInfer.PatternListCons listCons ->
            let
                moonbitHead :
                    { pattern : MoonbitPattern
                    , guardConditions : List MoonbitExpression
                    }
                moonbitHead =
                    listCons.head |> pattern context

                moonbitTailPattern :
                    { pattern : MoonbitPattern
                    , guardConditions : List MoonbitExpression
                    }
                moonbitTailPattern =
                    listCons.tail |> pattern context
            in
            { pattern =
                moonbitPatternListMore moonbitHead.pattern
                    moonbitTailPattern.pattern
            , guardConditions =
                moonbitHead.guardConditions
                    ++ moonbitTailPattern.guardConditions
            }

        ElmSyntaxTypeInfer.PatternListExact elementPatterns ->
            case elementPatterns of
                [] ->
                    { pattern = moonbitPatternListEmpty
                    , guardConditions = []
                    }

                head :: tail ->
                    let
                        moonbitHead :
                            { pattern : MoonbitPattern
                            , guardConditions : List MoonbitExpression
                            }
                        moonbitHead =
                            head |> pattern context

                        moonbitTailPattern :
                            { pattern : MoonbitPattern
                            , guardConditions : List MoonbitExpression
                            }
                        moonbitTailPattern =
                            tail |> patternListExact context
                    in
                    { pattern =
                        moonbitPatternListMore moonbitHead.pattern
                            moonbitTailPattern.pattern
                    , guardConditions =
                        moonbitHead.guardConditions
                            ++ moonbitTailPattern.guardConditions
                    }

        ElmSyntaxTypeInfer.PatternVariant variant ->
            let
                reference :
                    { originTypeName : List String
                    , name : String
                    , referencedValueIndexes : List Int
                    }
                reference =
                    case
                        { moduleOrigin = variant.moduleOrigin
                        , name = variant.name
                        , type_ = patternInferred.type_
                        }
                            |> variantToCoreMoonbit
                    of
                        Just moonbitReference ->
                            moonbitReference

                        Nothing ->
                            let
                                originTypeMoonbitName : String
                                originTypeMoonbitName =
                                    { moduleOrigin = variant.moduleOrigin
                                    , name = variant.choiceTypeName
                                    }
                                        |> elmReferenceToPascalCaseMoonbitName
                            in
                            { originTypeName = [ originTypeMoonbitName ]
                            , name = variant.name |> toPascalCaseMoonbitName
                            , referencedValueIndexes =
                                case context.moonbitEnumTypes |> FastDict.get originTypeMoonbitName of
                                    Nothing ->
                                        -- error
                                        []

                                    Just originMoonbitEnumType ->
                                        originMoonbitEnumType.variantReferencedValueIndexes
                                            |> FastDict.get (variant.name |> toPascalCaseMoonbitName)
                                            |> Maybe.withDefault []
                            }

                moonbitValues :
                    { patterns : List { label : Maybe String, pattern : MoonbitPattern }
                    , guardConditions : List MoonbitExpression
                    }
                moonbitValues =
                    variant.values
                        |> List.foldr
                            (\variantValue soFar ->
                                let
                                    moonbitValue :
                                        { pattern : MoonbitPattern
                                        , guardConditions : List MoonbitExpression
                                        }
                                    moonbitValue =
                                        variantValue |> pattern context
                                in
                                { patterns =
                                    { label = Nothing
                                    , pattern = moonbitValue.pattern
                                    }
                                        :: soFar.patterns
                                , guardConditions =
                                    moonbitValue.guardConditions
                                        ++ soFar.guardConditions
                                }
                            )
                            { patterns = []
                            , guardConditions = []
                            }
            in
            { pattern =
                MoonbitPatternVariant
                    { originTypeName = reference.originTypeName
                    , name = reference.name
                    , values = moonbitValues.patterns
                    }
            , guardConditions = moonbitValues.guardConditions
            }

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            let
                dereferencedAliasBindingName : String
                dereferencedAliasBindingName =
                    patternAs.variable.value |> toSnakeCaseMoonbitName

                moonbitType : MoonbitType
                moonbitType =
                    patternAs.variable.type_ |> type_ context

                moonbitPattern :
                    { pattern : MoonbitPattern
                    , guardConditions : List MoonbitExpression
                    }
                moonbitPattern =
                    patternAs.pattern |> pattern context
            in
            { pattern =
                MoonbitPatternAlias
                    { variable = dereferencedAliasBindingName
                    , type_ = moonbitType
                    , pattern = moonbitPattern.pattern
                    }
            , guardConditions = moonbitPattern.guardConditions
            }


moonbitExpressionReferenceBasicsEq : MoonbitExpression
moonbitExpressionReferenceBasicsEq =
    MoonbitExpressionReference
        { qualification = []
        , name = "basics_eq"
        }


moonbitExpressionReferenceStringEqualsStr : MoonbitExpression
moonbitExpressionReferenceStringEqualsStr =
    MoonbitExpressionReference
        { qualification = [], name = "string_equals_str" }


stringAsGeneratedMoonbitPatternBindingName : String -> String
stringAsGeneratedMoonbitPatternBindingName stringValue =
    let
        sanitizedStringValue : String
        sanitizedStringValue =
            stringValue
                |> String.toList
                |> List.map
                    (\char ->
                        if (char |> Char.isLower) || (char |> Char.isDigit) then
                            String.fromChar char

                        else
                            "_u"
                                ++ (char
                                        |> Char.toCode
                                        |> String.fromInt
                                   )
                                ++ "_"
                    )
                |> String.concat
    in
    ("generated_string"
        ++ sanitizedStringValue
    )
        |> String.replace "__" "_"


patternListExact :
    { typeAliasesInModule :
        String
        ->
            Maybe
                (FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                )
    , moonbitEnumTypes :
        FastDict.Dict
            String
            { isShow : Bool
            , isEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    }
    -> List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
    ->
        { pattern : MoonbitPattern
        , guardConditions : List MoonbitExpression
        }
patternListExact context elements =
    elements
        |> List.foldr
            (\element soFar ->
                let
                    moonbitElement :
                        { pattern : MoonbitPattern
                        , guardConditions : List MoonbitExpression
                        }
                    moonbitElement =
                        element |> pattern context
                in
                { pattern = moonbitPatternListMore moonbitElement.pattern soFar.pattern
                , guardConditions =
                    moonbitElement.guardConditions
                        ++ soFar.guardConditions
                }
            )
            { pattern = moonbitPatternListEmpty
            , guardConditions = []
            }


typeConstructReferenceToCoreMoonbit :
    { moduleOrigin : String
    , name : String
    }
    ->
        Maybe
            { qualification : List String
            , name : String
            , isShow : Bool
            , isEq : Bool
            }
typeConstructReferenceToCoreMoonbit reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "Order" ->
                    Just
                        { qualification = []
                        , name = "BasicsOrder"
                        , isShow = True
                        , isEq = True
                        }

                "Bool" ->
                    justMoonbitReferenceBool

                "Int" ->
                    justMoonbitReferenceInt64

                "Float" ->
                    justMoonbitReferenceDouble

                "Never" ->
                    Just
                        { qualification = []
                        , name = "BasicsNever"
                        , isShow = True
                        , isEq = True
                        }

                _ ->
                    Nothing

        "String" ->
            -- "String" is the only possible reference.name
            justMoonbitReferenceStringString

        "Char" ->
            -- "Char" is the only possible reference.name
            justMoonbitReferenceChar

        "List" ->
            -- "List" is the only possible reference.name
            justMoonbitReferenceListList

        "Array" ->
            -- "Array" is the only possible reference.name
            Just
                { qualification = [ "immut", "array" ]
                , name = "T"
                , isShow = True
                , isEq = True
                }

        "Dict" ->
            -- "Dict" is the only possible reference.name
            Just
                { qualification = [ "immut", "sorted_map" ]
                , name = "SortedMap"
                , isShow = True
                , isEq = True
                }

        "Set" ->
            -- "Set" is the only possible reference.name
            Just
                { qualification = [ "immut", "sorted_set" ]
                , name = "SortedSet"
                , isShow = True
                , isEq = True
                }

        "Maybe" ->
            -- "Maybe" is the only possible reference.name
            justMoonbitReferenceOption

        "Result" ->
            -- "Result" is the only possible reference.name
            justMoonbitReferenceResultResult

        "Json.Encode" ->
            -- "Value" is the only possible reference.name
            Just
                { qualification = []
                , name = "JsonValue"
                , isShow = True
                , isEq = True
                }

        "Json.Decode" ->
            case reference.name of
                "Value" ->
                    Just
                        { qualification = []
                        , name = "JsonValue"
                        , isShow = True
                        , isEq = True
                        }

                "Decoder" ->
                    Just
                        { qualification = []
                        , name = "JsonDecodeDecoder"
                        , isShow = False
                        , isEq = False
                        }

                "Error" ->
                    Just
                        { qualification = []
                        , name = "JsonDecodeError"
                        , isShow = True
                        , isEq = True
                        }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "Seed" ->
                    Just
                        { qualification = []
                        , name = "RandomSeed"
                        , isShow = True
                        , isEq = True
                        }

                "Generator" ->
                    Just
                        { qualification = []
                        , name = "RandomGenerator"
                        , isShow = False
                        , isEq = False
                        }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "Posix" ->
                    Just
                        { qualification = []
                        , name = "TimePosix"
                        , isShow = True
                        , isEq = True
                        }

                "Zone" ->
                    Just
                        { qualification = []
                        , name = "TimeZone"
                        , isShow = True
                        , isEq = True
                        }

                "Month" ->
                    Just
                        { qualification = []
                        , name = "TimeMonth"
                        , isShow = True
                        , isEq = True
                        }

                "Weekday" ->
                    Just
                        { qualification = []
                        , name = "TimeWeekday"
                        , isShow = True
                        , isEq = True
                        }

                "ZoneName" ->
                    Just
                        { qualification = []
                        , name = "TimeZoneName"
                        , isShow = True
                        , isEq = True
                        }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "Endianness" ->
                    Just
                        { qualification = []
                        , name = "BytesEndianness"
                        , isShow = True
                        , isEq = True
                        }

                "Bytes" ->
                    Just
                        { qualification = []
                        , name = "BytesBytes"
                        , isShow = True
                        , isEq = True
                        }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Decoder" ->
                    Just
                        { qualification = []
                        , name = "BytesDecodeDecoder"
                        , isShow = False
                        , isEq = False
                        }

                "Step" ->
                    Just
                        { qualification = []
                        , name = "BytesDecodeStep"
                        , isShow = True
                        , isEq = True
                        }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            -- "Encoder" is the only possible reference.name
            Just
                { qualification = []
                , name = "BytesEncodeEncoder"
                , isShow = True
                , isEq = True
                }

        "VirtualDom" ->
            case reference.name of
                "Node" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomNode"
                        , isShow = False
                        , isEq = False
                        }

                "Attribute" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomAttribute"
                        , isShow = False
                        , isEq = False
                        }

                "Handler" ->
                    Just
                        { qualification = []
                        , name = "VirtualDomHandler"
                        , isShow = False
                        , isEq = False
                        }

                _ ->
                    Nothing

        "Math.Vector2" ->
            case reference.name of
                "Vec2" ->
                    Just
                        { qualification = []
                        , name = "MathVector2Vec2"
                        , isShow = True
                        , isEq = True
                        }

                _ ->
                    Nothing

        "Math.Vector3" ->
            case reference.name of
                "Vec3" ->
                    Just
                        { qualification = []
                        , name = "MathVector3Vec3"
                        , isShow = True
                        , isEq = True
                        }

                _ ->
                    Nothing

        "Math.Vector4" ->
            case reference.name of
                "Vec4" ->
                    Just
                        { qualification = []
                        , name = "MathVector4Vec4"
                        , isShow = True
                        , isEq = True
                        }

                _ ->
                    Nothing

        "Math.Matrix4" ->
            -- not supported, see readme
            Nothing

        "Platform" ->
            case reference.name of
                "Program" ->
                    Just
                        { qualification = []
                        , name = "PlatformProgram"
                        , isShow = False
                        , isEq = False
                        }

                -- "Task" | "ProcessId" | "Router"
                _ ->
                    Nothing

        "Platform.Cmd" ->
            -- "Cmd" is the only possible reference.name
            Just
                { qualification = []
                , name = "PlatformCmdCmd"
                , isShow = True
                , isEq = True
                }

        "Platform.Sub" ->
            -- "Sub" is the only possible reference.name
            Just
                { qualification = []
                , name = "PlatformSubSub"
                , isShow = False
                , isEq = False
                }

        _ ->
            Nothing


justMoonbitReferenceInt64 :
    Maybe
        { qualification : List String
        , name : String
        , isShow : Bool
        , isEq : Bool
        }
justMoonbitReferenceInt64 =
    Just moonbitReferenceInt64


moonbitReferenceInt64 :
    { qualification : List String
    , name : String
    , isShow : Bool
    , isEq : Bool
    }
moonbitReferenceInt64 =
    { qualification = []
    , name = "Int64"
    , isShow = True
    , isEq = True
    }


justMoonbitReferenceDouble :
    Maybe
        { qualification : List String
        , name : String
        , isShow : Bool
        , isEq : Bool
        }
justMoonbitReferenceDouble =
    Just moonbitReferenceDouble


moonbitReferenceDouble :
    { qualification : List String
    , name : String
    , isShow : Bool
    , isEq : Bool
    }
moonbitReferenceDouble =
    { qualification = []
    , name = "Double"
    , isShow = True
    , isEq = True
    }


justMoonbitReferenceBool :
    Maybe
        { qualification : List String
        , name : String
        , isShow : Bool
        , isEq : Bool
        }
justMoonbitReferenceBool =
    Just
        { qualification = []
        , name = "Bool"
        , isShow = True
        , isEq = True
        }


justMoonbitReferenceStringString :
    Maybe
        { qualification : List String
        , name : String
        , isShow : Bool
        , isEq : Bool
        }
justMoonbitReferenceStringString =
    Just
        { qualification = []
        , name = "StringString"
        , isShow = True
        , isEq = True
        }


moonbitTypeStringString : MoonbitType
moonbitTypeStringString =
    MoonbitTypeConstruct
        { qualification = []
        , name = "StringString"
        , arguments = []
        , isShow = True
        , isEq = True
        }


justMoonbitReferenceChar :
    Maybe
        { qualification : List String
        , name : String
        , isShow : Bool
        , isEq : Bool
        }
justMoonbitReferenceChar =
    Just
        { qualification = []
        , name = "Char"
        , isShow = True
        , isEq = True
        }


justMoonbitReferenceListList :
    Maybe
        { qualification : List String
        , name : String
        , isShow : Bool
        , isEq : Bool
        }
justMoonbitReferenceListList =
    Just
        { qualification = [ "list" ]
        , name = "List"
        , isShow = True
        , isEq = True
        }


justMoonbitReferenceOption :
    Maybe
        { qualification : List String
        , name : String
        , isShow : Bool
        , isEq : Bool
        }
justMoonbitReferenceOption =
    Just
        { qualification = []
        , name = "Option"
        , isShow = True
        , isEq = True
        }


justMoonbitReferenceResultResult :
    Maybe
        { qualification : List String
        , name : String
        , isShow : Bool
        , isEq : Bool
        }
justMoonbitReferenceResultResult =
    Just
        { qualification = []
        , name = "ResultResult"
        , isShow = True
        , isEq = True
        }


variantToCoreMoonbit :
    { moduleOrigin : String
    , name : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Maybe
            { originTypeName : List String
            , name : String
            , referencedValueIndexes : List Int
            }
variantToCoreMoonbit reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "LT" ->
                    Just { originTypeName = [ "BasicsOrder" ], name = "LT", referencedValueIndexes = [] }

                "EQ" ->
                    Just { originTypeName = [ "BasicsOrder" ], name = "EQ", referencedValueIndexes = [] }

                "GT" ->
                    Just { originTypeName = [ "BasicsOrder" ], name = "LT", referencedValueIndexes = [] }

                "True" ->
                    Just { originTypeName = [], name = "true", referencedValueIndexes = [] }

                "False" ->
                    Just { originTypeName = [], name = "false", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "Nothing" ->
                    Just { originTypeName = [ "Option" ], name = "None", referencedValueIndexes = [] }

                "Just" ->
                    Just { originTypeName = [ "Option" ], name = "Some", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "Err" ->
                    Just { originTypeName = [ "Result" ], name = "Err", referencedValueIndexes = [] }

                "Ok" ->
                    Just { originTypeName = [ "Result" ], name = "Ok", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "Field" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Field", referencedValueIndexes = [ 1 ] }

                "Index" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Index", referencedValueIndexes = [ 1 ] }

                "OneOf" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "OneOf", referencedValueIndexes = [ 0 ] }

                "Failure" ->
                    Just { originTypeName = [ "JsonDecodeError" ], name = "Failure", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "LE" ->
                    Just { originTypeName = [ "BytesEndianness" ], name = "LE", referencedValueIndexes = [] }

                "BE" ->
                    Just { originTypeName = [ "BytesEndianness" ], name = "BE", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "Normal" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "Normal", referencedValueIndexes = [] }

                "MayStopPropagation" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "MayStopPropagation", referencedValueIndexes = [] }

                "MayPreventDefault" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "MayPreventDefault", referencedValueIndexes = [] }

                "Custom" ->
                    Just { originTypeName = [ "VirtualDomHandler" ], name = "Custom", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "Loop" ->
                    Just { originTypeName = [ "BytesDecodeStep" ], name = "Loop", referencedValueIndexes = [] }

                "Done" ->
                    Just { originTypeName = [ "BytesDecodeStep" ], name = "Done", referencedValueIndexes = [] }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "Name" ->
                    Just { originTypeName = [ "TimeZoneName" ], name = "Name", referencedValueIndexes = [] }

                "Offset" ->
                    Just { originTypeName = [ "TimeZoneName" ], name = "Offset", referencedValueIndexes = [] }

                "Jan" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jan", referencedValueIndexes = [] }

                "Feb" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Feb", referencedValueIndexes = [] }

                "Mar" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Mar", referencedValueIndexes = [] }

                "Apr" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Apr", referencedValueIndexes = [] }

                "May" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "May", referencedValueIndexes = [] }

                "Jun" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jun", referencedValueIndexes = [] }

                "Jul" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Jul", referencedValueIndexes = [] }

                "Aug" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Aug", referencedValueIndexes = [] }

                "Sep" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Sep", referencedValueIndexes = [] }

                "Oct" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Oct", referencedValueIndexes = [] }

                "Nov" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Nov", referencedValueIndexes = [] }

                "Dec" ->
                    Just { originTypeName = [ "TimeMonth" ], name = "Dec", referencedValueIndexes = [] }

                "Mon" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Mon", referencedValueIndexes = [] }

                "Tue" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Tue", referencedValueIndexes = [] }

                "Wed" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Wed", referencedValueIndexes = [] }

                "Thu" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Thu", referencedValueIndexes = [] }

                "Fri" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Fri", referencedValueIndexes = [] }

                "Sat" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Sat", referencedValueIndexes = [] }

                "Sun" ->
                    Just { originTypeName = [ "TimeWeekday" ], name = "Sun", referencedValueIndexes = [] }

                _ ->
                    Nothing

        _ ->
            Nothing


justMoonbitReferenceIdentity :
    Maybe
        { qualification : List String
        , name : String
        }
justMoonbitReferenceIdentity =
    Just
        { qualification = []
        , name = "basics_identity"
        }


{-| Use `typeConstructReferenceToCoreMoonbit` for types
-}
referenceToCoreMoonbit :
    { moduleOrigin : String
    , name : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Maybe
            { qualification : List String
            , name : String
            }
referenceToCoreMoonbit reference =
    case reference.moduleOrigin of
        "Basics" ->
            case reference.name of
                "identity" ->
                    justMoonbitReferenceIdentity

                "always" ->
                    Just
                        { qualification = []
                        , name = "basics_always"
                        }

                "compare" ->
                    Just
                        { qualification = []
                        , name = "basics_compare"
                        }

                "max" ->
                    Just
                        { qualification = [ "cmp" ]
                        , name = "maximum"
                        }

                "min" ->
                    Just
                        { qualification = [ "cmp" ]
                        , name = "minimum"
                        }

                "not" ->
                    Just
                        { qualification = []
                        , name = "basics_not"
                        }

                "xor" ->
                    Just
                        { qualification = []
                        , name = "basics_neq"
                        }

                "e" ->
                    Just
                        { qualification = []
                        , name = "basics_e"
                        }

                "pi" ->
                    Just
                        { qualification = [ "math" ]
                        , name = "PI"
                        }

                "ceiling" ->
                    Just
                        { qualification = []
                        , name = "basics_ceiling"
                        }

                "floor" ->
                    Just
                        { qualification = []
                        , name = "basics_floor"
                        }

                "round" ->
                    Just
                        { qualification = []
                        , name = "basics_round"
                        }

                "truncate" ->
                    Just
                        { qualification = []
                        , name = "basics_truncate"
                        }

                "negate" ->
                    Just
                        { qualification = []
                        , name = "basics_negate"
                        }

                "abs" ->
                    Just
                        (case
                            case reference.type_ of
                                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                                    typeFunction.input |> inferredTypeCheckOrGuessIntOrFloat

                                _ ->
                                    -- assume Int
                                    IntNotFloat
                         of
                            FloatNotInt ->
                                { qualification = [ "double" ]
                                , name = "abs"
                                }

                            IntNotFloat ->
                                { qualification = [ "int64" ]
                                , name = "abs"
                                }
                        )

                "toFloat" ->
                    Just
                        { qualification = []
                        , name = "basics_to_float"
                        }

                "isNaN" ->
                    Just
                        { qualification = []
                        , name = "basics_is_nan"
                        }

                "isInfinite" ->
                    Just
                        { qualification = []
                        , name = "basics_is_infinite"
                        }

                "remainderBy" ->
                    Just
                        { qualification = []
                        , name = "basics_remainder_by"
                        }

                "modBy" ->
                    Just
                        { qualification = []
                        , name = "basics_mod_by"
                        }

                "sin" ->
                    Just
                        { qualification = [ "math" ]
                        , name = "sin"
                        }

                "cos" ->
                    Just
                        { qualification = [ "math" ]
                        , name = "cos"
                        }

                "tan" ->
                    Just
                        { qualification = [ "math" ]
                        , name = "tan"
                        }

                "asin" ->
                    Just
                        { qualification = [ "math" ]
                        , name = "asin"
                        }

                "acos" ->
                    Just
                        { qualification = [ "math" ]
                        , name = "acos"
                        }

                "atan" ->
                    Just
                        { qualification = [ "math" ]
                        , name = "atan"
                        }

                "atan2" ->
                    Just
                        { qualification = [ "math" ]
                        , name = "atan2"
                        }

                "sqrt" ->
                    Just
                        { qualification = []
                        , name = "basics_sqrt"
                        }

                "logBase" ->
                    Just
                        { qualification = []
                        , name = "basics_log_base"
                        }

                "radians" ->
                    justMoonbitReferenceIdentity

                "degrees" ->
                    Just
                        { qualification = []
                        , name = "basics_to_radians"
                        }

                "turns" ->
                    Just
                        { qualification = []
                        , name = "basics_turns"
                        }

                "fromPolar" ->
                    Just
                        { qualification = []
                        , name = "basics_from_polar"
                        }

                "toPolar" ->
                    Just
                        { qualification = []
                        , name = "basics_to_polar"
                        }

                "clamp" ->
                    Just
                        { qualification = []
                        , name = "basics_clamp"
                        }

                "never" ->
                    Just
                        { qualification = []
                        , name = "basics_never"
                        }

                _ ->
                    Nothing

        "Bitwise" ->
            case reference.name of
                "complement" ->
                    Just
                        { qualification = []
                        , name = "bitwise_complement"
                        }

                "and" ->
                    Just
                        { qualification = []
                        , name = "bitwise_and"
                        }

                "or" ->
                    Just
                        { qualification = []
                        , name = "bitwise_or"
                        }

                "xor" ->
                    Just
                        { qualification = []
                        , name = "bitwise_xor"
                        }

                "shiftLeftBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_left_by"
                        }

                "shiftRightBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_right_by"
                        }

                "shiftRightZfBy" ->
                    Just
                        { qualification = []
                        , name = "bitwise_shift_right_zf_by"
                        }

                _ ->
                    Nothing

        "String" ->
            case reference.name of
                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "string_is_empty"
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "string_length"
                        }

                "append" ->
                    Just
                        { qualification = []
                        , name = "string_append"
                        }

                "concat" ->
                    Just
                        { qualification = []
                        , name = "string_concat"
                        }

                "trim" ->
                    Just
                        { qualification = []
                        , name = "string_trim"
                        }

                "trimLeft" ->
                    Just
                        { qualification = []
                        , name = "string_trim_left"
                        }

                "trimRight" ->
                    Just
                        { qualification = []
                        , name = "string_trim_right"
                        }

                "left" ->
                    Just
                        { qualification = []
                        , name = "string_left"
                        }

                "right" ->
                    Just
                        { qualification = []
                        , name = "string_right"
                        }

                "dropLeft" ->
                    Just
                        { qualification = []
                        , name = "string_drop_left"
                        }

                "dropRight" ->
                    Just
                        { qualification = []
                        , name = "string_drop_right"
                        }

                "pad" ->
                    Just
                        { qualification = []
                        , name = "string_pad"
                        }

                "padLeft" ->
                    Just
                        { qualification = []
                        , name = "string_pad_left"
                        }

                "padRight" ->
                    Just
                        { qualification = []
                        , name = "string_pad_right"
                        }

                "replace" ->
                    Just
                        { qualification = []
                        , name = "string_replace"
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "string_reverse"
                        }

                "fromList" ->
                    Just
                        { qualification = []
                        , name = "string_from_list"
                        }

                "toList" ->
                    Just
                        { qualification = []
                        , name = "string_to_list"
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "string_foldl"
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "string_foldr"
                        }

                "join" ->
                    Just
                        { qualification = []
                        , name = "string_join"
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "string_filter"
                        }

                "any" ->
                    Just
                        { qualification = []
                        , name = "string_any"
                        }

                "all" ->
                    Just
                        { qualification = []
                        , name = "string_all"
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "string_map"
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "string_repeat"
                        }

                "split" ->
                    Just
                        { qualification = []
                        , name = "string_split"
                        }

                "lines" ->
                    Just
                        { qualification = []
                        , name = "string_lines"
                        }

                "words" ->
                    Just
                        { qualification = []
                        , name = "string_words"
                        }

                "startsWith" ->
                    Just
                        { qualification = []
                        , name = "string_starts_with"
                        }

                "endsWith" ->
                    Just
                        { qualification = []
                        , name = "string_ends_with"
                        }

                "toInt" ->
                    Just
                        { qualification = []
                        , name = "string_to_int"
                        }

                "toFloat" ->
                    Just
                        { qualification = []
                        , name = "string_to_float"
                        }

                "fromInt" ->
                    Just
                        { qualification = []
                        , name = "string_from_int"
                        }

                "fromFloat" ->
                    Just
                        { qualification = []
                        , name = "string_from_float"
                        }

                "contains" ->
                    Just
                        { qualification = []
                        , name = "string_contains"
                        }

                "fromChar" ->
                    Just
                        { qualification = []
                        , name = "string_from_char"
                        }

                "cons" ->
                    Just
                        { qualification = []
                        , name = "string_cons"
                        }

                "uncons" ->
                    Just
                        { qualification = []
                        , name = "string_uncons"
                        }

                "slice" ->
                    Just
                        { qualification = []
                        , name = "string_slice"
                        }

                "toLower" ->
                    Just
                        { qualification = []
                        , name = "string_to_lower"
                        }

                "toUpper" ->
                    Just
                        { qualification = []
                        , name = "string_to_upper"
                        }

                _ ->
                    Nothing

        "Char" ->
            case reference.name of
                "toCode" ->
                    Just
                        { qualification = []
                        , name = "char_to_code"
                        }

                "fromCode" ->
                    Just
                        { qualification = []
                        , name = "char_from_code"
                        }

                "toLower" ->
                    Just
                        { qualification = []
                        , name = "char_to_lower"
                        }

                "toUpper" ->
                    Just
                        { qualification = []
                        , name = "char_to_upper"
                        }

                "toLocaleLower" ->
                    Just
                        { qualification = []
                        , name = "char_to_lower"
                        }

                "toLocaleUpper" ->
                    Just
                        { qualification = []
                        , name = "char_to_upper"
                        }

                "isLower" ->
                    Just
                        { qualification = []
                        , name = "char_is_lower"
                        }

                "isUpper" ->
                    Just
                        { qualification = []
                        , name = "char_is_upper"
                        }

                "isHexDigit" ->
                    Just
                        { qualification = []
                        , name = "char_is_hex_digit"
                        }

                "isOctDigit" ->
                    Just
                        { qualification = []
                        , name = "char_is_oct_digit"
                        }

                "isDigit" ->
                    Just
                        { qualification = []
                        , name = "char_is_digit"
                        }

                "isAlpha" ->
                    Just
                        { qualification = []
                        , name = "char_is_alpha"
                        }

                "isAlphaNum" ->
                    Just
                        { qualification = []
                        , name = "char_is_alpha_num"
                        }

                _ ->
                    Nothing

        "List" ->
            case reference.name of
                "singleton" ->
                    Just
                        { qualification = []
                        , name = "list_singleton"
                        }

                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "list_is_empty"
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "list_length"
                        }

                "member" ->
                    Just
                        { qualification = []
                        , name = "list_member"
                        }

                "minimum" ->
                    Just
                        { qualification = []
                        , name = "list_minimum"
                        }

                "maximum" ->
                    Just
                        { qualification = []
                        , name = "list_maximum"
                        }

                "sum" ->
                    Just
                        (case
                            case reference.type_ of
                                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                                    typeFunction.output |> inferredTypeCheckOrGuessIntOrFloat

                                _ ->
                                    -- assume Int
                                    IntNotFloat
                         of
                            FloatNotInt ->
                                { qualification = []
                                , name = "list_sum_float"
                                }

                            IntNotFloat ->
                                { qualification = []
                                , name = "list_sum_int"
                                }
                        )

                "product" ->
                    Just
                        (case
                            case reference.type_ of
                                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                                    typeFunction.output |> inferredTypeCheckOrGuessIntOrFloat

                                _ ->
                                    -- assume Int
                                    IntNotFloat
                         of
                            FloatNotInt ->
                                { qualification = []
                                , name = "list_product_float"
                                }

                            IntNotFloat ->
                                { qualification = []
                                , name = "list_product_int"
                                }
                        )

                "append" ->
                    Just
                        { qualification = []
                        , name = "list_append"
                        }

                "concat" ->
                    Just
                        { qualification = []
                        , name = "list_concat"
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "list_reverse"
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "list_repeat"
                        }

                "head" ->
                    Just
                        { qualification = []
                        , name = "list_head"
                        }

                "tail" ->
                    Just
                        { qualification = []
                        , name = "list_tail"
                        }

                "all" ->
                    Just
                        { qualification = []
                        , name = "list_all"
                        }

                "any" ->
                    Just
                        { qualification = []
                        , name = "list_any"
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "list_filter"
                        }

                "filterMap" ->
                    Just
                        { qualification = []
                        , name = "list_filter_map"
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "list_map"
                        }

                "indexedMap" ->
                    Just
                        { qualification = []
                        , name = "list_indexed_map"
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "list_map2"
                        }

                "zip" ->
                    Just
                        { qualification = []
                        , name = "list_zip"
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "list_map3"
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "list_map4"
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "list_map5"
                        }

                "unzip" ->
                    Just
                        { qualification = []
                        , name = "list_unzip"
                        }

                "concatMap" ->
                    Just
                        { qualification = []
                        , name = "list_concat_map"
                        }

                "sort" ->
                    Just
                        { qualification = []
                        , name = "list_sort"
                        }

                "sortBy" ->
                    Just
                        { qualification = []
                        , name = "list_sort_by"
                        }

                "sortWith" ->
                    Just
                        { qualification = []
                        , name = "list_sort_with"
                        }

                "range" ->
                    Just
                        { qualification = []
                        , name = "list_range"
                        }

                "take" ->
                    Just
                        { qualification = []
                        , name = "list_take"
                        }

                "drop" ->
                    Just
                        { qualification = []
                        , name = "list_drop"
                        }

                "intersperse" ->
                    Just
                        { qualification = []
                        , name = "list_intersperse"
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "list_foldl"
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "list_foldr"
                        }

                _ ->
                    Nothing

        "Maybe" ->
            case reference.name of
                "withDefault" ->
                    Just
                        { qualification = []
                        , name = "maybe_with_default"
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "maybe_map"
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "maybe_map2"
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "maybe_map3"
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "maybe_map4"
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "maybe_map5"
                        }

                "andThen" ->
                    Just
                        { qualification = []
                        , name = "maybe_and_then"
                        }

                _ ->
                    Nothing

        "Result" ->
            case reference.name of
                "map" ->
                    Just
                        { qualification = []
                        , name = "result_map"
                        }

                "map2" ->
                    Just
                        { qualification = []
                        , name = "result_map2"
                        }

                "map3" ->
                    Just
                        { qualification = []
                        , name = "result_map3"
                        }

                "map4" ->
                    Just
                        { qualification = []
                        , name = "result_map4"
                        }

                "map5" ->
                    Just
                        { qualification = []
                        , name = "result_map5"
                        }

                "andThen" ->
                    Just
                        { qualification = []
                        , name = "result_and_then"
                        }

                "withDefault" ->
                    Just
                        { qualification = []
                        , name = "result_with_default"
                        }

                "toMaybe" ->
                    Just
                        { qualification = []
                        , name = "result_to_maybe"
                        }

                "fromMaybe" ->
                    Just
                        { qualification = []
                        , name = "result_from_maybe"
                        }

                "mapError" ->
                    Just
                        { qualification = []
                        , name = "result_map_error"
                        }

                _ ->
                    Nothing

        "Array" ->
            case reference.name of
                "isEmpty" ->
                    Just
                        { qualification = []
                        , name = "array_is_empty"
                        }

                "length" ->
                    Just
                        { qualification = []
                        , name = "array_length"
                        }

                "get" ->
                    Just
                        { qualification = []
                        , name = "array_get"
                        }

                "empty" ->
                    Just
                        { qualification = [ "immut", "array" ]
                        , name = "new"
                        }

                "singleton" ->
                    Just
                        { qualification = []
                        , name = "array_singleton"
                        }

                "repeat" ->
                    Just
                        { qualification = []
                        , name = "array_repeat"
                        }

                "initialize" ->
                    Just
                        { qualification = []
                        , name = "array_initialize"
                        }

                "fromList" ->
                    Just
                        { qualification = []
                        , name = "array_from_list"
                        }

                "reverse" ->
                    Just
                        { qualification = []
                        , name = "array_reverse"
                        }

                "filter" ->
                    Just
                        { qualification = []
                        , name = "array_filter"
                        }

                "push" ->
                    Just
                        { qualification = []
                        , name = "array_push"
                        }

                "set" ->
                    Just
                        { qualification = []
                        , name = "array_set"
                        }

                "slice" ->
                    Just
                        { qualification = []
                        , name = "array_slice"
                        }

                "map" ->
                    Just
                        { qualification = []
                        , name = "array_map"
                        }

                "indexedMap" ->
                    Just
                        { qualification = []
                        , name = "array_indexed_map"
                        }

                "append" ->
                    Just
                        { qualification = []
                        , name = "array_append"
                        }

                "toList" ->
                    Just
                        { qualification = []
                        , name = "array_to_list"
                        }

                "toIndexedList" ->
                    Just
                        { qualification = []
                        , name = "array_to_indexed_list"
                        }

                "foldl" ->
                    Just
                        { qualification = []
                        , name = "array_foldl"
                        }

                "foldr" ->
                    Just
                        { qualification = []
                        , name = "array_foldr"
                        }

                _ ->
                    Nothing

        "Dict" ->
            case reference.name of
                "size" ->
                    Just { qualification = [], name = "dict_size" }

                "empty" ->
                    Just { qualification = [], name = "dict_empty" }

                "singleton" ->
                    Just { qualification = [], name = "dict_singleton" }

                "fromList" ->
                    Just { qualification = [], name = "dict_from_list" }

                "toList" ->
                    Just { qualification = [], name = "dict_to_list" }

                "keys" ->
                    Just { qualification = [], name = "dict_keys" }

                "values" ->
                    Just { qualification = [], name = "dict_values" }

                "isEmpty" ->
                    Just { qualification = [], name = "dict_is_empty" }

                "map" ->
                    Just { qualification = [], name = "dict_map" }

                "partition" ->
                    Just { qualification = [], name = "dict_partition" }

                "foldl" ->
                    Just { qualification = [], name = "dict_foldl" }

                "foldr" ->
                    Just { qualification = [], name = "dict_foldr" }

                "filter" ->
                    Just { qualification = [], name = "dict_filter" }

                "get" ->
                    Just { qualification = [], name = "dict_get" }

                "member" ->
                    Just { qualification = [], name = "dict_member" }

                "insert" ->
                    Just { qualification = [], name = "dict_insert" }

                "update" ->
                    Just { qualification = [], name = "dict_update" }

                "remove" ->
                    Just { qualification = [], name = "dict_remove" }

                "union" ->
                    Just { qualification = [], name = "dict_union" }

                "diff" ->
                    Just { qualification = [], name = "dict_diff" }

                "intersect" ->
                    Just { qualification = [], name = "dict_intersect" }

                "merge" ->
                    Just { qualification = [], name = "dict_merge" }

                _ ->
                    Nothing

        "Set" ->
            case reference.name of
                "size" ->
                    Just { qualification = [], name = "set_size" }

                "empty" ->
                    Just { qualification = [], name = "set_empty" }

                "singleton" ->
                    Just { qualification = [], name = "set_singleton" }

                "fromList" ->
                    Just { qualification = [], name = "set_from_list" }

                "toList" ->
                    Just { qualification = [], name = "set_to_list" }

                "isEmpty" ->
                    Just { qualification = [], name = "set_is_empty" }

                "insert" ->
                    Just { qualification = [], name = "set_insert" }

                "partition" ->
                    Just { qualification = [], name = "set_partition" }

                "foldl" ->
                    Just { qualification = [], name = "set_foldl" }

                "foldr" ->
                    Just { qualification = [], name = "set_foldr" }

                "map" ->
                    Just { qualification = [], name = "set_map" }

                "filter" ->
                    Just { qualification = [], name = "set_filter" }

                "member" ->
                    Just { qualification = [], name = "set_member" }

                "remove" ->
                    Just { qualification = [], name = "set_remove" }

                "union" ->
                    Just { qualification = [], name = "set_union" }

                "diff" ->
                    Just { qualification = [], name = "set_diff" }

                "intersect" ->
                    Just { qualification = [], name = "set_intersect" }

                _ ->
                    Nothing

        "Debug" ->
            case reference.name of
                "log" ->
                    Just { qualification = [], name = "debug_log" }

                "toString" ->
                    Just { qualification = [], name = "debug_to_string" }

                "todo" ->
                    Just { qualification = [], name = "debug_todo" }

                _ ->
                    Nothing

        "Json.Encode" ->
            case reference.name of
                "encode" ->
                    Just { qualification = [], name = "json_encode_encode" }

                "null" ->
                    Just { qualification = [], name = "json_encode_null" }

                "bool" ->
                    Just { qualification = [], name = "json_encode_bool" }

                "string" ->
                    Just { qualification = [], name = "json_encode_string" }

                "int" ->
                    Just { qualification = [], name = "json_encode_int" }

                "float" ->
                    Just { qualification = [], name = "json_encode_float" }

                "list" ->
                    Just { qualification = [], name = "json_encode_list" }

                "array" ->
                    Just { qualification = [], name = "json_encode_array" }

                "set" ->
                    Just { qualification = [], name = "json_encode_set" }

                "object" ->
                    Just { qualification = [], name = "json_encode_object" }

                "dict" ->
                    Just { qualification = [], name = "json_encode_dict" }

                _ ->
                    Nothing

        "Json.Decode" ->
            case reference.name of
                "string" ->
                    Just { qualification = [], name = "json_decode_string" }

                "bool" ->
                    Just { qualification = [], name = "json_decode_bool" }

                "int" ->
                    Just { qualification = [], name = "json_decode_int" }

                "float" ->
                    Just { qualification = [], name = "json_decode_float" }

                "nullable" ->
                    Just { qualification = [], name = "json_decode_nullable" }

                "list" ->
                    Just { qualification = [], name = "json_decode_list" }

                "array" ->
                    Just { qualification = [], name = "json_decode_array" }

                "dict" ->
                    Just { qualification = [], name = "json_decode_dict" }

                "keyValuePairs" ->
                    Just { qualification = [], name = "json_decode_key_value_pairs" }

                "oneOrMore" ->
                    Just { qualification = [], name = "json_decode_one_or_more" }

                "field" ->
                    Just { qualification = [], name = "json_decode_field" }

                "at" ->
                    Just { qualification = [], name = "json_decode_at" }

                "index" ->
                    Just { qualification = [], name = "json_decode_index" }

                "maybe" ->
                    Just { qualification = [], name = "json_decode_maybe" }

                "oneOf" ->
                    Just { qualification = [], name = "json_decode_one_of" }

                "decodeString" ->
                    Just { qualification = [], name = "json_decode_decode_string" }

                "decodeValue" ->
                    Just { qualification = [], name = "json_decode_decode_value" }

                "errorToString" ->
                    Just { qualification = [], name = "json_decode_error_to_string" }

                "map" ->
                    Just { qualification = [], name = "json_decode_map" }

                "map2" ->
                    Just { qualification = [], name = "json_decode_map2" }

                "map3" ->
                    Just { qualification = [], name = "json_decode_map3" }

                "map4" ->
                    Just { qualification = [], name = "json_decode_map4" }

                "map5" ->
                    Just { qualification = [], name = "json_decode_map5" }

                "map6" ->
                    Just { qualification = [], name = "json_decode_map6" }

                "map7" ->
                    Just { qualification = [], name = "json_decode_map7" }

                "map8" ->
                    Just { qualification = [], name = "json_decode_map8" }

                "lazy" ->
                    Just { qualification = [], name = "json_decode_lazy" }

                "value" ->
                    Just { qualification = [], name = "json_decode_value" }

                "null" ->
                    Just { qualification = [], name = "json_decode_null" }

                "succeed" ->
                    Just { qualification = [], name = "json_decode_succeed" }

                "fail" ->
                    Just { qualification = [], name = "json_decode_fail" }

                "andThen" ->
                    Just { qualification = [], name = "json_decode_and_then" }

                _ ->
                    Nothing

        "Random" ->
            case reference.name of
                "int" ->
                    Just { qualification = [], name = "random_int" }

                "float" ->
                    Just { qualification = [], name = "random_float" }

                "uniform" ->
                    Just { qualification = [], name = "random_uniform" }

                "weighted" ->
                    Just { qualification = [], name = "random_weighted" }

                "constant" ->
                    Just { qualification = [], name = "random_constant" }

                "list" ->
                    Just { qualification = [], name = "random_list" }

                "pair" ->
                    Just { qualification = [], name = "random_pair" }

                "map" ->
                    Just { qualification = [], name = "random_map" }

                "map2" ->
                    Just { qualification = [], name = "random_map2" }

                "map3" ->
                    Just { qualification = [], name = "random_map3" }

                "map4" ->
                    Just { qualification = [], name = "random_map4" }

                "map5" ->
                    Just { qualification = [], name = "random_map5" }

                "andThen" ->
                    Just { qualification = [], name = "random_and_then" }

                "lazy" ->
                    Just { qualification = [], name = "random_lazy" }

                "minInt" ->
                    Just { qualification = [], name = "random_min_int" }

                "maxInt" ->
                    Just { qualification = [], name = "random_max_int" }

                "step" ->
                    Just { qualification = [], name = "random_step" }

                "initialSeed" ->
                    Just { qualification = [], name = "random_initial_seed" }

                "independentSeed" ->
                    Just { qualification = [], name = "random_independent_seed" }

                _ ->
                    Nothing

        "Time" ->
            case reference.name of
                "posixToMillis" ->
                    Just { qualification = [], name = "time_posix_to_millis" }

                "millisToPosix" ->
                    Just { qualification = [], name = "time_millis_to_posix" }

                "utc" ->
                    Just { qualification = [], name = "time_utc" }

                "toYear" ->
                    Just { qualification = [], name = "time_to_year" }

                "toMonth" ->
                    Just { qualification = [], name = "time_to_month" }

                "toDay" ->
                    Just { qualification = [], name = "time_to_day" }

                "toWeekday" ->
                    Just { qualification = [], name = "time_to_weekday" }

                "toHour" ->
                    Just { qualification = [], name = "time_to_hour" }

                "toMinute" ->
                    Just { qualification = [], name = "time_to_minute" }

                "toSecond" ->
                    Just { qualification = [], name = "time_to_second" }

                "toMillis" ->
                    Just { qualification = [], name = "time_to_millis" }

                "customZone" ->
                    Just { qualification = [], name = "time_custom_zone" }

                _ ->
                    Nothing

        "Bytes" ->
            case reference.name of
                "width" ->
                    Just { qualification = [], name = "bytes_width" }

                _ ->
                    Nothing

        "Bytes.Decode" ->
            case reference.name of
                "decode" ->
                    Just { qualification = [], name = "bytes_decode_decode" }

                "signedInt8" ->
                    Just { qualification = [], name = "bytes_decode_signed_int8" }

                "signedInt16" ->
                    Just { qualification = [], name = "bytes_decode_signed_int16" }

                "signedInt32" ->
                    Just { qualification = [], name = "bytes_decode_signed_int32" }

                "unsignedInt8" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int8" }

                "unsignedInt16" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int16" }

                "unsignedInt32" ->
                    Just { qualification = [], name = "bytes_decode_unsigned_int32" }

                "float32" ->
                    Just { qualification = [], name = "bytes_decode_float32" }

                "float64" ->
                    Just { qualification = [], name = "bytes_decode_float64" }

                "string" ->
                    Just { qualification = [], name = "bytes_decode_string" }

                "bytes" ->
                    Just { qualification = [], name = "bytes_decode_bytes" }

                "map" ->
                    Just { qualification = [], name = "bytes_decode_map" }

                "map2" ->
                    Just { qualification = [], name = "bytes_decode_map2" }

                "map3" ->
                    Just { qualification = [], name = "bytes_decode_map3" }

                "map4" ->
                    Just { qualification = [], name = "bytes_decode_map4" }

                "map5" ->
                    Just { qualification = [], name = "bytes_decode_map5" }

                "andThen" ->
                    Just { qualification = [], name = "bytes_decode_and_then" }

                "succeed" ->
                    Just { qualification = [], name = "bytes_decode_succeed" }

                "fail" ->
                    Just { qualification = [], name = "bytes_decode_fail" }

                "loop" ->
                    Just { qualification = [], name = "bytes_decode_loop" }

                _ ->
                    Nothing

        "Bytes.Encode" ->
            case reference.name of
                "encode" ->
                    Just { qualification = [], name = "bytes_encode_encode" }

                "signedInt8" ->
                    Just { qualification = [], name = "bytes_encode_signed_int8" }

                "signedInt16" ->
                    Just { qualification = [], name = "bytes_encode_signed_int16" }

                "signedInt32" ->
                    Just { qualification = [], name = "bytes_encode_signed_int32" }

                "unsignedInt8" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int8" }

                "unsignedInt16" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int16" }

                "unsignedInt32" ->
                    Just { qualification = [], name = "bytes_encode_unsigned_int32" }

                "float32" ->
                    Just { qualification = [], name = "bytes_encode_float32" }

                "float64" ->
                    Just { qualification = [], name = "bytes_encode_float64" }

                "bytes" ->
                    Just { qualification = [], name = "bytes_encode_bytes" }

                "string" ->
                    Just { qualification = [], name = "bytes_encode_string" }

                "getStringWidth" ->
                    Just { qualification = [], name = "string_length" }

                "sequence" ->
                    Just { qualification = [], name = "bytes_encode_sequence" }

                _ ->
                    Nothing

        "Elm.Kernel.Parser" ->
            case reference.name of
                "isSubString" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_sub_string" }

                "isSubChar" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_sub_char" }

                "isAsciiCode" ->
                    Just { qualification = [], name = "elm_kernel_parser_is_ascii_code" }

                "chompBase10" ->
                    Just { qualification = [], name = "elm_kernel_parser_chomp_base10" }

                "consumeBase" ->
                    Just { qualification = [], name = "elm_kernel_parser_consume_base" }

                "consumeBase16" ->
                    Just { qualification = [], name = "elm_kernel_parser_consume_base16" }

                "findSubString" ->
                    Just { qualification = [], name = "elm_kernel_parser_find_sub_string" }

                _ ->
                    Nothing

        "Elm.Kernel.VirtualDom" ->
            case reference.name of
                "property" ->
                    Just { qualification = [], name = "virtual_dom_property" }

                "attribute" ->
                    Just { qualification = [], name = "virtual_dom_attribute" }

                "attributeNS" ->
                    Just { qualification = [], name = "virtual_dom_attribute_ns" }

                "node" ->
                    Just { qualification = [], name = "virtual_dom_node" }

                "nodeNS" ->
                    Just { qualification = [], name = "virtual_dom_node_ns" }

                "noJavaScriptOrHtmlUri" ->
                    Just { qualification = [], name = "virtual_dom_no_java_script_or_html_uri" }

                "noJavaScriptUri" ->
                    Just { qualification = [], name = "virtual_dom_no_java_script_uri" }

                _ ->
                    Nothing

        "VirtualDom" ->
            case reference.name of
                "text" ->
                    Just { qualification = [], name = "virtual_dom_text" }

                "node" ->
                    Just { qualification = [], name = "virtual_dom_node" }

                "nodeNS" ->
                    Just { qualification = [], name = "virtual_dom_node_ns" }

                "style" ->
                    Just { qualification = [], name = "virtual_dom_style" }

                "property" ->
                    Just { qualification = [], name = "virtual_dom_property" }

                "attribute" ->
                    Just { qualification = [], name = "virtual_dom_attribute" }

                "attributeNS" ->
                    Just { qualification = [], name = "virtual_dom_attribute_ns" }

                "on" ->
                    Just { qualification = [], name = "virtual_dom_on" }

                "map" ->
                    Just { qualification = [], name = "virtual_dom_map" }

                "mapAttribute" ->
                    Just { qualification = [], name = "virtual_dom_map_attribute" }

                "keyedNode" ->
                    Just { qualification = [], name = "virtual_dom_keyed_node" }

                "keyedNodeNS" ->
                    Just { qualification = [], name = "virtual_dom_keyed_node_ns" }

                "lazy" ->
                    Just { qualification = [], name = "virtual_dom_lazy" }

                "lazy2" ->
                    Just { qualification = [], name = "virtual_dom_lazy2" }

                "lazy3" ->
                    Just { qualification = [], name = "virtual_dom_lazy3" }

                "lazy4" ->
                    Just { qualification = [], name = "virtual_dom_lazy4" }

                "lazy5" ->
                    Just { qualification = [], name = "virtual_dom_lazy5" }

                "lazy6" ->
                    Just { qualification = [], name = "virtual_dom_lazy6" }

                "lazy7" ->
                    Just { qualification = [], name = "virtual_dom_lazy7" }

                "lazy8" ->
                    Just { qualification = [], name = "virtual_dom_lazy8" }

                _ ->
                    Nothing

        "Math.Vector2" ->
            -- not supported in the near future, see readme
            Nothing

        "Math.Vector3" ->
            -- not supported in the near future, see readme
            Nothing

        "Math.Vector4" ->
            -- not supported in the near future, see readme
            Nothing

        "Math.Matrix4" ->
            -- not supported in the near future, see readme
            Nothing

        "Platform" ->
            case reference.name of
                "worker" ->
                    Just { qualification = [], name = "platform_worker" }

                _ ->
                    Nothing

        "Platform.Cmd" ->
            case reference.name of
                "none" ->
                    Just { qualification = [], name = "platform_cmd_none" }

                "batch" ->
                    Just { qualification = [], name = "platform_cmd_batch" }

                "map" ->
                    Just { qualification = [], name = "platform_cmd_map" }

                _ ->
                    Nothing

        "Platform.Sub" ->
            case reference.name of
                "none" ->
                    Just { qualification = [], name = "platform_sub_none" }

                "batch" ->
                    Just { qualification = [], name = "platform_sub_batch" }

                "map" ->
                    Just { qualification = [], name = "platform_sub_map" }

                _ ->
                    Nothing

        _ ->
            Nothing


elmReferenceToSnakeCaseMoonbitName :
    { moduleOrigin : String
    , name : String
    }
    -> String
elmReferenceToSnakeCaseMoonbitName reference =
    (case reference.moduleOrigin |> String.replace "." "" of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            (moduleOriginNotEmpty |> String.replace "_" "0")
                ++ "_"
                ++ reference.name
    )
        |> toSnakeCaseMoonbitName


elmReferenceToPascalCaseMoonbitName :
    { moduleOrigin : String
    , name : String
    }
    -> String
elmReferenceToPascalCaseMoonbitName reference =
    (case reference.moduleOrigin |> String.replace "." "" of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ (reference.name |> stringFirstCharToUpper)
    )
        |> toPascalCaseMoonbitName


printMoonbitPattern : MoonbitPattern -> Print
printMoonbitPattern moonbitPattern =
    -- IGNORE TCO
    case moonbitPattern of
        MoonbitPatternIgnore ->
            printExactlyUnderscore

        MoonbitPatternInteger int64 ->
            printMoonbitPatternInteger int64

        MoonbitPatternChar char ->
            printMoonbitCharLiteral char

        MoonbitPatternString string ->
            printMoonbitStringLiteral string

        MoonbitPatternVariable variable ->
            Print.exactly variable.name

        MoonbitPatternAlias moonbitPatternAlias ->
            printMoonbitPatternAlias moonbitPatternAlias

        MoonbitPatternStructNotExhaustive moonbitPatternStructNotExhaustive ->
            printMoonbitPatternStructNotExhaustive moonbitPatternStructNotExhaustive

        MoonbitPatternVariant patternVariant ->
            printMoonbitPatternVariant patternVariant

        MoonbitPatternTuple parts ->
            printMoonbitPatternTuple parts


printMoonbitPatternInteger : Int -> Print
printMoonbitPatternInteger int64 =
    Print.exactly (int64Literal int64)


printMoonbitPatternAlias :
    { pattern : MoonbitPattern
    , variable : String
    , type_ : MoonbitType
    }
    -> Print
printMoonbitPatternAlias moonbitPatternAlias =
    let
        patternPrint : Print
        patternPrint =
            moonbitPatternAlias.pattern |> printMoonbitPattern
    in
    Print.exactly
        (moonbitPatternAlias.variable
            ++ " @"
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented (patternPrint |> Print.lineSpread)
                    |> Print.followedBy
                        patternPrint
                )
            )


printMoonbitPatternVariant :
    { originTypeName : List String
    , name : String
    , values : List { label : Maybe String, pattern : MoonbitPattern }
    }
    -> Print
printMoonbitPatternVariant patternVariant =
    Print.exactly
        (qualifiedMoonbitVariantReferenceToString
            { originTypeName = patternVariant.originTypeName
            , name = patternVariant.name
            }
        )
        |> Print.followedBy
            (case patternVariant.values of
                [] ->
                    Print.empty

                variantValue0 :: variantValue1Up ->
                    printExactlyParenOpening
                        |> Print.followedBy
                            ((variantValue0 :: variantValue1Up)
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\variantValue ->
                                        let
                                            variantValuePrint : Print
                                            variantValuePrint =
                                                printMoonbitPattern variantValue.pattern
                                        in
                                        case variantValue.label of
                                            Nothing ->
                                                variantValuePrint

                                            Just label ->
                                                Print.exactly (label ++ "=")
                                                    |> Print.followedBy
                                                        (Print.withIndentAtNextMultipleOf4
                                                            (Print.linebreakIndented
                                                                |> Print.followedBy
                                                                    variantValuePrint
                                                            )
                                                        )
                                    )
                                    printExactlyCommaSpace
                            )
                        |> Print.followedBy printExactlyParenClosing
            )


printMoonbitPatternTuple :
    { part0 : MoonbitPattern
    , part1 : MoonbitPattern
    , part2Up : List MoonbitPattern
    }
    -> Print
printMoonbitPatternTuple parts =
    printExactlyParenOpening
        |> Print.followedBy
            ((parts.part0 :: parts.part1 :: parts.part2Up)
                |> Print.listMapAndIntersperseAndFlatten
                    printMoonbitPattern
                    printExactlyCommaSpace
            )
        |> Print.followedBy printExactlyParenClosing


printMoonbitPatternStructNotExhaustive :
    { name : String
    , fields : FastDict.Dict String MoonbitPattern
    }
    -> Print
printMoonbitPatternStructNotExhaustive moonbitPatternStruct =
    Print.exactly
        (-- moonbitPatternStruct.name ++ "::" ++
         "{ "
        )
        |> Print.followedBy
            (moonbitPatternStruct.fields
                |> FastDict.toList
                |> Print.listMapAndIntersperseAndFlatten
                    (\( fieldName, fieldValuePattern ) ->
                        Print.exactly
                            (fieldName ++ ": ")
                            |> Print.followedBy
                                (printMoonbitPattern
                                    fieldValuePattern
                                )
                    )
                    printExactlyComma
            )
        |> Print.followedBy (Print.exactly ", .. }")


printExactlyCommaSpace : Print
printExactlyCommaSpace =
    Print.exactly ", "


printExactlyComma : Print
printExactlyComma =
    Print.exactly ","


printMoonbitExpressionStruct :
    { name : String
    , fields : FastDict.Dict String MoonbitExpression
    }
    -> Print
printMoonbitExpressionStruct moonbitExpressionStruct =
    if moonbitExpressionStruct.fields |> FastDict.isEmpty then
        printExactlyMoonbitExpressionRecordEmpty

    else
        let
            fieldsPrint : Print
            fieldsPrint =
                moonbitExpressionStruct.fields
                    |> FastDict.toList
                    |> Print.listMapAndIntersperseAndFlatten
                        (\( fieldName, fieldValue ) ->
                            let
                                fieldValuePrint : Print
                                fieldValuePrint =
                                    printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                        fieldValue
                            in
                            Print.exactly (fieldName ++ ":")
                                |> Print.followedBy
                                    (Print.withIndentAtNextMultipleOf4
                                        (Print.spaceOrLinebreakIndented
                                            (fieldValuePrint |> Print.lineSpread)
                                            |> Print.followedBy fieldValuePrint
                                        )
                                    )
                        )
                        (printExactlyComma
                            |> Print.followedBy Print.linebreakIndented
                        )
        in
        Print.exactly
            -- name can be omitted, but adding it doesn't hurt
            (moonbitExpressionStruct.name ++ "::{")
            |> Print.followedBy
                (Print.withIndentAtNextMultipleOf4
                    (Print.spaceOrLinebreakIndented
                        (fieldsPrint |> Print.lineSpread)
                        |> Print.followedBy fieldsPrint
                    )
                )
            |> Print.followedBy
                (Print.spaceOrLinebreakIndented
                    (fieldsPrint |> Print.lineSpread)
                )
            |> Print.followedBy printExactlyCurlyClosing


printExactlyMoonbitExpressionRecordEmpty : Print
printExactlyMoonbitExpressionRecordEmpty =
    Print.exactly "Generated{}"


printExactlyCurlyClosing : Print
printExactlyCurlyClosing =
    Print.exactly "}"


{-| (Wrap in parens)
-}
printParenthesized : Print -> Print
printParenthesized inner =
    printExactlyParenOpening
        |> Print.followedBy
            (Print.withIndentIncreasedBy 1
                inner
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented
                (inner |> Print.lineSpread)
            )
        |> Print.followedBy printExactlyParenClosing


{-| {Wrap in curlies}
-}
printCurlyEmbraced : Print -> Print
printCurlyEmbraced inner =
    printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy inner
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyParenOpening : Print
printExactlyParenOpening =
    Print.exactly "("


printExactlyParenClosing : Print
printExactlyParenClosing =
    Print.exactly ")"


{-| Transpile a list of [`Elm.Syntax.Declaration.Declaration`](https://dark.elm.dmy.fr/packages/stil4m/elm-syntax/latest/Elm-Syntax-Declaration#Declaration)s
across multiple modules to value, function and type declarations.
Declarations that use unsupported stuff like html kernel code (directly or indirectly)
will not be present in the final declarations.
Their errors can be found alongside the valid transpiled declarations.

The given list of files must also include files from used dependencies
including `elm/core`.

-}
modules :
    List Elm.Syntax.File.File
    ->
        { errors : List String
        , declarations :
            { fns :
                List
                    { name : String
                    , parameters : List { binding : Maybe String, type_ : MoonbitType }
                    , result : MoonbitExpression
                    , resultType : MoonbitType
                    }
            , lets :
                List
                    { name : String
                    , result : MoonbitExpression
                    , resultType : MoonbitType
                    }
            , typeAliases :
                List
                    { name : String
                    , parameters : List String
                    , type_ : MoonbitType
                    }
            , enumTypes :
                List
                    { name : String
                    , parameters : List String
                    , variants :
                        FastDict.Dict String (List MoonbitType)
                    }
            , structs :
                List
                    { name : String
                    , parameters : List String
                    , fields : FastDict.Dict String MoonbitType
                    }
            }
        }
modules syntaxDeclarationsIncludingOverwrittenOnes =
    let
        syntaxModules : List Elm.Syntax.File.File
        syntaxModules =
            syntaxDeclarationsIncludingOverwrittenOnes
                |> List.filter
                    (\syntaxModule ->
                        case
                            syntaxModule.moduleDefinition
                                |> Elm.Syntax.Node.value
                                |> moduleHeaderName
                        of
                            "Basics" ->
                                False

                            "Array" ->
                                False

                            -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                            "Elm.JsArray" ->
                                False

                            "Bitwise" ->
                                False

                            "Debug" ->
                                False

                            "Char" ->
                                False

                            "String" ->
                                False

                            "List" ->
                                False

                            "Maybe" ->
                                False

                            "Result" ->
                                False

                            "Dict" ->
                                False

                            "Set" ->
                                False

                            "Platform" ->
                                False

                            "Platform.Cmd" ->
                                False

                            "Platform.Sub" ->
                                False

                            "Process" ->
                                False

                            "Task" ->
                                False

                            "Json.Decode" ->
                                False

                            "Json.Encode" ->
                                False

                            "Regex" ->
                                False

                            "File" ->
                                False

                            "Bytes" ->
                                False

                            "Bytes.Encode" ->
                                False

                            "Bytes.Decode" ->
                                False

                            "Http" ->
                                False

                            "VirtualDom" ->
                                False

                            "Browser" ->
                                False

                            "Browser.Events" ->
                                False

                            "Browser.Navigation" ->
                                False

                            "Browser.Dom" ->
                                False

                            -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                            "Browser.AnimationManager" ->
                                False

                            -- https://github.com/elm/browser/tree/master/src/Debugger
                            "Debugger.Expando" ->
                                False

                            "Debugger.History" ->
                                False

                            "Debugger.Main" ->
                                False

                            "Debugger.Metadata" ->
                                False

                            "Debugger.Overlay" ->
                                False

                            "Debugger.Report" ->
                                False

                            "Time" ->
                                False

                            "Random" ->
                                False

                            "Markdown" ->
                                False

                            "Benchmark" ->
                                False

                            "WebGL" ->
                                False

                            "WebGL.Settings" ->
                                False

                            "WebGL.Settings.Blend" ->
                                False

                            "WebGL.Settings.DepthTest" ->
                                False

                            "WebGL.Settings.StencilTest" ->
                                False

                            "WebGL.Texture" ->
                                False

                            "Math.Matrix4" ->
                                False

                            "Math.Vector2" ->
                                False

                            "Math.Vector3" ->
                                False

                            "Math.Vector4" ->
                                False

                            _ ->
                                True
                    )

        allElmRecords : FastSet.Set (List String)
        allElmRecords =
            syntaxModules
                |> listMapToFastSetsAndUnify
                    (\syntaxModule ->
                        syntaxModule.declarations
                            |> listMapToFastSetsAndUnify
                                (\(Elm.Syntax.Node.Node _ syntaxDeclaration) ->
                                    case syntaxDeclaration of
                                        Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                            let
                                                implementationContainedConstructedRecords : FastSet.Set (List String)
                                                implementationContainedConstructedRecords =
                                                    syntaxValueOrFunctionDeclaration.declaration
                                                        |> Elm.Syntax.Node.value
                                                        |> .expression
                                                        |> syntaxExpressionContainedConstructedRecords
                                            in
                                            case syntaxValueOrFunctionDeclaration.signature of
                                                Nothing ->
                                                    implementationContainedConstructedRecords

                                                Just (Elm.Syntax.Node.Node _ signature) ->
                                                    implementationContainedConstructedRecords
                                                        |> FastSet.union
                                                            (signature.typeAnnotation
                                                                |> typeContainedRecords
                                                            )

                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                            -- invalid syntax
                                            FastSet.empty

                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                            FastSet.empty

                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                            syntaxTypeAliasDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.PortDeclaration syntaxPortDeclaration ->
                                            syntaxPortDeclaration.typeAnnotation
                                                |> typeContainedRecords

                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                            syntaxChoiceTypeDeclaration.constructors
                                                |> listMapToFastSetsAndUnify
                                                    (\(Elm.Syntax.Node.Node _ variant) ->
                                                        variant.arguments
                                                            |> listMapToFastSetsAndUnify typeContainedRecords
                                                    )
                                )
                    )

        syntaxModulesFromMostToLeastImported : List Elm.Syntax.File.File
        syntaxModulesFromMostToLeastImported =
            syntaxModules
                |> List.map
                    (\syntaxModule ->
                        ( syntaxModule
                        , syntaxModule.moduleDefinition
                            |> Elm.Syntax.Node.value
                            |> moduleHeaderName
                        , syntaxModule.imports
                            |> List.map
                                (\(Elm.Syntax.Node.Node _ import_) ->
                                    import_.moduleName |> Elm.Syntax.Node.value |> String.join "."
                                )
                        )
                    )
                |> Graph.stronglyConnComponents
                |> List.foldr
                    (\edge0 syntaxModulesFromMostToLeastImportedSoFar ->
                        case edge0 of
                            Graph.AcyclicSCC n ->
                                n :: syntaxModulesFromMostToLeastImportedSoFar

                            Graph.CyclicSCC recursive ->
                                -- we assume the given module do not have cyclic imports
                                recursive ++ syntaxModulesFromMostToLeastImportedSoFar
                    )
                    []

        specialize :
            { typeAliases :
                FastDict.Dict
                    String
                    (FastDict.Dict
                        String
                        { parameters : List String
                        , recordFieldOrder : Maybe (List String)
                        , type_ : ElmSyntaxTypeInfer.Type
                        }
                    )
            , inferred : InferredValueOrFunctionDeclaration
            , syntax : Elm.Syntax.Expression.Function
            }
            -> List Elm.Syntax.Expression.Function
        specialize config =
            let
                specializedTypes : FastDict.Dict String (List MoonbitTypeVariableSpecialization)
                specializedTypes =
                    config.inferred.type_
                        |> inferredTypeExpandInnerAliases
                            (\moduleName -> config.typeAliases |> FastDict.get moduleName)
                        |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes
                            { allElmRecords = allElmRecords }
            in
            if specializedTypes |> FastDict.isEmpty then
                []

            else
                case config.syntax.signature of
                    Nothing ->
                        specializedTypes
                            |> fastDictPermutations
                            |> List.map
                                (\specialization ->
                                    let
                                        specializedName : String
                                        specializedName =
                                            config.inferred.name
                                                |> moonbitNameWithSpecializedTypes
                                                    specialization

                                        (Elm.Syntax.Node.Node implementationRange implementation) =
                                            config.syntax.declaration
                                    in
                                    { documentation = config.syntax.documentation
                                    , signature = Nothing
                                    , declaration =
                                        Elm.Syntax.Node.Node
                                            implementationRange
                                            { name =
                                                Elm.Syntax.Node.Node
                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                    specializedName
                                            , arguments = implementation.arguments
                                            , expression = implementation.expression
                                            }
                                    }
                                )

                    Just (Elm.Syntax.Node.Node signatureRange signature) ->
                        let
                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable : FastDict.Dict String String
                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable =
                                createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    config.inferred.type_
                                    signature.typeAnnotation
                        in
                        specializedTypes
                            |> fastDictPermutations
                            |> List.map
                                (\specialization ->
                                    let
                                        specializedName : String
                                        specializedName =
                                            config.inferred.name
                                                |> moonbitNameWithSpecializedTypes
                                                    specialization
                                    in
                                    { documentation = config.syntax.documentation
                                    , signature =
                                        Just
                                            (Elm.Syntax.Node.Node signatureRange
                                                { typeAnnotation =
                                                    signature.typeAnnotation
                                                        |> syntaxTypeNodeApplySpecialization
                                                            (specialization
                                                                |> FastDict.foldl
                                                                    (\inferredVariable specializedType soFar ->
                                                                        case
                                                                            synchronizationFromInferredTypeVariableToAnnotationTypeVariable
                                                                                |> FastDict.get inferredVariable
                                                                        of
                                                                            Nothing ->
                                                                                soFar

                                                                            Just annotationVariable ->
                                                                                soFar
                                                                                    |> FastDict.insert annotationVariable specializedType
                                                                    )
                                                                    FastDict.empty
                                                            )
                                                , name =
                                                    Elm.Syntax.Node.Node
                                                        (signature.name |> Elm.Syntax.Node.range)
                                                        specializedName
                                                }
                                            )
                                    , declaration =
                                        let
                                            (Elm.Syntax.Node.Node implementationRange implementation) =
                                                config.syntax.declaration
                                        in
                                        Elm.Syntax.Node.Node
                                            implementationRange
                                            { name =
                                                Elm.Syntax.Node.Node
                                                    (implementation.name |> Elm.Syntax.Node.range)
                                                    specializedName
                                            , arguments = implementation.arguments
                                            , expression = implementation.expression
                                            }
                                    }
                                )

        syntaxModulesInferredOrError :
            Result
                String
                { errors : List String
                , types :
                    FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
                , inferred :
                    List
                        { module_ : Elm.Syntax.File.File
                        , moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                        , declarationTypes : ElmSyntaxTypeInfer.ModuleTypes
                        , declarationsInferred : List InferredValueOrFunctionDeclaration
                        }
                , valueAndFunctionAnnotations :
                    FastDict.Dict
                        {- module origin -} String
                        (FastDict.Dict
                            String
                            ElmSyntaxTypeInfer.Type
                        )
                }
        syntaxModulesInferredOrError =
            syntaxModulesFromMostToLeastImported
                |> listFoldlWhileOkFrom
                    { errors = []
                    , types = baseElmDeclarationTypes
                    , inferred = []
                    , valueAndFunctionAnnotations = FastDict.empty
                    }
                    (\syntaxModule soFar ->
                        let
                            moduleName : String
                            moduleName =
                                syntaxModule.moduleDefinition
                                    |> Elm.Syntax.Node.value
                                    |> moduleHeaderName

                            moduleOriginLookup : ElmSyntaxTypeInfer.ModuleOriginLookup
                            moduleOriginLookup =
                                syntaxModule.imports
                                    |> ElmSyntaxTypeInfer.importsToModuleOriginLookup
                                        soFar.types

                            currentModuleDeclarationTypesAndErrors : { types : ElmSyntaxTypeInfer.ModuleTypes, errors : List String }
                            currentModuleDeclarationTypesAndErrors =
                                syntaxModule.declarations
                                    |> ElmSyntaxTypeInfer.moduleDeclarationsToTypes
                                        { moduleName = moduleName
                                        , moduleOriginLookup = moduleOriginLookup
                                        }

                            syntaxValueOrFunctionDeclarations : List Elm.Syntax.Expression.Function
                            syntaxValueOrFunctionDeclarations =
                                syntaxModule.declarations
                                    |> List.filterMap
                                        (\(Elm.Syntax.Node.Node _ declaration) ->
                                            case declaration of
                                                Elm.Syntax.Declaration.FunctionDeclaration syntaxValueOrFunctionDeclaration ->
                                                    Just syntaxValueOrFunctionDeclaration

                                                Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.PortDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                    Nothing

                                                Elm.Syntax.Declaration.Destructuring _ _ ->
                                                    Nothing
                                        )
                        in
                        syntaxValueOrFunctionDeclarations
                            |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                { moduleName = moduleName
                                , importedTypes = soFar.types
                                , moduleOriginLookup = moduleOriginLookup
                                , otherModuleDeclaredTypes =
                                    -- also includes signatures because ports need to be known
                                    -- and we sometimes specialize the declaration names
                                    -- before inferring but still reference the old names
                                    -- which get changed to their specialized form only
                                    -- after inferring
                                    currentModuleDeclarationTypesAndErrors.types
                                }
                            |> Result.andThen
                                (\declarationsInferredUnspecialized ->
                                    let
                                        typeAliasesAcrossModulesSoFarWithCurrent :
                                            FastDict.Dict
                                                {- module origin -} String
                                                (FastDict.Dict
                                                    String
                                                    { parameters : List String
                                                    , recordFieldOrder : Maybe (List String)
                                                    , type_ : ElmSyntaxTypeInfer.Type
                                                    }
                                                )
                                        typeAliasesAcrossModulesSoFarWithCurrent =
                                            soFar.types
                                                |> FastDict.map (\_ moduleTypes -> moduleTypes.typeAliases)
                                                |> FastDict.insert moduleName
                                                    currentModuleDeclarationTypesAndErrors.types.typeAliases

                                        specializedDeclarations :
                                            { splitDeclarations : List Elm.Syntax.Expression.Function
                                            , originalDeclarationNamesThatGotSplit : FastSet.Set String
                                            }
                                        specializedDeclarations =
                                            declarationsInferredUnspecialized
                                                |> List.foldl
                                                    (\inferredUnspecializedValueOrFunctionDeclaration specializedDeclarationsSoFar ->
                                                        case
                                                            syntaxValueOrFunctionDeclarations
                                                                |> listMapAndFirstJust
                                                                    (\syntaxValueOrFunctionDeclaration ->
                                                                        if
                                                                            (syntaxValueOrFunctionDeclaration
                                                                                |> .declaration
                                                                                |> Elm.Syntax.Node.value
                                                                                |> .name
                                                                                |> Elm.Syntax.Node.value
                                                                            )
                                                                                == inferredUnspecializedValueOrFunctionDeclaration.name
                                                                        then
                                                                            Just syntaxValueOrFunctionDeclaration

                                                                        else
                                                                            Nothing
                                                                    )
                                                        of
                                                            Nothing ->
                                                                specializedDeclarationsSoFar

                                                            Just originalSyntaxForInferredDeclaration ->
                                                                case
                                                                    specialize
                                                                        { typeAliases = typeAliasesAcrossModulesSoFarWithCurrent
                                                                        , syntax = originalSyntaxForInferredDeclaration
                                                                        , inferred = inferredUnspecializedValueOrFunctionDeclaration
                                                                        }
                                                                of
                                                                    [] ->
                                                                        specializedDeclarationsSoFar

                                                                    split0 :: split1Up ->
                                                                        { originalDeclarationNamesThatGotSplit =
                                                                            specializedDeclarationsSoFar.originalDeclarationNamesThatGotSplit
                                                                                |> FastSet.insert inferredUnspecializedValueOrFunctionDeclaration.name
                                                                        , splitDeclarations =
                                                                            split0
                                                                                :: split1Up
                                                                                ++ specializedDeclarationsSoFar.splitDeclarations
                                                                        }
                                                    )
                                                    { originalDeclarationNamesThatGotSplit = FastSet.empty
                                                    , splitDeclarations = []
                                                    }
                                    in
                                    specializedDeclarations.splitDeclarations
                                        |> ElmSyntaxTypeInfer.valueAndFunctionDeclarations
                                            { moduleName = moduleName
                                            , importedTypes = soFar.types
                                            , moduleOriginLookup = moduleOriginLookup
                                            , otherModuleDeclaredTypes = currentModuleDeclarationTypesAndErrors.types
                                            }
                                        |> Result.map
                                            (\specializedInferredDeclarations ->
                                                let
                                                    currentModuleDeclarationSignatureTypesIncludingUnannotated : FastDict.Dict String ElmSyntaxTypeInfer.Type
                                                    currentModuleDeclarationSignatureTypesIncludingUnannotated =
                                                        specializedInferredDeclarations
                                                            |> List.foldl
                                                                (\declarationInferred moduleTypesSoFar ->
                                                                    moduleTypesSoFar
                                                                        |> FastDict.insert declarationInferred.name
                                                                            declarationInferred.type_
                                                                )
                                                                (declarationsInferredUnspecialized
                                                                    |> List.foldl
                                                                        (\declarationInferred moduleTypesSoFar ->
                                                                            moduleTypesSoFar
                                                                                |> FastDict.insert declarationInferred.name
                                                                                    declarationInferred.type_
                                                                        )
                                                                        currentModuleDeclarationTypesAndErrors.types.signatures
                                                                )

                                                    currentModuleDeclarationTypesIncludingUnannotated : ElmSyntaxTypeInfer.ModuleTypes
                                                    currentModuleDeclarationTypesIncludingUnannotated =
                                                        { typeAliases = currentModuleDeclarationTypesAndErrors.types.typeAliases
                                                        , choiceTypes = currentModuleDeclarationTypesAndErrors.types.choiceTypes
                                                        , signatures = currentModuleDeclarationSignatureTypesIncludingUnannotated
                                                        }
                                                in
                                                { errors =
                                                    currentModuleDeclarationTypesAndErrors.errors
                                                        ++ soFar.errors
                                                , types =
                                                    soFar.types
                                                        |> FastDict.insert moduleName
                                                            currentModuleDeclarationTypesIncludingUnannotated
                                                , inferred =
                                                    { declarationsInferred =
                                                        case specializedInferredDeclarations of
                                                            [] ->
                                                                declarationsInferredUnspecialized

                                                            specializedInferredDeclaration0 :: specializedInferredDeclaration1Up ->
                                                                specializedInferredDeclaration0
                                                                    :: specializedInferredDeclaration1Up
                                                                    ++ (declarationsInferredUnspecialized
                                                                            |> List.filter
                                                                                (\declarationInferredUnspecialized ->
                                                                                    Basics.not
                                                                                        (FastSet.member declarationInferredUnspecialized.name
                                                                                            specializedDeclarations.originalDeclarationNamesThatGotSplit
                                                                                        )
                                                                                )
                                                                       )
                                                    , module_ = syntaxModule
                                                    , moduleOriginLookup = moduleOriginLookup
                                                    , declarationTypes = currentModuleDeclarationTypesIncludingUnannotated
                                                    }
                                                        :: soFar.inferred
                                                , valueAndFunctionAnnotations =
                                                    soFar.valueAndFunctionAnnotations
                                                        |> FastDict.insert
                                                            moduleName
                                                            currentModuleDeclarationSignatureTypesIncludingUnannotated
                                                }
                                            )
                                )
                            |> Result.mapError
                                (\error ->
                                    "In module " ++ moduleName ++ ": " ++ error
                                )
                    )
    in
    case syntaxModulesInferredOrError of
        Err error ->
            { errors = [ error ]
            , declarations =
                { lets = []
                , fns = []
                , typeAliases = []
                , enumTypes = []
                , structs = []
                }
            }

        Ok modulesInferred ->
            let
                moduleDeclaredPorts :
                    FastDict.Dict
                        String
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        }
                moduleDeclaredPorts =
                    syntaxDeclarationsIncludingOverwrittenOnes
                        |> List.filter
                            (\syntaxModule ->
                                -- remove those modules we don't have a replacement for, yet
                                case
                                    syntaxModule.moduleDefinition
                                        |> Elm.Syntax.Node.value
                                        |> moduleHeaderName
                                of
                                    -- https://github.com/elm/core/blob/1.0.5/src/Elm/JsArray.elm
                                    "Elm.JsArray" ->
                                        False

                                    "Process" ->
                                        False

                                    "Task" ->
                                        False

                                    "File" ->
                                        False

                                    "Http" ->
                                        False

                                    "Browser" ->
                                        False

                                    "Browser.Events" ->
                                        False

                                    "Browser.Navigation" ->
                                        False

                                    "Browser.Dom" ->
                                        False

                                    -- https://github.com/elm/browser/blob/master/src/Browser/AnimationManager.elm
                                    "Browser.AnimationManager" ->
                                        False

                                    -- https://github.com/elm/browser/tree/master/src/Debugger
                                    "Debugger.Expando" ->
                                        False

                                    "Debugger.History" ->
                                        False

                                    "Debugger.Main" ->
                                        False

                                    "Debugger.Metadata" ->
                                        False

                                    "Debugger.Overlay" ->
                                        False

                                    "Debugger.Report" ->
                                        False

                                    "Markdown" ->
                                        False

                                    "Benchmark" ->
                                        False

                                    "WebGL" ->
                                        False

                                    "WebGL.Settings" ->
                                        False

                                    "WebGL.Settings.Blend" ->
                                        False

                                    "WebGL.Settings.DepthTest" ->
                                        False

                                    "WebGL.Settings.StencilTest" ->
                                        False

                                    "WebGL.Texture" ->
                                        False

                                    _ ->
                                        True
                            )
                        |> List.foldl
                            (\syntaxModule acrossModulesSoFar ->
                                acrossModulesSoFar
                                    |> FastDict.insert
                                        (syntaxModule.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName
                                        )
                                        (syntaxModule.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ declaration) membersSoFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.PortDeclaration portDeclaration ->
                                                            if portDeclaration.typeAnnotation |> portTypeSignifiesOutgoing then
                                                                { portsOutgoing =
                                                                    membersSoFar.portsOutgoing
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                , portsIncoming = membersSoFar.portsIncoming
                                                                }

                                                            else
                                                                { portsOutgoing = membersSoFar.portsOutgoing
                                                                , portsIncoming =
                                                                    membersSoFar.portsIncoming
                                                                        |> FastSet.insert
                                                                            (portDeclaration.name |> Elm.Syntax.Node.value)
                                                                }

                                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.AliasDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            membersSoFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            -- invalid syntax
                                                            membersSoFar
                                                )
                                                portsOutgoingDictEmptyPortsIncomingDictEmpty
                                        )
                            )
                            FastDict.empty

                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, type_ : ElmSyntaxTypeInfer.Type, recordFieldOrder : Maybe (List String) })
                typeAliasesInModule moduleNameToAccess =
                    modulesInferred.types
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases

                moduleInfo :
                    FastDict.Dict
                        {- module origin -} String
                        { portsIncoming : FastSet.Set String
                        , portsOutgoing : FastSet.Set String
                        , valueAndFunctionAnnotations :
                            FastDict.Dict
                                String
                                ElmSyntaxTypeInfer.Type
                        , typeAliases :
                            FastDict.Dict
                                String
                                { parameters : List String
                                , recordFieldOrder : Maybe (List String)
                                , type_ : ElmSyntaxTypeInfer.Type
                                }
                        }
                moduleInfo =
                    modulesPlusImplicitlyImportedToModuleContext
                        { ports = moduleDeclaredPorts
                        , types = modulesInferred.types
                        , valueAndFunctionAnnotations =
                            modulesInferred.valueAndFunctionAnnotations
                        }

                transpiledMoonbitDeclarations :
                    { errors : List String
                    , moonbitEnumTypes :
                        FastDict.Dict
                            String
                            { isShow : Bool
                            , isEq : Bool
                            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
                            }
                    , moonbitConsts : FastSet.Set String
                    , declarations :
                        { fns :
                            List
                                { name : String
                                , parameters : List { binding : Maybe String, type_ : MoonbitType }
                                , result : MoonbitExpression
                                , resultType : MoonbitType
                                }
                        , lets :
                            List
                                { name : String
                                , result : MoonbitExpression
                                , resultType : MoonbitType
                                }
                        , typeAliases :
                            List
                                { name : String
                                , parameters : List String
                                , type_ : MoonbitType
                                }
                        , enumTypes :
                            List
                                { name : String
                                , parameters : List String
                                , variants : FastDict.Dict String (List MoonbitType)
                                }
                        }
                    }
                transpiledMoonbitDeclarations =
                    modulesInferred.inferred
                        |> -- from most to least depended on
                           List.foldr
                            (\moduleInferred soFarAcrossModules ->
                                let
                                    moduleName : String
                                    moduleName =
                                        moduleInferred.module_.moduleDefinition
                                            |> Elm.Syntax.Node.value
                                            |> moduleHeaderName

                                    moduleDeclaredInferredTypeAliasesAndChoiceTypes :
                                        { typeAliasDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , type_ : ElmSyntaxTypeInfer.Type
                                                }
                                        , choiceTypeDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , variants :
                                                    FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
                                                }
                                        , errors : List String
                                        }
                                    moduleDeclaredInferredTypeAliasesAndChoiceTypes =
                                        moduleInferred.module_.declarations
                                            |> List.foldl
                                                (\(Elm.Syntax.Node.Node _ declaration) soFar ->
                                                    case declaration of
                                                        Elm.Syntax.Declaration.FunctionDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.PortDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.InfixDeclaration _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.Destructuring _ _ ->
                                                            soFar

                                                        Elm.Syntax.Declaration.AliasDeclaration syntaxTypeAliasDeclaration ->
                                                            let
                                                                typeAliasName : String
                                                                typeAliasName =
                                                                    syntaxTypeAliasDeclaration.name |> Elm.Syntax.Node.value
                                                            in
                                                            case moduleInferred.declarationTypes.typeAliases |> FastDict.get typeAliasName of
                                                                Nothing ->
                                                                    { typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                    , errors =
                                                                        ("bug in elm-syntax-to-moonbit: failed to find transformed type alias declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ typeAliasName
                                                                        )
                                                                            :: soFar.errors
                                                                    }

                                                                Just inferredTypeAliasDeclaration ->
                                                                    let
                                                                        inferredAliasedTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                                                                        inferredAliasedTypeWithExpandedAliases =
                                                                            inferredTypeAliasDeclaration.type_
                                                                                |> inferredTypeExpandInnerAliases typeAliasesInModule
                                                                    in
                                                                    if inferredAliasedTypeWithExpandedAliases |> inferredTypeContainsExtensibleRecord then
                                                                        soFar

                                                                    else
                                                                        { errors = soFar.errors
                                                                        , choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                        , typeAliasDeclarations =
                                                                            { name = typeAliasName
                                                                            , parameters = inferredTypeAliasDeclaration.parameters
                                                                            , type_ = inferredAliasedTypeWithExpandedAliases
                                                                            }
                                                                                :: soFar.typeAliasDeclarations
                                                                        }

                                                        Elm.Syntax.Declaration.CustomTypeDeclaration syntaxChoiceTypeDeclaration ->
                                                            let
                                                                choiceTypeName : String
                                                                choiceTypeName =
                                                                    syntaxChoiceTypeDeclaration.name |> Elm.Syntax.Node.value
                                                            in
                                                            case moduleInferred.declarationTypes.choiceTypes |> FastDict.get choiceTypeName of
                                                                Nothing ->
                                                                    { choiceTypeDeclarations = soFar.choiceTypeDeclarations
                                                                    , typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , errors =
                                                                        ("bug in elm-syntax-to-moonbit: failed to find transformed choice type declaration "
                                                                            ++ moduleName
                                                                            ++ "."
                                                                            ++ choiceTypeName
                                                                        )
                                                                            :: soFar.errors
                                                                    }

                                                                Just inferredChoiceTypeDeclaration ->
                                                                    { errors = soFar.errors
                                                                    , typeAliasDeclarations = soFar.typeAliasDeclarations
                                                                    , choiceTypeDeclarations =
                                                                        { name = choiceTypeName
                                                                        , parameters = inferredChoiceTypeDeclaration.parameters
                                                                        , variants = inferredChoiceTypeDeclaration.variants
                                                                        }
                                                                            :: soFar.choiceTypeDeclarations
                                                                    }
                                                )
                                                { choiceTypeDeclarations = []
                                                , typeAliasDeclarations = []
                                                , errors = []
                                                }

                                    transpiledModuleDeclaredMoonbitTypes :
                                        { moonbitEnumDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , variants : FastDict.Dict String (List MoonbitType)
                                                }
                                        , moonbitTypeAliasDeclarations :
                                            List
                                                { name : String
                                                , parameters : List String
                                                , type_ : MoonbitType
                                                }
                                        , moonbitEnumTypes :
                                            FastDict.Dict
                                                String
                                                { isShow : Bool
                                                , isEq : Bool
                                                , variantReferencedValueIndexes : FastDict.Dict String (List Int)
                                                }
                                        }
                                    transpiledModuleDeclaredMoonbitTypes =
                                        inferredTypeDeclarationsToMostToLeastDependedOn
                                            { moduleOrigin = moduleName
                                            , typeAliases = moduleDeclaredInferredTypeAliasesAndChoiceTypes.typeAliasDeclarations
                                            , choiceTypes = moduleDeclaredInferredTypeAliasesAndChoiceTypes.choiceTypeDeclarations
                                            }
                                            |> List.foldl
                                                (\inferredTypeDeclarationComponent soFar ->
                                                    case inferredTypeDeclarationComponent of
                                                        Graph.AcyclicSCC inferredTypeDeclaration ->
                                                            case inferredTypeDeclaration of
                                                                InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                    let
                                                                        moonbitTypeAliasDeclaration :
                                                                            { parameters : List String
                                                                            , type_ : MoonbitType
                                                                            }
                                                                        moonbitTypeAliasDeclaration =
                                                                            typeAliasDeclaration
                                                                                { typeAliasesInModule = typeAliasesInModule
                                                                                , moonbitEnumTypes = soFar.moonbitEnumTypes
                                                                                }
                                                                                { parameters = inferredTypeAliasDeclaration.parameters
                                                                                , type_ = inferredTypeAliasDeclaration.type_
                                                                                }
                                                                    in
                                                                    { moonbitEnumTypes = soFar.moonbitEnumTypes
                                                                    , moonbitEnumDeclarations = soFar.moonbitEnumDeclarations
                                                                    , moonbitTypeAliasDeclarations =
                                                                        { name =
                                                                            { moduleOrigin = moduleName
                                                                            , name = inferredTypeAliasDeclaration.name
                                                                            }
                                                                                |> elmReferenceToPascalCaseMoonbitName
                                                                        , parameters = moonbitTypeAliasDeclaration.parameters
                                                                        , type_ = moonbitTypeAliasDeclaration.type_
                                                                        }
                                                                            :: soFar.moonbitTypeAliasDeclarations
                                                                    }

                                                                InferredChoiceTypeDeclaration inferredChoiceAliasDeclaration ->
                                                                    let
                                                                        moonbitName : String
                                                                        moonbitName =
                                                                            { moduleOrigin = moduleName
                                                                            , name = inferredChoiceAliasDeclaration.name
                                                                            }
                                                                                |> elmReferenceToPascalCaseMoonbitName

                                                                        moonbitEnumDeclaration :
                                                                            { parameters : List String
                                                                            , variants : FastDict.Dict String (List MoonbitType)
                                                                            , isShow : Bool
                                                                            , isEq : Bool
                                                                            }
                                                                        moonbitEnumDeclaration =
                                                                            choiceTypeDeclaration
                                                                                { typeAliasesInModule = typeAliasesInModule
                                                                                , moonbitEnumTypes = soFar.moonbitEnumTypes
                                                                                }
                                                                                { parameters = inferredChoiceAliasDeclaration.parameters
                                                                                , variants = inferredChoiceAliasDeclaration.variants
                                                                                }
                                                                    in
                                                                    { moonbitTypeAliasDeclarations = soFar.moonbitTypeAliasDeclarations
                                                                    , moonbitEnumTypes =
                                                                        soFar.moonbitEnumTypes
                                                                            |> FastDict.insert moonbitName
                                                                                { isShow = moonbitEnumDeclaration.isShow
                                                                                , isEq = moonbitEnumDeclaration.isEq
                                                                                , variantReferencedValueIndexes = FastDict.empty
                                                                                }
                                                                    , moonbitEnumDeclarations =
                                                                        { name = moonbitName
                                                                        , parameters = moonbitEnumDeclaration.parameters
                                                                        , variants = moonbitEnumDeclaration.variants
                                                                        }
                                                                            :: soFar.moonbitEnumDeclarations
                                                                    }

                                                        Graph.CyclicSCC inferredTypeDeclarationCycle ->
                                                            let
                                                                cycleMemberNames : FastSet.Set String
                                                                cycleMemberNames =
                                                                    inferredTypeDeclarationCycle
                                                                        |> List.foldl
                                                                            (\inferredTypeDeclaration cycleMemberNamesSoFar ->
                                                                                cycleMemberNamesSoFar
                                                                                    |> FastSet.insert
                                                                                        ({ moduleOrigin = moduleName
                                                                                         , name =
                                                                                            case inferredTypeDeclaration of
                                                                                                InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                                                    inferredTypeAliasDeclaration.name

                                                                                                InferredChoiceTypeDeclaration inferredChoiceTypeDeclaration ->
                                                                                                    inferredChoiceTypeDeclaration.name
                                                                                         }
                                                                                            |> elmReferenceToPascalCaseMoonbitName
                                                                                        )
                                                                            )
                                                                            FastSet.empty

                                                                moonbitTypeIncludesCycleMember : MoonbitType -> Bool
                                                                moonbitTypeIncludesCycleMember moonbitType =
                                                                    moonbitType
                                                                        |> moonbitTypeIncludesAnyLocalEnumOrTypeAliasConstruct
                                                                            cycleMemberNames
                                                            in
                                                            inferredTypeDeclarationCycle
                                                                |> List.foldl
                                                                    (\inferredTypeDeclaration withCycleDeclarationsSoFar ->
                                                                        case inferredTypeDeclaration of
                                                                            InferredTypeAliasDeclaration inferredTypeAliasDeclaration ->
                                                                                let
                                                                                    moonbitTypeAliasDeclaration :
                                                                                        { parameters : List String
                                                                                        , type_ : MoonbitType
                                                                                        }
                                                                                    moonbitTypeAliasDeclaration =
                                                                                        typeAliasDeclaration
                                                                                            { typeAliasesInModule = typeAliasesInModule
                                                                                            , moonbitEnumTypes =
                                                                                                -- same effect as withCycleDeclarationsSoFar.moonbitEnumTypes
                                                                                                soFar.moonbitEnumTypes
                                                                                            }
                                                                                            { parameters = inferredTypeAliasDeclaration.parameters
                                                                                            , type_ = inferredTypeAliasDeclaration.type_
                                                                                            }
                                                                                in
                                                                                { moonbitEnumTypes = withCycleDeclarationsSoFar.moonbitEnumTypes
                                                                                , moonbitEnumDeclarations = withCycleDeclarationsSoFar.moonbitEnumDeclarations
                                                                                , moonbitTypeAliasDeclarations =
                                                                                    { name =
                                                                                        { moduleOrigin = moduleName
                                                                                        , name = inferredTypeAliasDeclaration.name
                                                                                        }
                                                                                            |> elmReferenceToPascalCaseMoonbitName
                                                                                    , parameters = moonbitTypeAliasDeclaration.parameters
                                                                                    , type_ = moonbitTypeAliasDeclaration.type_
                                                                                    }
                                                                                        :: withCycleDeclarationsSoFar.moonbitTypeAliasDeclarations
                                                                                }

                                                                            InferredChoiceTypeDeclaration inferredChoiceTypeDeclaration ->
                                                                                let
                                                                                    moonbitName : String
                                                                                    moonbitName =
                                                                                        { moduleOrigin = moduleName
                                                                                        , name = inferredChoiceTypeDeclaration.name
                                                                                        }
                                                                                            |> elmReferenceToPascalCaseMoonbitName

                                                                                    moonbitEnumDeclaration :
                                                                                        { parameters : List String
                                                                                        , variants : FastDict.Dict String (List MoonbitType)
                                                                                        , isShow : Bool
                                                                                        , isEq : Bool
                                                                                        }
                                                                                    moonbitEnumDeclaration =
                                                                                        choiceTypeDeclaration
                                                                                            { typeAliasesInModule = typeAliasesInModule
                                                                                            , moonbitEnumTypes = withCycleDeclarationsSoFar.moonbitEnumTypes
                                                                                            }
                                                                                            { parameters = inferredChoiceTypeDeclaration.parameters
                                                                                            , variants = inferredChoiceTypeDeclaration.variants
                                                                                            }
                                                                                in
                                                                                { moonbitTypeAliasDeclarations = withCycleDeclarationsSoFar.moonbitTypeAliasDeclarations
                                                                                , moonbitEnumTypes =
                                                                                    withCycleDeclarationsSoFar.moonbitEnumTypes
                                                                                        |> FastDict.insert moonbitName
                                                                                            { isShow = moonbitEnumDeclaration.isShow
                                                                                            , isEq = moonbitEnumDeclaration.isEq
                                                                                            , variantReferencedValueIndexes =
                                                                                                moonbitEnumDeclaration.variants
                                                                                                    |> FastDict.map
                                                                                                        (\_ values ->
                                                                                                            values
                                                                                                                |> List.indexedMap
                                                                                                                    (\valueIndex value ->
                                                                                                                        if value |> moonbitTypeIncludesCycleMember then
                                                                                                                            Just valueIndex

                                                                                                                        else
                                                                                                                            Nothing
                                                                                                                    )
                                                                                                                |> List.filterMap identity
                                                                                                        )
                                                                                            }
                                                                                , moonbitEnumDeclarations =
                                                                                    { name = moonbitName
                                                                                    , parameters = moonbitEnumDeclaration.parameters
                                                                                    , variants = moonbitEnumDeclaration.variants
                                                                                    }
                                                                                        :: withCycleDeclarationsSoFar.moonbitEnumDeclarations
                                                                                }
                                                                    )
                                                                    soFar
                                                )
                                                { moonbitEnumDeclarations = []
                                                , moonbitTypeAliasDeclarations = []
                                                , moonbitEnumTypes = soFarAcrossModules.moonbitEnumTypes
                                                }
                                in
                                moduleInferred.declarationsInferred
                                    |> inferredValueOrFunctionDeclarationsToMostToLeastDependedOn
                                        { moduleOrigin = moduleName }
                                    |> List.foldl
                                        (\valueOrFunctionDeclarationInferredComponent withInferredValeAndFunctionDeclarationsSoFar ->
                                            case valueOrFunctionDeclarationInferredComponent of
                                                Graph.AcyclicSCC valueOrFunctionDeclarationInferred ->
                                                    case
                                                        valueOrFunctionDeclarationInferred
                                                            |> valueOrFunctionDeclaration
                                                                { moduleInfo = moduleInfo
                                                                , moonbitEnumTypes = transpiledModuleDeclaredMoonbitTypes.moonbitEnumTypes
                                                                , moonbitConsts = withInferredValeAndFunctionDeclarationsSoFar.moonbitConsts
                                                                }
                                                    of
                                                        Ok moonbitValueOrFunctionDeclaration ->
                                                            let
                                                                moonbitName : String
                                                                moonbitName =
                                                                    { moduleOrigin = moduleName
                                                                    , name = valueOrFunctionDeclarationInferred.name
                                                                    }
                                                                        |> elmReferenceToSnakeCaseMoonbitName
                                                            in
                                                            case moonbitValueOrFunctionDeclaration.parameters of
                                                                Just parameters ->
                                                                    { errors = withInferredValeAndFunctionDeclarationsSoFar.errors
                                                                    , moonbitEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.moonbitEnumTypes
                                                                    , moonbitConsts = withInferredValeAndFunctionDeclarationsSoFar.moonbitConsts
                                                                    , declarations =
                                                                        { typeAliases = withInferredValeAndFunctionDeclarationsSoFar.declarations.typeAliases
                                                                        , enumTypes = withInferredValeAndFunctionDeclarationsSoFar.declarations.enumTypes
                                                                        , lets = withInferredValeAndFunctionDeclarationsSoFar.declarations.lets
                                                                        , fns =
                                                                            { name = moonbitName
                                                                            , parameters = parameters
                                                                            , resultType = moonbitValueOrFunctionDeclaration.resultType
                                                                            , result = moonbitValueOrFunctionDeclaration.result
                                                                            }
                                                                                :: withInferredValeAndFunctionDeclarationsSoFar.declarations.fns
                                                                        }
                                                                    }

                                                                Nothing ->
                                                                    { errors = withInferredValeAndFunctionDeclarationsSoFar.errors
                                                                    , moonbitEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.moonbitEnumTypes
                                                                    , moonbitConsts =
                                                                        withInferredValeAndFunctionDeclarationsSoFar.moonbitConsts
                                                                            |> FastSet.insert moonbitName
                                                                    , declarations =
                                                                        { typeAliases = withInferredValeAndFunctionDeclarationsSoFar.declarations.typeAliases
                                                                        , enumTypes = withInferredValeAndFunctionDeclarationsSoFar.declarations.enumTypes
                                                                        , fns = withInferredValeAndFunctionDeclarationsSoFar.declarations.fns
                                                                        , lets =
                                                                            { name = moonbitName
                                                                            , resultType = moonbitValueOrFunctionDeclaration.resultType
                                                                            , result = moonbitValueOrFunctionDeclaration.result
                                                                            }
                                                                                :: withInferredValeAndFunctionDeclarationsSoFar.declarations.lets
                                                                        }
                                                                    }

                                                        Err error ->
                                                            { declarations = withInferredValeAndFunctionDeclarationsSoFar.declarations
                                                            , moonbitEnumTypes = withInferredValeAndFunctionDeclarationsSoFar.moonbitEnumTypes
                                                            , moonbitConsts = withInferredValeAndFunctionDeclarationsSoFar.moonbitConsts
                                                            , errors =
                                                                ("in value/function declaration "
                                                                    ++ moduleName
                                                                    ++ "."
                                                                    ++ valueOrFunctionDeclarationInferred.name
                                                                    ++ ": "
                                                                    ++ error
                                                                )
                                                                    :: withInferredValeAndFunctionDeclarationsSoFar.errors
                                                            }

                                                Graph.CyclicSCC valueOrFunctionDeclarationInferredCycle ->
                                                    valueOrFunctionDeclarationInferredCycle
                                                        |> List.foldl
                                                            (\valueOrFunctionDeclarationInferred withCycleMembersSoFar ->
                                                                case
                                                                    valueOrFunctionDeclarationInferred
                                                                        |> valueOrFunctionDeclaration
                                                                            { moduleInfo = moduleInfo
                                                                            , moonbitEnumTypes = transpiledModuleDeclaredMoonbitTypes.moonbitEnumTypes
                                                                            , moonbitConsts = withCycleMembersSoFar.moonbitConsts
                                                                            }
                                                                of
                                                                    Ok moonbitValueOrFunctionDeclaration ->
                                                                        let
                                                                            moonbitName : String
                                                                            moonbitName =
                                                                                { moduleOrigin = moduleName
                                                                                , name = valueOrFunctionDeclarationInferred.name
                                                                                }
                                                                                    |> elmReferenceToSnakeCaseMoonbitName
                                                                        in
                                                                        { errors = withCycleMembersSoFar.errors
                                                                        , moonbitEnumTypes = withCycleMembersSoFar.moonbitEnumTypes
                                                                        , moonbitConsts = withCycleMembersSoFar.moonbitConsts
                                                                        , declarations =
                                                                            { typeAliases = withCycleMembersSoFar.declarations.typeAliases
                                                                            , enumTypes = withCycleMembersSoFar.declarations.enumTypes
                                                                            , lets = withCycleMembersSoFar.declarations.lets
                                                                            , fns =
                                                                                { name = moonbitName
                                                                                , parameters =
                                                                                    moonbitValueOrFunctionDeclaration.parameters
                                                                                        |> -- mutual recursion with a value declaration
                                                                                           -- is always an error
                                                                                           Maybe.withDefault []
                                                                                , resultType = moonbitValueOrFunctionDeclaration.resultType
                                                                                , result = moonbitValueOrFunctionDeclaration.result
                                                                                }
                                                                                    :: withCycleMembersSoFar.declarations.fns
                                                                            }
                                                                        }

                                                                    Err error ->
                                                                        { declarations = withCycleMembersSoFar.declarations
                                                                        , moonbitEnumTypes = withCycleMembersSoFar.moonbitEnumTypes
                                                                        , moonbitConsts = withCycleMembersSoFar.moonbitConsts
                                                                        , errors =
                                                                            ("in value/function declaration "
                                                                                ++ moduleName
                                                                                ++ "."
                                                                                ++ valueOrFunctionDeclarationInferred.name
                                                                                ++ ": "
                                                                                ++ error
                                                                            )
                                                                                :: withCycleMembersSoFar.errors
                                                                        }
                                                            )
                                                            withInferredValeAndFunctionDeclarationsSoFar
                                        )
                                        { errors =
                                            moduleDeclaredInferredTypeAliasesAndChoiceTypes.errors
                                                ++ soFarAcrossModules.errors
                                        , moonbitEnumTypes = transpiledModuleDeclaredMoonbitTypes.moonbitEnumTypes
                                        , moonbitConsts = soFarAcrossModules.moonbitConsts
                                        , declarations =
                                            { fns = soFarAcrossModules.declarations.fns
                                            , lets = soFarAcrossModules.declarations.lets
                                            , typeAliases =
                                                transpiledModuleDeclaredMoonbitTypes.moonbitTypeAliasDeclarations
                                                    ++ soFarAcrossModules.declarations.typeAliases
                                            , enumTypes =
                                                transpiledModuleDeclaredMoonbitTypes.moonbitEnumDeclarations
                                                    ++ soFarAcrossModules.declarations.enumTypes
                                            }
                                        }
                            )
                            { errors = []
                            , moonbitEnumTypes = FastDict.empty
                            , moonbitConsts = FastSet.empty
                            , declarations =
                                { lets = []
                                , fns = []
                                , typeAliases = []
                                , enumTypes = []
                                }
                            }
            in
            { declarations =
                { lets =
                    transpiledMoonbitDeclarations.declarations.lets
                        |> listToUniqueSortedDescendingBy .name
                , fns =
                    transpiledMoonbitDeclarations.declarations.fns
                        |> listToUniqueSortedDescendingBy .name
                , enumTypes =
                    transpiledMoonbitDeclarations.declarations.enumTypes
                        |> listToUniqueSortedDescendingBy .name
                , typeAliases =
                    transpiledMoonbitDeclarations.declarations.typeAliases
                        |> listToUniqueSortedDescendingBy .name
                , structs =
                    allElmRecords
                        |> FastSet.foldl
                            (\elmRecordFields soFar ->
                                case elmRecordFields of
                                    -- record given to Platform.worker
                                    [ "init", "subscriptions", "update" ] ->
                                        soFar

                                    -- record used by Time.customZone
                                    [ "offset", "start" ] ->
                                        soFar

                                    -- used by VirtualDom.Handler
                                    [ "message", "preventDefault", "stopPropagation" ] ->
                                        soFar

                                    elmRecordFieldsNotAlreadyInDefaultDeclarations ->
                                        { name = generatedRecordStructTypeName elmRecordFieldsNotAlreadyInDefaultDeclarations
                                        , parameters =
                                            elmRecordFieldsNotAlreadyInDefaultDeclarations
                                                |> List.map toPascalCaseMoonbitName
                                        , fields =
                                            elmRecordFieldsNotAlreadyInDefaultDeclarations
                                                |> List.map
                                                    (\elmRecordField ->
                                                        ( elmRecordField |> toSnakeCaseMoonbitName
                                                        , MoonbitTypeVariable
                                                            (elmRecordField |> toPascalCaseMoonbitName)
                                                        )
                                                    )
                                                |> FastDict.fromList
                                        }
                                            :: soFar
                            )
                            []
                }
            , errors =
                (modulesInferred.errors |> List.reverse)
                    ++ (transpiledMoonbitDeclarations.errors
                            |> List.reverse
                       )
            }


listToUniqueSortedDescendingBy : (a -> comparable_) -> List a -> List a
listToUniqueSortedDescendingBy elementToKey list =
    list
        |> List.sortBy elementToKey
        |> listReverseDeduplicateNeighboringElementsBy elementToKey


listReverseDeduplicateNeighboringElementsBy : (a -> comparable_) -> List a -> List a
listReverseDeduplicateNeighboringElementsBy elementToKey list =
    listReverseDeduplicateNeighboringElementsIntoBy [] elementToKey list


listReverseDeduplicateNeighboringElementsIntoBy : List a -> (a -> comparable_) -> List a -> List a
listReverseDeduplicateNeighboringElementsIntoBy soFar elementToKey list =
    -- can be optimized
    case list of
        [] ->
            soFar

        [ onlyElement ] ->
            onlyElement :: soFar

        element0 :: element1 :: element2Up ->
            if (element0 |> elementToKey) == (element1 |> elementToKey) then
                listReverseDeduplicateNeighboringElementsIntoBy soFar
                    elementToKey
                    (element1 :: element2Up)

            else
                listReverseDeduplicateNeighboringElementsIntoBy
                    (element0 :: soFar)
                    elementToKey
                    (element1 :: element2Up)


moonbitTypeIncludesAnyLocalEnumOrTypeAliasConstruct : FastSet.Set String -> MoonbitType -> Bool
moonbitTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs moonbitType =
    -- IGNORE TCO
    case moonbitType of
        MoonbitTypeInfer ->
            False

        MoonbitTypeConstruct typeConstruct ->
            ((typeConstruct.qualification |> List.isEmpty)
                && (needleTypeConstructs |> FastSet.member typeConstruct.name)
            )
                || (typeConstruct.arguments
                        |> List.any
                            (\argument ->
                                argument |> moonbitTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                            )
                   )

        MoonbitTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue |> moonbitTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                    )

        MoonbitTypeTuple parts ->
            (parts.part0
                |> moonbitTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
            )
                || (parts.part1
                        |> moonbitTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                   )
                || (parts.part2Up
                        |> List.any
                            (\part ->
                                part |> moonbitTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                            )
                   )

        MoonbitTypeVariable _ ->
            False

        MoonbitTypeFunction function ->
            (function.input
                |> List.any
                    (\input ->
                        input |> moonbitTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                    )
            )
                || (function.output
                        |> moonbitTypeIncludesAnyLocalEnumOrTypeAliasConstruct needleTypeConstructs
                   )


generatedRecordStructTypeName : List String -> String
generatedRecordStructTypeName elmFieldNames =
    "Generated"
        ++ (elmFieldNames
                |> List.map stringFirstCharToUpper
                |> String.concat
           )
        |> toPascalCaseMoonbitName


portsOutgoingDictEmptyPortsIncomingDictEmpty : { portsOutgoing : FastSet.Set a, portsIncoming : FastSet.Set a }
portsOutgoingDictEmptyPortsIncomingDictEmpty =
    { portsOutgoing = FastSet.empty
    , portsIncoming = FastSet.empty
    }


listFoldlWhileOkFrom :
    okFolded
    -> (a -> okFolded -> Result err okFolded)
    -> List a
    -> Result err okFolded
listFoldlWhileOkFrom initialOkFolded reduceOnOk list =
    case list of
        [] ->
            Ok initialOkFolded

        head :: tail ->
            case initialOkFolded |> reduceOnOk head of
                Err error ->
                    Err error

                Ok okFoldedWithHead ->
                    listFoldlWhileOkFrom okFoldedWithHead reduceOnOk tail


listMapAndFirstJust : (element -> Maybe found) -> List element -> Maybe found
listMapAndFirstJust elementToMaybeFound list =
    case list of
        [] ->
            Nothing

        head :: tail ->
            case head |> elementToMaybeFound of
                Just found ->
                    Just found

                Nothing ->
                    listMapAndFirstJust elementToMaybeFound tail


baseElmDeclarationTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
baseElmDeclarationTypes =
    ElmSyntaxTypeInfer.elmCoreTypes
        |> FastDict.union elmJsonTypes
        |> FastDict.union elmBytesTypes
        |> FastDict.union elmVirtualDomTypes
        |> FastDict.union elmKernelVirtualDomTypes
        |> FastDict.union elmRandomTypes
        |> FastDict.union elmRegexTypes
        |> FastDict.union elmTimeTypes
        |> FastDict.union elmExplorationsLinearAlgebraTypes
        |> FastDict.union elmKernelParserTypes
        |> FastDict.union elmKernelUrlTypes


portTypeSignifiesOutgoing :
    Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Bool
portTypeSignifiesOutgoing (Elm.Syntax.Node.Node _ syntaxType) =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ (Elm.Syntax.Node.Node _ output) ->
            case output of
                Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
                    name |> String.toLower |> String.contains "cmd"

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    False

                Elm.Syntax.TypeAnnotation.Unit ->
                    False

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    False

                Elm.Syntax.TypeAnnotation.Record _ ->
                    False

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    False

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    False

        Elm.Syntax.TypeAnnotation.Typed (Elm.Syntax.Node.Node _ ( _, name )) _ ->
            name |> String.toLower |> String.contains "cmd"

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            False

        Elm.Syntax.TypeAnnotation.Unit ->
            False

        Elm.Syntax.TypeAnnotation.Tupled _ ->
            False

        Elm.Syntax.TypeAnnotation.Record _ ->
            False

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            False


patternTypedNodeIntroducedVariables :
    ElmSyntaxTypeInfer.TypedNode
        ElmSyntaxTypeInfer.Pattern
    -> FastDict.Dict String ElmSyntaxTypeInfer.Type
patternTypedNodeIntroducedVariables patternTypedNode =
    -- IGNORE TCO
    case patternTypedNode.value of
        ElmSyntaxTypeInfer.PatternIgnored ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternChar _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternString _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternInt _ ->
            FastDict.empty

        ElmSyntaxTypeInfer.PatternVariable variable ->
            FastDict.singleton variable patternTypedNode.type_

        ElmSyntaxTypeInfer.PatternParenthesized inParens ->
            patternTypedNodeIntroducedVariables inParens

        ElmSyntaxTypeInfer.PatternAs patternAs ->
            FastDict.insert patternAs.variable.value
                patternAs.variable.type_
                (patternAs.pattern
                    |> patternTypedNodeIntroducedVariables
                )

        ElmSyntaxTypeInfer.PatternTuple parts ->
            parts.part0
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (parts.part1
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternTriple parts ->
            parts.part0
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (parts.part1
                        |> patternTypedNodeIntroducedVariables
                    )
                |> FastDict.union
                    (parts.part2
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternListCons patternListCons ->
            patternListCons.head
                |> patternTypedNodeIntroducedVariables
                |> FastDict.union
                    (patternListCons.tail
                        |> patternTypedNodeIntroducedVariables
                    )

        ElmSyntaxTypeInfer.PatternListExact elements ->
            elements
                |> listMapToFastDictsAndUnify
                    patternTypedNodeIntroducedVariables

        ElmSyntaxTypeInfer.PatternVariant patternVariant ->
            patternVariant.values
                |> listMapToFastDictsAndUnify
                    patternTypedNodeIntroducedVariables

        ElmSyntaxTypeInfer.PatternRecord fields ->
            fields
                |> List.foldl
                    (\fieldTypedNode soFar ->
                        soFar
                            |> FastDict.insert fieldTypedNode.value
                                fieldTypedNode.type_
                    )
                    FastDict.empty


moduleHeaderName : Elm.Syntax.Module.Module -> String
moduleHeaderName moduleHeader =
    (case moduleHeader of
        Elm.Syntax.Module.NormalModule header ->
            header.moduleName

        Elm.Syntax.Module.PortModule header ->
            header.moduleName

        Elm.Syntax.Module.EffectModule header ->
            header.moduleName
    )
        |> Elm.Syntax.Node.value
        |> String.join "."


type alias InferredValueOrFunctionDeclaration =
    { name : String
    , nameRange : Elm.Syntax.Range.Range
    , documentation : Maybe { content : String, range : Elm.Syntax.Range.Range }
    , signature :
        Maybe
            { range : Elm.Syntax.Range.Range
            , nameRange : Elm.Syntax.Range.Range
            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
            , annotationTypeRange : Elm.Syntax.Range.Range
            }
    , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    , type_ : ElmSyntaxTypeInfer.Type
    }


valueOrFunctionDeclaration :
    { moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , moonbitEnumTypes :
        FastDict.Dict
            String
            { isShow : Bool
            , isEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    , moonbitConsts : FastSet.Set String
    }
    -> InferredValueOrFunctionDeclaration
    ->
        Result
            String
            { parameters : Maybe (List { binding : Maybe String, type_ : MoonbitType })
            , result : MoonbitExpression
            , resultType : MoonbitType
            }
valueOrFunctionDeclaration context syntaxDeclarationValueOrFunction =
    let
        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            syntaxDeclarationValueOrFunction.type_
                |> inferredTypeExpandInnerAliases typeAliasesInModule

        moonbitFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        moonbitFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction

        syntaxParameterCount : Int
        syntaxParameterCount =
            syntaxDeclarationValueOrFunction.parameters
                |> List.length

        additionalGeneratedParameters : List { name : String, type_ : MoonbitType }
        additionalGeneratedParameters =
            moonbitFullTypeAsFunction.inputs
                |> List.drop syntaxParameterCount
                |> List.indexedMap
                    (\additionalParameterIndex additionalParameterInferredType ->
                        { name =
                            generatedParameterNameForIndex
                                (syntaxParameterCount + additionalParameterIndex)
                        , type_ =
                            additionalParameterInferredType
                                |> type_
                                    { typeAliasesInModule = typeAliasesInModule
                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                    }
                                |> moonbitTypeUnnestFn
                        }
                    )

        elmParametersAsMoonbit :
            { patterns : List { pattern : MoonbitPattern, type_ : MoonbitType }
            }
        elmParametersAsMoonbit =
            syntaxDeclarationValueOrFunction.parameters
                |> List.foldr
                    (\parameter soFar ->
                        let
                            moonbitParameter :
                                { pattern : MoonbitPattern
                                , guardConditions : List MoonbitExpression
                                }
                            moonbitParameter =
                                parameter
                                    |> pattern
                                        { typeAliasesInModule = typeAliasesInModule
                                        , moonbitEnumTypes = context.moonbitEnumTypes
                                        }
                        in
                        { patterns =
                            ({ pattern = moonbitParameter.pattern
                             , type_ =
                                parameter.type_
                                    |> type_
                                        { typeAliasesInModule = typeAliasesInModule
                                        , moonbitEnumTypes = context.moonbitEnumTypes
                                        }
                             }
                                |> moonbitParameterUnnestFn
                            )
                                :: soFar.patterns
                        }
                    )
                    { patterns = []
                    }

        allMoonbitParameters : List { pattern : MoonbitPattern, type_ : MoonbitType }
        allMoonbitParameters =
            elmParametersAsMoonbit.patterns
                ++ (additionalGeneratedParameters
                        |> List.map
                            (\additionalParameter ->
                                let
                                    additionalParameterTypeUnnestedFn : MoonbitType
                                    additionalParameterTypeUnnestedFn =
                                        additionalParameter.type_
                                            |> moonbitTypeUnnestFn
                                in
                                { pattern =
                                    MoonbitPatternVariable
                                        { name = additionalParameter.name
                                        , type_ = additionalParameterTypeUnnestedFn
                                        }
                                , type_ = additionalParameterTypeUnnestedFn
                                }
                            )
                   )
    in
    Result.map
        (\moonbitResult ->
            let
                moonbitResultType : MoonbitType
                moonbitResultType =
                    syntaxDeclarationValueOrFunction.type_
                        |> type_
                            { typeAliasesInModule = typeAliasesInModule
                            , moonbitEnumTypes = context.moonbitEnumTypes
                            }
            in
            if
                (moonbitFullTypeAsFunction.inputs |> List.isEmpty)
                    && (-- https://github.com/moonbit-lang/moonbit/issues/113521
                        moonbitResultType |> moonbitTypeIsConcrete
                       )
            then
                { parameters = Nothing
                , resultType = moonbitResultType
                , result = moonbitResult
                }

            else
                let
                    resultWithAdditionalGeneratedArgumentsApplied : MoonbitExpression
                    resultWithAdditionalGeneratedArgumentsApplied =
                        additionalGeneratedParameters
                            |> List.foldl
                                (\additionalGeneratedParameter soFar ->
                                    moonbitExpressionCallCondense
                                        { called = soFar
                                        , argument =
                                            MoonbitExpressionReference
                                                { qualification = []
                                                , name = additionalGeneratedParameter.name
                                                }
                                        }
                                )
                                moonbitResult
                in
                { parameters =
                    Just
                        (allMoonbitParameters
                            |> List.indexedMap
                                (\parameterIndex parameter ->
                                    { binding =
                                        case parameter.pattern of
                                            MoonbitPatternVariable parameterVariable ->
                                                Just parameterVariable.name

                                            MoonbitPatternIgnore ->
                                                Nothing

                                            _ ->
                                                Just (generatedParameterNameForIndex parameterIndex)
                                    , type_ = parameter.type_
                                    }
                                )
                        )
                , resultType =
                    moonbitFullTypeAsFunction.output
                        |> type_
                            { typeAliasesInModule = typeAliasesInModule
                            , moonbitEnumTypes = context.moonbitEnumTypes
                            }
                , result =
                    resultWithAdditionalGeneratedArgumentsApplied
                        |> moonbitExpressionPrependStatements
                            (allMoonbitParameters
                                |> List.indexedMap Tuple.pair
                                |> List.filterMap
                                    (\( parameterIndex, parameter ) ->
                                        case parameter.pattern of
                                            MoonbitPatternVariable _ ->
                                                Nothing

                                            MoonbitPatternIgnore ->
                                                Nothing

                                            parameterPatternThatNeedsToBeDestructured ->
                                                Just
                                                    (MoonbitStatementLetDestructuring
                                                        { pattern = parameterPatternThatNeedsToBeDestructured
                                                        , expression =
                                                            MoonbitExpressionReference
                                                                { qualification = []
                                                                , name = generatedParameterNameForIndex parameterIndex
                                                                }
                                                        }
                                                    )
                                    )
                            )
                }
        )
        (syntaxDeclarationValueOrFunction.result
            |> expression
                { moduleInfo = context.moduleInfo
                , localElmBindingsInScope =
                    syntaxDeclarationValueOrFunction.parameters
                        |> listMapToFastDictsAndUnify
                            patternTypedNodeIntroducedVariables
                , functionDeclaredMoonbitParameterEquivalentBindings =
                    allMoonbitParameters
                        |> listMapToFastSetsAndUnify
                            (\moonbitParameter ->
                                moonbitParameter.pattern
                                    |> moonbitPatternDirectlyCapturingBindings
                            )
                , letDeclaredValueAndFunctionTypes = FastDict.empty
                , moonbitEnumTypes = context.moonbitEnumTypes
                , moonbitConsts = context.moonbitConsts
                , path = [ "result" ]
                }
        )


moonbitParameterUnnestFn :
    { pattern : MoonbitPattern, type_ : MoonbitType }
    -> { pattern : MoonbitPattern, type_ : MoonbitType }
moonbitParameterUnnestFn parameter =
    let
        typeUnnestedFn : MoonbitType
        typeUnnestedFn =
            parameter.type_ |> moonbitTypeUnnestFn
    in
    { pattern =
        parameter.pattern
            |> moonbitPatternDirectlyCapturingBindingsSetType typeUnnestedFn
    , type_ = typeUnnestedFn
    }


{-| E.g. in

    (a @ ((b) @ ( first, second @ third )))

the "directly capturing" bindings are `a` and `b`
as they reference the whole matched expression.

-}
moonbitPatternDirectlyCapturingBindingsSetType : MoonbitType -> MoonbitPattern -> MoonbitPattern
moonbitPatternDirectlyCapturingBindingsSetType newMoonbitType moonbitPattern =
    -- IGNORE TCO
    case moonbitPattern of
        MoonbitPatternIgnore ->
            MoonbitPatternIgnore

        MoonbitPatternChar _ ->
            moonbitPattern

        MoonbitPatternString _ ->
            moonbitPattern

        MoonbitPatternInteger _ ->
            moonbitPattern

        MoonbitPatternTuple _ ->
            moonbitPattern

        MoonbitPatternVariant _ ->
            moonbitPattern

        MoonbitPatternStructNotExhaustive _ ->
            moonbitPattern

        MoonbitPatternVariable binding ->
            MoonbitPatternVariable
                { name = binding.name
                , type_ = newMoonbitType
                }

        MoonbitPatternAlias patternAlias ->
            MoonbitPatternAlias
                { variable = patternAlias.variable
                , type_ = newMoonbitType
                , pattern =
                    patternAlias.pattern
                        |> moonbitPatternDirectlyCapturingBindingsSetType newMoonbitType
                }


{-| `Fn(First) -> Fn(Second) -> Out` to `Fn(First, Second) -> Out`
-}
moonbitTypeUnnestFn : MoonbitType -> MoonbitType
moonbitTypeUnnestFn moonbitType =
    moonbitTypeUnnestFnPrependReverseInputs [] moonbitType


{-| `Fn(First) -> Fn(Second) -> Out` to `Fn(First, Second) -> Out`
-}
moonbitTypeUnnestFnPrependReverseInputs : List MoonbitType -> MoonbitType -> MoonbitType
moonbitTypeUnnestFnPrependReverseInputs reverseInputsToPrepend moonbitType =
    case moonbitType of
        MoonbitTypeFunction typeFn ->
            moonbitTypeUnnestFnPrependReverseInputs
                (reverseInputsToPrepend
                    |> listPrependInReverse typeFn.input
                )
                typeFn.output

        _ ->
            case reverseInputsToPrepend of
                [] ->
                    moonbitType

                _ ->
                    MoonbitTypeFunction
                        { input = reverseInputsToPrepend |> List.reverse
                        , output = moonbitType
                        }


listPrependInReverse : List a -> List a -> List a
listPrependInReverse earlierReverse later =
    case earlierReverse of
        [] ->
            later

        earlierLast :: earlierBeforeLastReverse ->
            listPrependInReverse earlierBeforeLastReverse
                (earlierLast :: later)


generatedParameterNameForIndex : Int -> String
generatedParameterNameForIndex parameterIndex =
    "generated_" ++ (parameterIndex |> String.fromInt)


variableNameDisambiguateFromMoonbitKeywords : String -> String
variableNameDisambiguateFromMoonbitKeywords variableName =
    if
        (moonbitKeywords |> FastSet.member variableName)
            || -- to avoid overlaps, push other variables further with -1
               ((variableName |> String.endsWith "_")
                    && (moonbitKeywords |> FastSet.member (variableName |> String.dropRight 1))
               )
    then
        variableName ++ "1"

    else
        variableName


{-| both weak, reserved and strong.
see https://docs.moonbitlang.com/en/latest/language/introduction.html
-}
moonbitKeywords : FastSet.Set String
moonbitKeywords =
    FastSet.fromList
        [ "as"
        , "else"
        , "extern"
        , "fn"
        , "fnalias"
        , "if"
        , "let"
        , "const"
        , "match"
        , "using"
        , "mut"
        , "type"
        , "typealias"
        , "struct"
        , "enum"
        , "trait"
        , "traitalias"
        , "derive"
        , "while"
        , "break"
        , "continue"
        , "import"
        , "return"
        , "throw"
        , "raise"
        , "try"
        , "catch"
        , "pub"
        , "priv"
        , "readonly"
        , "true"
        , "false"
        , "_"
        , "test"
        , "loop"
        , "for"
        , "in"
        , "impl"
        , "with"
        , "guard"
        , "async"
        , "is"
        , "suberror"
        , "and"
        , "letrec"
        , "enumview"
        , "noraise"
        , "defer"
        , "Error"
        , -- reserved for future use
          "module"
        , "move"
        , "ref"
        , "static"
        , "super"
        , "unsafe"
        , "use"
        , "where"
        , "await"
        , "dyn"
        , "abstract"
        , "do"
        , "final"
        , "macro"
        , "override"
        , "typeof"
        , "virtual"
        , "yield"
        , "local"
        , "method"
        , "alias"
        , "assert"
        , "package"
        , "recur"
        , "using"
        , "enumview"
        , "isnot"
        , "define"
        , "downcast"
        , "inherit"
        , "member"
        , "namespace"
        , "static"
        , "upcast"
        , "use"
        , "void"
        , "lazy"
        , "include"
        , "mixin"
        , "protected"
        , "sealed"
        , "constructor"
        , "atomic"
        , "volatile"
        , "anyframe"
        , "anytype"
        , "asm"
        , "await"
        , "comptime"
        , "errdefer"
        , "export"
        , "opaque"
        , "orelse"
        , "resume"
        , "threadlocal"
        , "unreachable"
        , "dynclass"
        , "dynobj"
        , "dynrec"
        , "var"
        , "finally"
        , "noasync"
        ]


type alias ExpressionToMoonbitContext =
    { localElmBindingsInScope : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , -- when a parameter of a module declared and locally declared function
      -- immediately captures its value (e.g. func a = ... or func (a as _) = ...)
      functionDeclaredMoonbitParameterEquivalentBindings : FastSet.Set String
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , -- TODO rename to valueAndFunctionTypesWithExpandedAliases
              valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    , moonbitEnumTypes :
        FastDict.Dict
            String
            { isShow : Bool
            , isEq : Bool
            , variantReferencedValueIndexes : FastDict.Dict String (List Int)
            }
    , moonbitConsts : FastSet.Set String
    , path : List String
    }


moonbitExpressionClosureReduced :
    { parameters : List { binding : Maybe String, type_ : Maybe MoonbitType }
    , result : MoonbitExpression
    }
    -> MoonbitExpression
moonbitExpressionClosureReduced closure =
    let
        closureParametersMaybeAsBindings : Maybe (List String)
        closureParametersMaybeAsBindings =
            closure.parameters
                |> listMapAndCombineJust
                    (\parameter ->
                        parameter.binding
                    )
    in
    case closureParametersMaybeAsBindings of
        Nothing ->
            MoonbitExpressionClosure
                { parameters = closure.parameters
                , result = closure.result
                , resultType = Nothing
                }

        Just closureParametersAsBindings ->
            case closure.result of
                MoonbitExpressionCall closureResultCall ->
                    if
                        listAll2
                            closureParametersAsBindings
                            closureResultCall.arguments
                            (\parameterBindingName closureResultCallArgument ->
                                case closureResultCallArgument of
                                    MoonbitExpressionReference reference ->
                                        (reference.qualification |> List.isEmpty)
                                            && (reference.name == parameterBindingName)

                                    _ ->
                                        False
                            )
                            && ((closureParametersAsBindings |> List.length)
                                    == (closureResultCall.arguments |> List.length)
                               )
                            && Basics.not
                                (let
                                    calledLocalBindings : FastSet.Set String
                                    calledLocalBindings =
                                        closureResultCall.called
                                            |> moonbitExpressionUsedLocalBindings
                                 in
                                 List.any
                                    (\parameterBinding ->
                                        calledLocalBindings
                                            |> FastSet.member parameterBinding
                                    )
                                    closureParametersAsBindings
                                )
                    then
                        closureResultCall.called

                    else
                        MoonbitExpressionClosure
                            { parameters = closure.parameters
                            , result = closure.result
                            , resultType = Nothing
                            }

                _ ->
                    MoonbitExpressionClosure
                        { parameters = closure.parameters
                        , result = closure.result
                        , resultType = Nothing
                        }


listAll2 : List a -> List b -> (a -> b -> Bool) -> Bool
listAll2 aList bList abIsExpected =
    case aList of
        [] ->
            True

        aHead :: aTail ->
            case bList of
                [] ->
                    True

                bHead :: bTail ->
                    -- not && to trigger TCO
                    if abIsExpected aHead bHead then
                        listAll2 aTail bTail abIsExpected

                    else
                        False


type IntOrFloat
    = IntNotFloat
    | FloatNotInt


inferredTypeCheckOrGuessIntOrFloat : ElmSyntaxTypeInfer.Type -> IntOrFloat
inferredTypeCheckOrGuessIntOrFloat inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable inputTypeVariable ->
            if inputTypeVariable.name |> String.startsWith "number" then
                -- assume Float
                FloatNotInt

            else
                -- assume Int
                IntNotFloat

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            case inferredTypeNotVariable of
                ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
                    case typeConstruct.moduleOrigin of
                        "Basics" ->
                            case typeConstruct.name of
                                "Float" ->
                                    FloatNotInt

                                "Int" ->
                                    IntNotFloat

                                _ ->
                                    IntNotFloat

                        _ ->
                            IntNotFloat

                ElmSyntaxTypeInfer.TypeUnit ->
                    -- incorrect type inference, assume Float
                    IntNotFloat

                ElmSyntaxTypeInfer.TypeTuple _ ->
                    -- incorrect type inference, assume Float
                    IntNotFloat

                ElmSyntaxTypeInfer.TypeTriple _ ->
                    -- incorrect type inference, assume Float
                    IntNotFloat

                ElmSyntaxTypeInfer.TypeRecord _ ->
                    -- incorrect type inference, assume Float
                    IntNotFloat

                ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                    -- incorrect type inference, assume Float
                    IntNotFloat

                ElmSyntaxTypeInfer.TypeFunction _ ->
                    -- incorrect type inference, assume Float
                    IntNotFloat


{-| Attention: Use `expressionWrappingInLetIfOrMatchResult`
instead when moonbit if/match are not allowed as `.result`
-}
expression :
    ExpressionToMoonbitContext
    -> ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> Result String MoonbitExpression
expression context expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            Ok MoonbitExpressionUnit

        ElmSyntaxTypeInfer.ExpressionInteger intValue ->
            case expressionTypedNode.type_ |> inferredTypeCheckOrGuessIntOrFloat of
                IntNotFloat ->
                    Ok (MoonbitExpressionInt64 intValue.value)

                FloatNotInt ->
                    Ok (MoonbitExpressionDouble (intValue.value |> Basics.toFloat))

        ElmSyntaxTypeInfer.ExpressionFloat doubleValue ->
            Ok (MoonbitExpressionDouble doubleValue)

        ElmSyntaxTypeInfer.ExpressionChar charValue ->
            Ok (MoonbitExpressionChar charValue)

        ElmSyntaxTypeInfer.ExpressionString stringValue ->
            Ok
                (MoonbitExpressionCall
                    { called = moonbitExpressionReferenceVariantStringStringOne
                    , arguments = [ MoonbitExpressionString stringValue ]
                    }
                )

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction fieldName ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    let
                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases

                        inputRecordMoonbitType : MoonbitType
                        inputRecordMoonbitType =
                            typeFunction.input
                                |> type_
                                    { typeAliasesInModule = typeAliasesInModule
                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                    }
                    in
                    Ok
                        (moonbitExpressionClosureReduced
                            { parameters =
                                [ { binding =
                                        Just generatedAccessedStructVariableName
                                  , type_ = Just inputRecordMoonbitType
                                  }
                                ]
                            , result =
                                MoonbitExpressionStructAccess
                                    { struct =
                                        MoonbitExpressionReference
                                            { qualification = []
                                            , name = generatedAccessedStructVariableName
                                            }
                                    , field =
                                        fieldName
                                            |> String.replace "." ""
                                            |> toSnakeCaseMoonbitName
                                    }
                            }
                        )

                _ ->
                    Err "record access function has an inferred type that wasn't a function"

        ElmSyntaxTypeInfer.ExpressionOperatorFunction operator ->
            let
                inferredTypeAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                inferredTypeAsFunction =
                    expressionTypedNode.type_ |> inferredTypeExpandToFunction
            in
            case inferredTypeAsFunction.inputs of
                leftInferredType :: rightInferredType :: _ ->
                    let
                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Result.map
                        (\reference ->
                            let
                                leftMoonbitType : MoonbitType
                                leftMoonbitType =
                                    leftInferredType
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , moonbitEnumTypes = context.moonbitEnumTypes
                                            }

                                rightMoonbitType : MoonbitType
                                rightMoonbitType =
                                    rightInferredType
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , moonbitEnumTypes = context.moonbitEnumTypes
                                            }
                            in
                            moonbitExpressionClosureReduced
                                { parameters =
                                    [ { binding = Just "generated_left"
                                      , type_ = Just leftMoonbitType
                                      }
                                    ]
                                , result =
                                    moonbitExpressionClosureReduced
                                        { parameters =
                                            [ { binding = Just "generated_right"
                                              , type_ = Just rightMoonbitType
                                              }
                                            ]
                                        , result =
                                            MoonbitExpressionCall
                                                { called =
                                                    MoonbitExpressionReference
                                                        { qualification = reference.qualification
                                                        , name = reference.name
                                                        }
                                                , arguments =
                                                    [ MoonbitExpressionReference
                                                        { qualification = [], name = "generated_left" }
                                                    , MoonbitExpressionReference
                                                        { qualification = [], name = "generated_right" }
                                                    ]
                                                }
                                        }
                                }
                        )
                        (expressionOperatorToMoonbitFunctionReference
                            { moduleOrigin = operator.moduleOrigin
                            , symbol = operator.symbol
                            , type_ = expressionTypedNode.type_
                            }
                        )

                _ ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") I tried to transpile the operator function ("
                            ++ operator.symbol
                            ++ ") to a lambda into a call but for that I needed to find the left and right argument types which I couldn't"
                        )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            Result.map2
                (\called moonbitArguments ->
                    let
                        calledAsFnDeclaredParameterTypes : Maybe (List ElmSyntaxTypeInfer.Type)
                        calledAsFnDeclaredParameterTypes =
                            case call.called.value of
                                ElmSyntaxTypeInfer.ExpressionReference calledReference ->
                                    case calledReference.moduleOrigin of
                                        "" ->
                                            context.letDeclaredValueAndFunctionTypes
                                                |> FastDict.get calledReference.name
                                                |> Maybe.andThen (\function -> function)
                                                |> Maybe.map .parameters

                                        moduleOrigin ->
                                            context.moduleInfo
                                                |> FastDict.get moduleOrigin
                                                |> Maybe.andThen
                                                    (\inModule ->
                                                        inModule.valueAndFunctionAnnotations
                                                            |> FastDict.get calledReference.name
                                                    )
                                                |> Maybe.map
                                                    (\originType ->
                                                        originType
                                                            |> inferredTypeExpandFunction
                                                            |> .inputs
                                                    )

                                _ ->
                                    Nothing
                    in
                    case calledAsFnDeclaredParameterTypes of
                        Nothing ->
                            moonbitArguments
                                |> List.foldl
                                    (\argument condensedSoFar ->
                                        moonbitExpressionCallCondense
                                            { called = condensedSoFar
                                            , argument = argument
                                            }
                                    )
                                    called

                        Just calledFnDeclaredParameterTypes ->
                            let
                                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                typeAliasesInModule moduleNameToAccess =
                                    context.moduleInfo
                                        |> FastDict.get moduleNameToAccess
                                        |> Maybe.map .typeAliases
                            in
                            List.map4
                                (\index moonbitArgument originType inferredType ->
                                    { index = index
                                    , moonbit = moonbitArgument
                                    , originTypeFunctionInput =
                                        originType
                                            |> inferredTypeExpandFunction
                                            |> .inputs
                                    , inferredType = inferredType
                                    }
                                )
                                (List.range 0 ((calledFnDeclaredParameterTypes |> List.length) - 1))
                                moonbitArguments
                                calledFnDeclaredParameterTypes
                                (call.called.type_
                                    |> inferredTypeExpandFunction
                                    |> .inputs
                                )
                                |> List.foldl
                                    (\argument condensedSoFar ->
                                        case argument.originTypeFunctionInput of
                                            [] ->
                                                moonbitExpressionCallCondense
                                                    { called = condensedSoFar
                                                    , argument = argument.moonbit
                                                    }

                                            [ _ ] ->
                                                moonbitExpressionCallCondense
                                                    { called = condensedSoFar
                                                    , argument = argument.moonbit
                                                    }

                                            _ :: _ :: _ ->
                                                let
                                                    argumentPath : List String
                                                    argumentPath =
                                                        ("unnest" ++ (argument.index |> String.fromInt))
                                                            :: context.path

                                                    unnested :
                                                        { parametersReverse :
                                                            List
                                                                { binding : Maybe String
                                                                , type_ : Maybe MoonbitType
                                                                }
                                                        , moonbitArgumentCondensed : MoonbitExpression
                                                        }
                                                    unnested =
                                                        argument.inferredType
                                                            |> inferredTypeExpandFunction
                                                            |> .inputs
                                                            |> List.indexedMap Tuple.pair
                                                            |> List.foldl
                                                                (\( unnestParameterIndex, unnestParameterType ) soFar ->
                                                                    case soFar.moonbitArgumentCondensed of
                                                                        MoonbitExpressionClosure moonbitArgumentCondensedClosure ->
                                                                            { parametersReverse =
                                                                                moonbitArgumentCondensedClosure.parameters
                                                                                    ++ soFar.parametersReverse
                                                                            , moonbitArgumentCondensed =
                                                                                moonbitArgumentCondensedClosure.result
                                                                            }

                                                                        _ ->
                                                                            let
                                                                                unnestMoonbitParameterType : MoonbitType
                                                                                unnestMoonbitParameterType =
                                                                                    unnestParameterType
                                                                                        |> type_
                                                                                            { typeAliasesInModule = typeAliasesInModule
                                                                                            , moonbitEnumTypes = context.moonbitEnumTypes
                                                                                            }

                                                                                unnestParameterName : String
                                                                                unnestParameterName =
                                                                                    generatedParameterNameForIndexAtPath unnestParameterIndex
                                                                                        argumentPath
                                                                            in
                                                                            { parametersReverse =
                                                                                { binding = Just unnestParameterName
                                                                                , type_ = Just unnestMoonbitParameterType
                                                                                }
                                                                                    :: soFar.parametersReverse
                                                                            , moonbitArgumentCondensed =
                                                                                moonbitExpressionCallCondense
                                                                                    { called = soFar.moonbitArgumentCondensed
                                                                                    , argument =
                                                                                        MoonbitExpressionReference
                                                                                            { qualification = []
                                                                                            , name = unnestParameterName
                                                                                            }
                                                                                    }
                                                                            }
                                                                )
                                                                { parametersReverse = []
                                                                , moonbitArgumentCondensed = argument.moonbit
                                                                }
                                                in
                                                moonbitExpressionCallCondense
                                                    { called = condensedSoFar
                                                    , argument =
                                                        moonbitExpressionClosureReduced
                                                            { parameters =
                                                                unnested.parametersReverse |> List.reverse
                                                            , result = unnested.moonbitArgumentCondensed
                                                            }
                                                    }
                                    )
                                    called
                )
                (call.called
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "called" :: context.path
                        }
                )
                ((call.argument0 :: call.argument1Up)
                    |> List.indexedMap (\index argument -> ( index, argument ))
                    |> listMapAndCombineOk
                        (\( argumentIndex, inferredArgument ) ->
                            inferredArgument
                                |> expression
                                    { moduleInfo = context.moduleInfo
                                    , localElmBindingsInScope =
                                        context.localElmBindingsInScope
                                    , functionDeclaredMoonbitParameterEquivalentBindings =
                                        context.functionDeclaredMoonbitParameterEquivalentBindings
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                    , moonbitConsts = context.moonbitConsts
                                    , path =
                                        ("argument" ++ (argumentIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            case infixOperation.operator.symbol of
                "|>" ->
                    Result.map2
                        (\argument called ->
                            moonbitExpressionCallCondense
                                { called = called
                                , argument = argument
                                }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                , moonbitConsts = context.moonbitConsts
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                , moonbitConsts = context.moonbitConsts
                                , path = "right" :: context.path
                                }
                        )

                "<|" ->
                    Result.map2
                        (\called argument ->
                            moonbitExpressionCallCondense
                                { called = called
                                , argument = argument
                                }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                , moonbitConsts = context.moonbitConsts
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                , moonbitConsts = context.moonbitConsts
                                , path = "right" :: context.path
                                }
                        )

                "++" ->
                    Result.map2
                        (\left right ->
                            if infixOperation.left.type_ == inferredTypeString then
                                if left |> moonbitExpressionIsEmptyStringString then
                                    right

                                else if right |> moonbitExpressionIsEmptyStringString then
                                    left

                                else
                                    MoonbitExpressionCall
                                        { called =
                                            MoonbitExpressionReference
                                                { qualification = []
                                                , name = "string_append"
                                                }
                                        , arguments =
                                            [ left
                                            , right
                                            ]
                                        }

                            else
                                MoonbitExpressionCall
                                    { called =
                                        MoonbitExpressionReference
                                            { qualification = []
                                            , name = "list_append"
                                            }
                                    , arguments =
                                        [ left
                                        , right
                                        ]
                                    }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                , moonbitConsts = context.moonbitConsts
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                , moonbitConsts = context.moonbitConsts
                                , path = "right" :: context.path
                                }
                        )

                "==" ->
                    Result.map2
                        (\left right ->
                            -- small "optimization": if one side is a literal in elm,
                            -- use string_equals_str instead of wrapping in StringString::One
                            case left |> moonbitExpressionStringStringOneToLiteral of
                                Just leftStringLiteral ->
                                    MoonbitExpressionCall
                                        { called = moonbitExpressionReferenceStringEqualsStr
                                        , arguments = [ right, leftStringLiteral ]
                                        }

                                Nothing ->
                                    case right |> moonbitExpressionStringStringOneToLiteral of
                                        Just rightStringLiteral ->
                                            MoonbitExpressionCall
                                                { called = moonbitExpressionReferenceStringEqualsStr
                                                , arguments = [ left, rightStringLiteral ]
                                                }

                                        Nothing ->
                                            MoonbitExpressionCall
                                                { called = moonbitExpressionReferenceBasicsEq
                                                , arguments = [ left, right ]
                                                }
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                , moonbitConsts = context.moonbitConsts
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                , moonbitConsts = context.moonbitConsts
                                , path = "right" :: context.path
                                }
                        )

                _ ->
                    Result.map3
                        (\operationFunctionReference left right ->
                            MoonbitExpressionCall
                                { called =
                                    MoonbitExpressionReference
                                        { qualification = operationFunctionReference.qualification
                                        , name = operationFunctionReference.name
                                        }
                                , arguments =
                                    [ left
                                    , right
                                    ]
                                }
                        )
                        (expressionOperatorToMoonbitFunctionReference
                            infixOperation.operator
                        )
                        (infixOperation.left
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                , moonbitConsts = context.moonbitConsts
                                , path = "left" :: context.path
                                }
                        )
                        (infixOperation.right
                            |> expression
                                { moduleInfo = context.moduleInfo
                                , localElmBindingsInScope =
                                    context.localElmBindingsInScope
                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                , letDeclaredValueAndFunctionTypes =
                                    context.letDeclaredValueAndFunctionTypes
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                , moonbitConsts = context.moonbitConsts
                                , path = "right" :: context.path
                                }
                        )

        ElmSyntaxTypeInfer.ExpressionReferenceVariant reference ->
            let
                asMoonbitVariant :
                    { originTypeName : List String
                    , name : String
                    , referencedValueIndexes : List Int
                    }
                asMoonbitVariant =
                    case
                        { moduleOrigin = reference.moduleOrigin
                        , name = reference.name
                        , type_ = expressionTypedNode.type_
                        }
                            |> variantToCoreMoonbit
                    of
                        Just moonbitCoreReference ->
                            moonbitCoreReference

                        Nothing ->
                            let
                                originTypeMoonbitName : String
                                originTypeMoonbitName =
                                    { moduleOrigin = reference.moduleOrigin
                                    , name = reference.choiceTypeName
                                    }
                                        |> elmReferenceToPascalCaseMoonbitName
                            in
                            { name = reference.name |> toPascalCaseMoonbitName
                            , originTypeName = [ originTypeMoonbitName ]
                            , referencedValueIndexes =
                                case context.moonbitEnumTypes |> FastDict.get originTypeMoonbitName of
                                    Nothing ->
                                        -- error
                                        []

                                    Just originMoonbitEnumType ->
                                        originMoonbitEnumType.variantReferencedValueIndexes
                                            |> FastDict.get (reference.name |> toPascalCaseMoonbitName)
                                            |> Maybe.withDefault []
                            }

                moonbitExpressionVariantValue : MoonbitExpression
                moonbitExpressionVariantValue =
                    MoonbitExpressionReferenceVariant
                        { originTypeName = asMoonbitVariant.originTypeName
                        , name = asMoonbitVariant.name
                        }

                variantReferenceTypeExpandedAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                variantReferenceTypeExpandedAsFunction =
                    expressionTypedNode.type_
                        |> inferredTypeExpandFunction
            in
            Ok
                (case variantReferenceTypeExpandedAsFunction.inputs of
                    [] ->
                        moonbitExpressionVariantValue

                    valueType0 :: valueType1Up ->
                        let
                            typeAliasesInModule :
                                String
                                ->
                                    Maybe
                                        (FastDict.Dict
                                            String
                                            { parameters : List String
                                            , recordFieldOrder : Maybe (List String)
                                            , type_ : ElmSyntaxTypeInfer.Type
                                            }
                                        )
                            typeAliasesInModule moduleNameToAccess =
                                context.moduleInfo
                                    |> FastDict.get moduleNameToAccess
                                    |> Maybe.map .typeAliases
                        in
                        (valueType0 :: valueType1Up)
                            |> List.indexedMap
                                (\valueIndex valueType ->
                                    { name = generatedParameterNameForIndexAtPath valueIndex context.path
                                    , type_ =
                                        valueType
                                            |> type_
                                                { typeAliasesInModule = typeAliasesInModule
                                                , moonbitEnumTypes = context.moonbitEnumTypes
                                                }
                                    }
                                )
                            |> List.foldr
                                (\parameter resultSoFar ->
                                    { expression =
                                        moonbitExpressionClosureReduced
                                            { parameters =
                                                [ { binding = Just parameter.name
                                                  , type_ = parameter.type_ |> Just
                                                  }
                                                ]
                                            , result = resultSoFar.expression
                                            }
                                    , type_ =
                                        MoonbitTypeFunction
                                            { input = [ parameter.type_ ]
                                            , output = resultSoFar.type_
                                            }
                                    }
                                )
                                { type_ =
                                    variantReferenceTypeExpandedAsFunction.output
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , moonbitEnumTypes = context.moonbitEnumTypes
                                            }
                                , expression =
                                    MoonbitExpressionCall
                                        { called = moonbitExpressionVariantValue
                                        , arguments =
                                            (valueType0 :: valueType1Up)
                                                |> List.indexedMap
                                                    (\valueIndex _ ->
                                                        MoonbitExpressionReference
                                                            { qualification = []
                                                            , name = generatedParameterNameForIndexAtPath valueIndex context.path
                                                            }
                                                    )
                                        }
                                }
                            |> .expression
                )

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction reference ->
            case
                context.moduleInfo
                    |> FastDict.get reference.moduleOrigin
                    |> Maybe.andThen
                        (\byName ->
                            byName.typeAliases
                                |> FastDict.get reference.name
                        )
                    |> Maybe.andThen .recordFieldOrder
            of
                Just fieldOrder ->
                    let
                        inferredTypeFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                        inferredTypeFunction =
                            inferredTypeExpandToFunction
                                expressionTypedNode.type_

                        resultRecordFields : FastDict.Dict String MoonbitExpression
                        resultRecordFields =
                            fieldOrder
                                |> List.foldl
                                    (\fieldName soFar ->
                                        let
                                            moonbitFieldName : String
                                            moonbitFieldName =
                                                fieldName |> toSnakeCaseMoonbitName
                                        in
                                        soFar
                                            |> FastDict.insert
                                                moonbitFieldName
                                                (MoonbitExpressionReference
                                                    { qualification = []
                                                    , name = generatedFieldValueParameterName moonbitFieldName
                                                    }
                                                )
                                    )
                                    FastDict.empty

                        typeAliasesInModule :
                            String
                            ->
                                Maybe
                                    (FastDict.Dict
                                        String
                                        { parameters : List String
                                        , recordFieldOrder : Maybe (List String)
                                        , type_ : ElmSyntaxTypeInfer.Type
                                        }
                                    )
                        typeAliasesInModule moduleNameToAccess =
                            context.moduleInfo
                                |> FastDict.get moduleNameToAccess
                                |> Maybe.map .typeAliases
                    in
                    Ok
                        (List.map2
                            (\fieldName fieldType ->
                                { name = generatedFieldValueParameterName fieldName
                                , type_ = fieldType
                                }
                            )
                            fieldOrder
                            inferredTypeFunction.inputs
                            |> List.foldr
                                (\parameter resultSoFar ->
                                    let
                                        parameterType : MoonbitType
                                        parameterType =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                                    }
                                    in
                                    { expression =
                                        moonbitExpressionClosureReduced
                                            { parameters =
                                                [ { binding = Just parameter.name
                                                  , type_ = Just parameterType
                                                  }
                                                ]
                                            , result = resultSoFar.expression
                                            }
                                    , type_ =
                                        MoonbitTypeFunction
                                            { input = [ parameterType ]
                                            , output = resultSoFar.type_
                                            }
                                    }
                                )
                                { type_ =
                                    inferredTypeFunction.output
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , moonbitEnumTypes = context.moonbitEnumTypes
                                            }
                                , expression =
                                    MoonbitExpressionStruct
                                        { name =
                                            generatedRecordStructTypeName
                                                (fieldOrder |> List.sort)
                                        , fields = resultRecordFields
                                        }
                                }
                            |> .expression
                        )

                Nothing ->
                    Err
                        ("could not find declaration for the record type alias constructor "
                            ++ inferredReferenceToInfoString reference
                        )

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            let
                isVariableFromWithinDeclaration : Bool
                isVariableFromWithinDeclaration =
                    case reference.moduleOrigin of
                        "" ->
                            context.localElmBindingsInScope
                                |> FastDict.member reference.name

                        _ ->
                            False
            in
            Ok
                (if isVariableFromWithinDeclaration then
                    let
                        moonbitName : String
                        moonbitName =
                            reference.name |> toSnakeCaseMoonbitName

                        moonbitExpressionReference : MoonbitExpression
                        moonbitExpressionReference =
                            MoonbitExpressionReference
                                { qualification = []
                                , name = moonbitName
                                }
                    in
                    case
                        context.letDeclaredValueAndFunctionTypes
                            |> FastDict.get reference.name
                    of
                        Nothing ->
                            -- variable from pattern
                            if
                                context.functionDeclaredMoonbitParameterEquivalentBindings
                                    |> FastSet.member moonbitName
                            then
                                let
                                    inferredReferenceTypeAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                                    inferredReferenceTypeAsFunction =
                                        expressionTypedNode.type_
                                            |> inferredTypeExpandFunction
                                in
                                case inferredReferenceTypeAsFunction.inputs of
                                    [ _ ] ->
                                        moonbitExpressionReference

                                    [] ->
                                        moonbitExpressionReference

                                    _ :: _ :: _ ->
                                        let
                                            typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                            typeAliasesInModule moduleNameToAccess =
                                                context.moduleInfo
                                                    |> FastDict.get moduleNameToAccess
                                                    |> Maybe.map .typeAliases

                                            moonbitParameters : List { name : String, type_ : MoonbitType }
                                            moonbitParameters =
                                                inferredReferenceTypeAsFunction.inputs
                                                    |> List.indexedMap
                                                        (\parameterIndex parameterInferredType ->
                                                            { name = generatedParameterNameForIndexAtPath parameterIndex context.path
                                                            , type_ =
                                                                parameterInferredType
                                                                    |> type_
                                                                        { typeAliasesInModule = typeAliasesInModule
                                                                        , moonbitEnumTypes = context.moonbitEnumTypes
                                                                        }
                                                            }
                                                        )
                                        in
                                        moonbitParameters
                                            |> List.foldr
                                                (\moonbitParameter soFar ->
                                                    moonbitExpressionClosureReduced
                                                        { parameters =
                                                            [ { binding =
                                                                    Just moonbitParameter.name
                                                              , type_ = Just moonbitParameter.type_
                                                              }
                                                            ]
                                                        , result = soFar
                                                        }
                                                )
                                                (MoonbitExpressionCall
                                                    { called = moonbitExpressionReference
                                                    , arguments =
                                                        moonbitParameters
                                                            |> List.map
                                                                (\moonbitParameter ->
                                                                    MoonbitExpressionReference
                                                                        { qualification = []
                                                                        , name = moonbitParameter.name
                                                                        }
                                                                )
                                                    }
                                                )

                            else
                                moonbitExpressionReference

                        Just letDeclaredValueOrFunction ->
                            case letDeclaredValueOrFunction of
                                -- value
                                Nothing ->
                                    moonbitExpressionReference

                                -- function
                                Just functionParameters ->
                                    let
                                        inferredReferenceTypeAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
                                        inferredReferenceTypeAsFunction =
                                            expressionTypedNode.type_
                                                |> inferredTypeExpandFunction

                                        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                        typeAliasesInModule moduleNameToAccess =
                                            context.moduleInfo
                                                |> FastDict.get moduleNameToAccess
                                                |> Maybe.map .typeAliases
                                    in
                                    -- number of inferredReferenceTypeAsFunction.inputs
                                    -- == number of functionParameters.parameters
                                    -- because local fns are always fully expanded
                                    inferredReferenceTypeAsFunction.inputs
                                        |> List.indexedMap
                                            (\parameterIndex inferredParameterType ->
                                                { name =
                                                    generatedParameterNameForIndexAtPath parameterIndex context.path
                                                , type_ =
                                                    inferredParameterType
                                                        |> type_
                                                            { typeAliasesInModule = typeAliasesInModule
                                                            , moonbitEnumTypes = context.moonbitEnumTypes
                                                            }
                                                }
                                            )
                                        |> List.foldr
                                            (\parameter resultSoFar ->
                                                { expression =
                                                    moonbitExpressionClosureReduced
                                                        { parameters =
                                                            [ { binding = Just parameter.name
                                                              , type_ = Just parameter.type_
                                                              }
                                                            ]
                                                        , result = resultSoFar.expression
                                                        }
                                                , type_ =
                                                    MoonbitTypeFunction
                                                        { input = [ parameter.type_ ]
                                                        , output = resultSoFar.type_
                                                        }
                                                }
                                            )
                                            { type_ =
                                                inferredReferenceTypeAsFunction.output
                                                    |> type_
                                                        { typeAliasesInModule = typeAliasesInModule
                                                        , moonbitEnumTypes = context.moonbitEnumTypes
                                                        }
                                            , expression =
                                                MoonbitExpressionCall
                                                    { called = moonbitExpressionReference
                                                    , arguments =
                                                        functionParameters.parameters
                                                            |> List.indexedMap
                                                                (\parameterIndex _ ->
                                                                    MoonbitExpressionReference
                                                                        { qualification = []
                                                                        , name =
                                                                            generatedParameterNameForIndexAtPath parameterIndex
                                                                                context.path
                                                                        }
                                                                )
                                                    }
                                            }
                                        |> .expression

                 else
                    -- is not variable from within declaration
                    case context.moduleInfo |> FastDict.get reference.moduleOrigin of
                        Nothing ->
                            -- error?
                            MoonbitExpressionReference
                                { qualification = []
                                , name =
                                    { moduleOrigin = reference.moduleOrigin
                                    , name = reference.name
                                    }
                                        |> elmReferenceToSnakeCaseMoonbitName
                                }

                        Just referenceOriginModuleInfo ->
                            if referenceOriginModuleInfo.portsOutgoing |> FastSet.member reference.name then
                                moonbitExpressionClosureReduced
                                    { parameters =
                                        [ { binding = Just "generated_data"
                                          , type_ = Just moonbitTypeJsonValue
                                          }
                                        ]
                                    , result =
                                        MoonbitExpressionCall
                                            { called =
                                                MoonbitExpressionReferenceVariant
                                                    { originTypeName = []
                                                    , name = "platform_cmd_port_outgoing"
                                                    }
                                            , arguments =
                                                [ MoonbitExpressionString reference.name
                                                , MoonbitExpressionReference
                                                    { qualification = []
                                                    , name = "generated_data"
                                                    }
                                                ]
                                            }
                                    }

                            else if referenceOriginModuleInfo.portsIncoming |> FastSet.member reference.name then
                                let
                                    onEventType : Maybe MoonbitType
                                    onEventType =
                                        case expressionTypedNode.type_ of
                                            ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction expressionTypeFunction) ->
                                                expressionTypeFunction.input
                                                    |> type_
                                                        { typeAliasesInModule =
                                                            \moduleName ->
                                                                context.moduleInfo
                                                                    |> FastDict.get moduleName
                                                                    |> Maybe.map .typeAliases
                                                        , moonbitEnumTypes = context.moonbitEnumTypes
                                                        }
                                                    |> Just

                                            _ ->
                                                -- error?
                                                Nothing
                                in
                                moonbitExpressionClosureReduced
                                    { parameters =
                                        [ { binding = Just "generated_on_event"
                                          , type_ = onEventType
                                          }
                                        ]
                                    , result =
                                        MoonbitExpressionCall
                                            { called =
                                                MoonbitExpressionReferenceVariant
                                                    { originTypeName = []
                                                    , name = "platform_sub_port_incoming"
                                                    }
                                            , arguments =
                                                [ MoonbitExpressionString reference.name
                                                , MoonbitExpressionReference
                                                    { qualification = []
                                                    , name = "generated_on_event"
                                                    }
                                                ]
                                            }
                                    }

                            else
                                -- not a port
                                let
                                    moonbitName : String
                                    moonbitName =
                                        { moduleOrigin = reference.moduleOrigin
                                        , name = reference.name
                                        }
                                            |> elmReferenceToSnakeCaseMoonbitName
                                in
                                if context.moonbitConsts |> FastSet.member moonbitName then
                                    MoonbitExpressionReference
                                        { qualification = []
                                        , name = moonbitName
                                        }

                                else
                                    case
                                        referenceOriginModuleInfo.valueAndFunctionAnnotations
                                            |> FastDict.get reference.name
                                    of
                                        Nothing ->
                                            MoonbitExpressionReference
                                                { qualification = []
                                                , name = moonbitName
                                                }

                                        Just originDeclarationType ->
                                            let
                                                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                                                typeAliasesInModule moduleNameToAccess =
                                                    context.moduleInfo
                                                        |> FastDict.get moduleNameToAccess
                                                        |> Maybe.map .typeAliases

                                                originDeclarationTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
                                                originDeclarationTypeWithExpandedAliases =
                                                    originDeclarationType
                                                        |> inferredTypeExpandInnerAliases
                                                            typeAliasesInModule
                                            in
                                            case
                                                { moduleOrigin = reference.moduleOrigin
                                                , name = reference.name
                                                , type_ = expressionTypedNode.type_
                                                }
                                                    |> referenceToCoreMoonbit
                                            of
                                                Just coreMoonbitReference ->
                                                    moonbitExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary context
                                                        { qualification = coreMoonbitReference.qualification
                                                        , name = coreMoonbitReference.name
                                                        , inferredType = expressionTypedNode.type_
                                                        , originDeclarationTypeWithExpandedAliases =
                                                            originDeclarationTypeWithExpandedAliases
                                                        }

                                                Nothing ->
                                                    let
                                                        specializedMoonbitName : String
                                                        specializedMoonbitName =
                                                            moonbitName
                                                                |> moonbitNameWithSpecializedTypes
                                                                    (inferredTypeSpecializedVariablesFrom
                                                                        originDeclarationTypeWithExpandedAliases
                                                                        (expressionTypedNode.type_
                                                                            |> inferredTypeExpandInnerAliases
                                                                                typeAliasesInModule
                                                                        )
                                                                    )
                                                    in
                                                    if context.moonbitConsts |> FastSet.member specializedMoonbitName then
                                                        MoonbitExpressionReference
                                                            { qualification = []
                                                            , name = specializedMoonbitName
                                                            }

                                                    else
                                                        moonbitExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary context
                                                            { inferredType = expressionTypedNode.type_
                                                            , originDeclarationTypeWithExpandedAliases =
                                                                originDeclarationTypeWithExpandedAliases
                                                            , qualification = []
                                                            , name = specializedMoonbitName
                                                            }
                )

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            Result.map3
                (\condition onTrue onFalse ->
                    MoonbitExpressionIfElse
                        { condition = condition
                        , onTrue = onTrue
                        , onFalse = onFalse
                        }
                )
                (ifThenElse.condition
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "condition" :: context.path
                        }
                )
                (ifThenElse.onTrue
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "on_true" :: context.path
                        }
                )
                (ifThenElse.onFalse
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "on_false" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            expression context inParens

        ElmSyntaxTypeInfer.ExpressionNegation inNegationNode ->
            Result.map
                (\moonbitInNegation ->
                    MoonbitExpressionNegateOperation
                        moonbitInNegation
                )
                (inNegationNode |> expression context)

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            Result.map
                (\record ->
                    MoonbitExpressionStructAccess
                        { struct = record
                        , field =
                            recordAccess.fieldName
                                |> String.replace "." ""
                                |> toSnakeCaseMoonbitName
                        }
                )
                (recordAccess.record |> expression context)

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            Result.map2
                (\part0 part1 ->
                    MoonbitExpressionTuple
                        { part0 = part0
                        , part1 = part1
                        , part2Up = []
                        }
                )
                (parts.part0
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "part0" :: context.path
                        }
                )
                (parts.part1
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "part1" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            Result.map3
                (\part0 part1 part2 ->
                    MoonbitExpressionTuple
                        { part0 = part0
                        , part1 = part1
                        , part2Up = [ part2 ]
                        }
                )
                (parts.part0
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "part0" :: context.path
                        }
                )
                (parts.part1
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "part1" :: context.path
                        }
                )
                (parts.part2
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "part2" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionList elementNodes ->
            Result.map
                (\elements ->
                    case elements of
                        [] ->
                            MoonbitExpressionCall
                                { called = moonbitExpressionReferenceListEmpty
                                , arguments = []
                                }

                        element0 :: element1Up ->
                            MoonbitExpressionCall
                                { called =
                                    MoonbitExpressionReference
                                        { qualification = [ "list" ], name = "of" }
                                , arguments =
                                    [ MoonbitExpressionArrayLiteral
                                        (element0 :: element1Up)
                                    ]
                                }
                )
                (elementNodes
                    |> List.indexedMap Tuple.pair
                    |> listMapAndCombineOk
                        (\( elementIndex, element ) ->
                            element
                                |> expression
                                    { moduleInfo = context.moduleInfo
                                    , localElmBindingsInScope =
                                        context.localElmBindingsInScope
                                    , functionDeclaredMoonbitParameterEquivalentBindings =
                                        context.functionDeclaredMoonbitParameterEquivalentBindings
                                    , letDeclaredValueAndFunctionTypes =
                                        context.letDeclaredValueAndFunctionTypes
                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                    , moonbitConsts = context.moonbitConsts
                                    , path = (elementIndex |> String.fromInt) :: context.path
                                    }
                        )
                )

        ElmSyntaxTypeInfer.ExpressionRecord fieldNodes ->
            Result.map
                (\fields ->
                    MoonbitExpressionStruct
                        { name =
                            generatedRecordStructTypeName
                                (fieldNodes
                                    |> List.map .name
                                    |> List.sort
                                )
                        , fields = fields |> FastDict.fromList
                        }
                )
                (fieldNodes
                    |> listMapAndCombineOk
                        (\field ->
                            Result.map
                                (\fieldValue ->
                                    ( field.name |> toSnakeCaseMoonbitName
                                    , fieldValue
                                    )
                                )
                                (field.value
                                    |> expression
                                        { moduleInfo = context.moduleInfo
                                        , localElmBindingsInScope =
                                            context.localElmBindingsInScope
                                        , functionDeclaredMoonbitParameterEquivalentBindings =
                                            context.functionDeclaredMoonbitParameterEquivalentBindings
                                        , letDeclaredValueAndFunctionTypes =
                                            context.letDeclaredValueAndFunctionTypes
                                        , moonbitEnumTypes = context.moonbitEnumTypes
                                        , moonbitConsts = context.moonbitConsts
                                        , path =
                                            (field.name |> toSnakeCaseMoonbitName)
                                                :: context.path
                                        }
                                )
                        )
                )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            case expressionTypedNode.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord allFields) ->
                    Result.map
                        (\fieldsToSet ->
                            let
                                originalRecordVariable : String
                                originalRecordVariable =
                                    { moduleOrigin =
                                        recordUpdate.recordVariable.value.moduleOrigin
                                    , name =
                                        recordUpdate.recordVariable.value.name
                                    }
                                        |> elmReferenceToSnakeCaseMoonbitName

                                moonbitOriginalStructVariableReferenceExpression : MoonbitExpression
                                moonbitOriginalStructVariableReferenceExpression =
                                    MoonbitExpressionReference
                                        { qualification = [], name = originalRecordVariable }

                                fieldsToSetDict : FastDict.Dict String MoonbitExpression
                                fieldsToSetDict =
                                    fieldsToSet
                                        |> List.foldl
                                            (\( fieldName, valueToSet ) soFar ->
                                                soFar |> FastDict.insert fieldName valueToSet
                                            )
                                            FastDict.empty
                            in
                            MoonbitExpressionStruct
                                { name =
                                    generatedRecordStructTypeName
                                        (allFields |> FastDict.keys)
                                , fields =
                                    allFields
                                        |> FastDict.foldl
                                            (\fieldName _ soFar ->
                                                let
                                                    moonbitFieldName : String
                                                    moonbitFieldName =
                                                        fieldName |> toSnakeCaseMoonbitName
                                                in
                                                soFar
                                                    |> FastDict.insert moonbitFieldName
                                                        (case fieldsToSetDict |> FastDict.get fieldName of
                                                            Just valueToSet ->
                                                                valueToSet

                                                            Nothing ->
                                                                MoonbitExpressionStructAccess
                                                                    { struct = moonbitOriginalStructVariableReferenceExpression
                                                                    , field = moonbitFieldName
                                                                    }
                                                        )
                                            )
                                            FastDict.empty
                                }
                        )
                        ((recordUpdate.field0 :: recordUpdate.field1Up)
                            |> listMapAndCombineOk
                                (\field ->
                                    Result.map
                                        (\fieldValue ->
                                            ( field.name, fieldValue )
                                        )
                                        (field.value
                                            |> expression
                                                { moduleInfo = context.moduleInfo
                                                , localElmBindingsInScope =
                                                    context.localElmBindingsInScope
                                                , functionDeclaredMoonbitParameterEquivalentBindings =
                                                    context.functionDeclaredMoonbitParameterEquivalentBindings
                                                , letDeclaredValueAndFunctionTypes =
                                                    context.letDeclaredValueAndFunctionTypes
                                                , moonbitEnumTypes = context.moonbitEnumTypes
                                                , moonbitConsts = context.moonbitConsts
                                                , path =
                                                    (field.name |> toSnakeCaseMoonbitName)
                                                        :: context.path
                                                }
                                        )
                                )
                        )

                _ ->
                    Err
                        ("("
                            ++ (expressionTypedNode.range |> rangeToInfoString)
                            ++ ") I tried to transpile an elm record update but the inferred type is not a record so I am unable to construct a new record. This likely means you are using extensible records in a variant or let declaration"
                        )

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            let
                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                typeAliasesInModule moduleNameToAccess =
                    context.moduleInfo
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases
            in
            Result.map
                (\result ->
                    let
                        moonbitParameters :
                            List
                                { type_ : MoonbitType
                                , pattern : MoonbitPattern
                                }
                        moonbitParameters =
                            (lambda.parameter0 :: lambda.parameter1Up)
                                |> List.map
                                    (\parameter ->
                                        let
                                            moonbitParameter :
                                                { pattern : MoonbitPattern
                                                , guardConditions : List MoonbitExpression
                                                }
                                            moonbitParameter =
                                                parameter
                                                    |> pattern
                                                        { typeAliasesInModule = typeAliasesInModule
                                                        , moonbitEnumTypes = context.moonbitEnumTypes
                                                        }
                                        in
                                        { type_ =
                                            parameter.type_
                                                |> type_
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                                    }
                                        , pattern = moonbitParameter.pattern
                                        }
                                    )
                    in
                    moonbitParameters
                        |> List.indexedMap Tuple.pair
                        |> List.foldr
                            (\( parameterIndex, parameter ) resultSoFar ->
                                { expression =
                                    moonbitExpressionClosureReduced
                                        { parameters =
                                            [ { binding =
                                                    case parameter.pattern of
                                                        MoonbitPatternVariable parameterVariable ->
                                                            Just parameterVariable.name

                                                        MoonbitPatternIgnore ->
                                                            Nothing

                                                        _ ->
                                                            Just (generatedParameterNameForIndex parameterIndex)
                                              , type_ = Just parameter.type_
                                              }
                                            ]
                                        , result = resultSoFar.expression
                                        }
                                , type_ =
                                    MoonbitTypeFunction
                                        { input = [ parameter.type_ ]
                                        , output = resultSoFar.type_
                                        }
                                }
                            )
                            { expression =
                                result
                                    |> moonbitExpressionPrependStatements
                                        (moonbitParameters
                                            |> List.indexedMap Tuple.pair
                                            |> List.filterMap
                                                (\( parameterIndex, parameter ) ->
                                                    case parameter.pattern of
                                                        MoonbitPatternVariable _ ->
                                                            Nothing

                                                        MoonbitPatternIgnore ->
                                                            Nothing

                                                        parameterPatternThatNeedsToBeDestructured ->
                                                            Just
                                                                (MoonbitStatementLetDestructuring
                                                                    { pattern = parameterPatternThatNeedsToBeDestructured
                                                                    , expression =
                                                                        MoonbitExpressionReference
                                                                            { qualification = []
                                                                            , name = generatedParameterNameForIndex parameterIndex
                                                                            }
                                                                    }
                                                                )
                                                )
                                        )
                            , type_ =
                                lambda.result.type_
                                    |> type_
                                        { typeAliasesInModule = typeAliasesInModule
                                        , moonbitEnumTypes = context.moonbitEnumTypes
                                        }
                            }
                        |> .expression
                )
                (lambda.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                                |> FastDict.union
                                    ((lambda.parameter0 :: lambda.parameter1Up)
                                        |> listMapToFastDictsAndUnify
                                            patternTypedNodeIntroducedVariables
                                    )
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "result" :: context.path
                        }
                )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            let
                typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
                typeAliasesInModule moduleNameToAccess =
                    context.moduleInfo
                        |> FastDict.get moduleNameToAccess
                        |> Maybe.map .typeAliases
            in
            Result.map2
                (\matched cases ->
                    MoonbitExpressionMatch
                        { matched = matched
                        , cases = cases
                        }
                )
                (caseOf.matched
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "matched" :: context.path
                        }
                )
                ((caseOf.case0 :: caseOf.case1Up)
                    |> List.indexedMap
                        (\caseIndex syntaxCase ->
                            ( caseIndex, syntaxCase )
                        )
                    |> listMapAndCombineOk
                        (\( caseIndex, syntaxCase ) ->
                            Result.map
                                (\result ->
                                    let
                                        moonbitPattern :
                                            { pattern : MoonbitPattern
                                            , guardConditions : List MoonbitExpression
                                            }
                                        moonbitPattern =
                                            syntaxCase.pattern
                                                |> pattern
                                                    { typeAliasesInModule = typeAliasesInModule
                                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                                    }
                                    in
                                    { pattern = moonbitPattern.pattern
                                    , guardConditions = moonbitPattern.guardConditions
                                    , result = result
                                    }
                                )
                                (syntaxCase.result
                                    |> expression
                                        { moduleInfo = context.moduleInfo
                                        , localElmBindingsInScope =
                                            context.localElmBindingsInScope
                                                |> FastDict.union
                                                    (syntaxCase.pattern |> patternTypedNodeIntroducedVariables)
                                        , functionDeclaredMoonbitParameterEquivalentBindings =
                                            context.functionDeclaredMoonbitParameterEquivalentBindings
                                        , letDeclaredValueAndFunctionTypes =
                                            context.letDeclaredValueAndFunctionTypes
                                        , moonbitEnumTypes = context.moonbitEnumTypes
                                        , moonbitConsts = context.moonbitConsts
                                        , path =
                                            -- intentional as there is only one sub-expression
                                            ("case" ++ (caseIndex |> String.fromInt))
                                                :: context.path
                                        }
                                )
                        )
                )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            let
                letIntroducedBindings : FastDict.Dict String ElmSyntaxTypeInfer.Type
                letIntroducedBindings =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> listMapToFastDictsAndUnify
                            (\syntaxLetDeclarationAndRange ->
                                case syntaxLetDeclarationAndRange.declaration of
                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration syntaxLetValueOrFunction ->
                                        FastDict.singleton syntaxLetValueOrFunction.name
                                            syntaxLetValueOrFunction.type_

                                    ElmSyntaxTypeInfer.LetDestructuring syntaxLetDestructuring ->
                                        syntaxLetDestructuring.pattern
                                            |> patternTypedNodeIntroducedVariables
                            )

                letDeclarationsSortedFromMostToLeastDependedOn : List { declaration : ElmSyntaxTypeInfer.LetDeclaration, range : Elm.Syntax.Range.Range }
                letDeclarationsSortedFromMostToLeastDependedOn =
                    (letIn.declaration0 :: letIn.declaration1Up)
                        |> inferredLetDeclarationNodesSortFromMostToLeastDependedOn

                letDeclaredValueAndFunctionTypesIncludingFromContext :
                    FastDict.Dict
                        String
                        (Maybe
                            -- Nothing means value, Just means function
                            { parameters : List ElmSyntaxTypeInfer.Type
                            }
                        )
                letDeclaredValueAndFunctionTypesIncludingFromContext =
                    letDeclarationsSortedFromMostToLeastDependedOn
                        |> List.foldl
                            (\declarationNode letDeclaredValueAndFunctionTypesIncludingFromContextSoFar ->
                                case declarationNode.declaration of
                                    ElmSyntaxTypeInfer.LetDestructuring _ ->
                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar

                                    ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunction ->
                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar
                                            |> FastDict.insert
                                                inferredLetValueOrFunction.name
                                                (letValueOrFunctionDeclarationToMoonbitKindAndParameters
                                                    { moduleInfo = context.moduleInfo
                                                    , localElmBindingsInScope =
                                                        context.localElmBindingsInScope
                                                            |> FastDict.union
                                                                letIntroducedBindings
                                                    , letDeclaredValueAndFunctionTypes =
                                                        letDeclaredValueAndFunctionTypesIncludingFromContextSoFar
                                                    }
                                                    { range = declarationNode.range
                                                    , declaration = inferredLetValueOrFunction
                                                    }
                                                )
                            )
                            context.letDeclaredValueAndFunctionTypes
            in
            Result.map2
                (\declarations result ->
                    moonbitExpressionPrependStatements
                        (declarations |> List.concat)
                        result
                )
                (letDeclarationsSortedFromMostToLeastDependedOn
                    |> List.indexedMap
                        (\letDeclarationIndex laterDeclaration ->
                            ( letDeclarationIndex, laterDeclaration )
                        )
                    |> listMapAndCombineOk
                        (\( letDeclarationIndex, letDeclarationNode ) ->
                            letDeclarationNode
                                |> letDeclaration
                                    { moduleInfo = context.moduleInfo
                                    , localElmBindingsInScope =
                                        context.localElmBindingsInScope
                                            |> FastDict.union letIntroducedBindings
                                    , functionDeclaredMoonbitParameterEquivalentBindings =
                                        context.functionDeclaredMoonbitParameterEquivalentBindings
                                    , letDeclaredValueAndFunctionTypes =
                                        letDeclaredValueAndFunctionTypesIncludingFromContext
                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                    , moonbitConsts = context.moonbitConsts
                                    , path =
                                        ("let_declaration" ++ (letDeclarationIndex |> String.fromInt))
                                            :: context.path
                                    }
                        )
                )
                (letIn.result
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                                |> FastDict.union letIntroducedBindings
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            letDeclaredValueAndFunctionTypesIncludingFromContext
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path = "let_result" :: context.path
                        }
                )


moonbitExpressionReferenceVariantStringStringOne : MoonbitExpression
moonbitExpressionReferenceVariantStringStringOne =
    MoonbitExpressionReferenceVariant
        { originTypeName = [ "StringString" ]
        , name = "One"
        }


moonbitTypeJsonValue : MoonbitType
moonbitTypeJsonValue =
    MoonbitTypeConstruct
        { qualification = []
        , isShow = True
        , isEq = True
        , name = "JsonValue"
        , arguments = []
        }


moonbitExpressionPrependStatements :
    List MoonbitStatement
    -> MoonbitExpression
    -> MoonbitExpression
moonbitExpressionPrependStatements statements result =
    statements
        |> List.foldr
            (\statement resultSoFar ->
                MoonbitExpressionAfterStatement { statement = statement, result = resultSoFar }
            )
            result


moonbitExpressionReferenceListEmpty : MoonbitExpression
moonbitExpressionReferenceListEmpty =
    MoonbitExpressionReference
        { qualification = [ "list" ]
        , name = "empty"
        }


moonbitExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary :
    ExpressionToMoonbitContext
    ->
        { qualification : List String
        , name : String
        , inferredType : ElmSyntaxTypeInfer.Type
        , originDeclarationTypeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        }
    -> MoonbitExpression
moonbitExpressionReferenceDeclaredFnAppliedLazilyOrCurriedIfNecessary context moonbitReference =
    let
        parameterCount : Int
        parameterCount =
            moonbitReference.originDeclarationTypeWithExpandedAliases
                |> inferredTypeExpandFunction
                |> .inputs
                |> List.length

        inferredTypeExpandedAsFunction : { inputs : List ElmSyntaxTypeInfer.Type, output : ElmSyntaxTypeInfer.Type }
        inferredTypeExpandedAsFunction =
            moonbitReference.inferredType
                |> inferredTypeExpandInnerAliases typeAliasesInModule
                |> inferredTypeExpandFunction

        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases
    in
    if parameterCount == 0 then
        let
            resultMoonbitType : MoonbitType
            resultMoonbitType =
                inferredTypeExpandedAsFunction.output
                    |> type_
                        { typeAliasesInModule = typeAliasesInModule
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        }
        in
        if resultMoonbitType |> moonbitTypeIsConcrete then
            MoonbitExpressionReference
                { qualification = moonbitReference.qualification
                , name = moonbitReference.name
                }

        else
            MoonbitExpressionCall
                { called =
                    MoonbitExpressionReference
                        { qualification = moonbitReference.qualification
                        , name = moonbitReference.name
                        }
                , arguments = []
                }

    else
        inferredTypeExpandedAsFunction.inputs
            |> List.take parameterCount
            |> List.indexedMap Tuple.pair
            |> List.foldr
                (\( parameterIndex, parameterInferredType ) resultSoFar ->
                    let
                        parameterType : MoonbitType
                        parameterType =
                            parameterInferredType
                                |> type_
                                    { typeAliasesInModule = typeAliasesInModule
                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                    }
                    in
                    moonbitExpressionClosureReduced
                        { parameters =
                            [ { binding =
                                    Just
                                        (generatedParameterNameForIndexAtPath
                                            parameterIndex
                                            context.path
                                        )
                              , type_ = Just parameterType
                              }
                            ]
                        , result = resultSoFar
                        }
                )
                (MoonbitExpressionCall
                    { called =
                        MoonbitExpressionReference
                            { qualification = moonbitReference.qualification
                            , name = moonbitReference.name
                            }
                    , arguments =
                        List.range 0 (parameterCount - 1)
                            |> List.map
                                (\parameterIndex ->
                                    MoonbitExpressionReference
                                        { qualification = []
                                        , name =
                                            generatedParameterNameForIndexAtPath
                                                parameterIndex
                                                context.path
                                        }
                                )
                    }
                )


generatedParameterNameForIndexAtPath : Int -> List String -> String
generatedParameterNameForIndexAtPath index path =
    "generated_"
        ++ (path |> String.join "_")
        ++ "_"
        ++ (index |> String.fromInt)


rangeToInfoString : Elm.Syntax.Range.Range -> String
rangeToInfoString range =
    (range.start |> locationToInfoString)
        ++ "-"
        ++ (range.end |> locationToInfoString)


locationToInfoString : Elm.Syntax.Range.Location -> String
locationToInfoString location =
    (location.row |> String.fromInt)
        ++ ":"
        ++ (location.column |> String.fromInt)


inferredLetDeclarationNodesSortFromMostToLeastDependedOn :
    List
        { declaration : ElmSyntaxTypeInfer.LetDeclaration
        , range : Elm.Syntax.Range.Range
        }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationNodesSortFromMostToLeastDependedOn inferredLetDeclarationNodes =
    let
        letValueOrFunctionDeclarations :
            List
                { range : Elm.Syntax.Range.Range
                , declaration :
                    { name : String
                    , nameRange : Elm.Syntax.Range.Range
                    , signature :
                        Maybe
                            { range : Elm.Syntax.Range.Range
                            , nameRange : Elm.Syntax.Range.Range
                            , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                            , annotationTypeRange : Elm.Syntax.Range.Range
                            }
                    , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
                    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
                }
        letValueOrFunctionDeclarations =
            inferredLetDeclarationNodes
                |> List.filterMap
                    (\inferredLetDeclarationNode ->
                        case inferredLetDeclarationNode.declaration of
                            ElmSyntaxTypeInfer.LetDestructuring _ ->
                                Nothing

                            ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
                                Just
                                    { range = inferredLetDeclarationNode.range
                                    , declaration = inferredLetValueOrFunctionDeclaration
                                    }
                    )

        letDestructurings :
            List
                { range : Elm.Syntax.Range.Range
                , declaration :
                    { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
                    , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
                    }
                }
        letDestructurings =
            inferredLetDeclarationNodes
                |> List.filterMap
                    (\inferredLetDeclarationNode ->
                        case inferredLetDeclarationNode.declaration of
                            ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration _ ->
                                Nothing

                            ElmSyntaxTypeInfer.LetDestructuring inferredLetDestructuring ->
                                Just
                                    { range = inferredLetDeclarationNode.range
                                    , declaration = inferredLetDestructuring
                                    }
                    )
    in
    letValueOrFunctionDeclarations
        |> List.map
            (\inferredLetValueOrFunctionDeclarationNode ->
                ( { range = inferredLetValueOrFunctionDeclarationNode.range
                  , declaration =
                        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration
                            inferredLetValueOrFunctionDeclarationNode.declaration
                  }
                , inferredLetValueOrFunctionDeclarationNode.declaration.name
                , inferredLetValueOrFunctionDeclarationNode.declaration.result.value
                    |> inferredExpressionUsedLocalReferences
                    |> FastSet.toList
                )
            )
        |> Graph.stronglyConnComponents
        |> List.concatMap
            (\bucket ->
                case bucket of
                    Graph.AcyclicSCC node ->
                        [ node ]

                    Graph.CyclicSCC nodes ->
                        nodes
            )
        |> inferredLetDeclarationsInsertLetDestructurings
            letDestructurings


inferredExpressionTypedNodeUsedLocalReferences :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> FastSet.Set String
inferredExpressionTypedNodeUsedLocalReferences inferredExpressionTypedNode =
    inferredExpressionUsedLocalReferences inferredExpressionTypedNode.value


inferredExpressionUsedLocalReferences : ElmSyntaxTypeInfer.Expression -> FastSet.Set String
inferredExpressionUsedLocalReferences inferredExpression =
    -- IGNORE TCO
    case inferredExpression of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceVariant _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionInteger _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionFloat _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionOperatorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            case reference.moduleOrigin of
                "" ->
                    FastSet.singleton reference.name

                _ ->
                    FastSet.empty

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            inferredExpressionTypedNodeUsedLocalReferences inParens

        ElmSyntaxTypeInfer.ExpressionNegation inNegation ->
            inferredExpressionTypedNodeUsedLocalReferences inNegation

        ElmSyntaxTypeInfer.ExpressionLambda lambda ->
            inferredExpressionTypedNodeUsedLocalReferences lambda.result

        ElmSyntaxTypeInfer.ExpressionRecordAccess recordAccess ->
            inferredExpressionTypedNodeUsedLocalReferences recordAccess.record

        ElmSyntaxTypeInfer.ExpressionInfixOperation infixOperation ->
            infixOperation.left
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (infixOperation.right
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            (parts.part0 |> inferredExpressionTypedNodeUsedLocalReferences)
                |> FastSet.union
                    (parts.part1 |> inferredExpressionTypedNodeUsedLocalReferences)

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (parts.part1 |> inferredExpressionTypedNodeUsedLocalReferences)
                |> FastSet.union
                    (parts.part2 |> inferredExpressionTypedNodeUsedLocalReferences)

        ElmSyntaxTypeInfer.ExpressionIfThenElse ifThenElse ->
            ifThenElse.condition
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (ifThenElse.onTrue
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (ifThenElse.onFalse
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionList elements ->
            elements
                |> listMapToFastSetsAndUnify
                    inferredExpressionTypedNodeUsedLocalReferences

        ElmSyntaxTypeInfer.ExpressionRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\field ->
                        field.value
                            |> inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate recordUpdate ->
            (case recordUpdate.recordVariable.value.moduleOrigin of
                "" ->
                    FastSet.empty

                _ ->
                    FastSet.singleton recordUpdate.recordVariable.value.name
            )
                |> FastSet.union
                    (recordUpdate.field0.value
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (recordUpdate.field1Up
                        |> listMapToFastSetsAndUnify
                            (\field ->
                                field.value
                                    |> inferredExpressionTypedNodeUsedLocalReferences
                            )
                    )

        ElmSyntaxTypeInfer.ExpressionCaseOf caseOf ->
            caseOf.matched
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (caseOf.case0.result
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (caseOf.case1Up
                        |> listMapToFastSetsAndUnify
                            (\laterCase ->
                                laterCase.result
                                    |> inferredExpressionTypedNodeUsedLocalReferences
                            )
                    )

        ElmSyntaxTypeInfer.ExpressionCall call ->
            call.called
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (call.argument0
                        |> inferredExpressionTypedNodeUsedLocalReferences
                    )
                |> FastSet.union
                    (call.argument1Up
                        |> listMapToFastSetsAndUnify
                            inferredExpressionTypedNodeUsedLocalReferences
                    )

        ElmSyntaxTypeInfer.ExpressionLetIn letIn ->
            letIn.result
                |> inferredExpressionTypedNodeUsedLocalReferences
                |> FastSet.union
                    (letIn.declaration0.declaration
                        |> inferredLetDeclarationUsedLocalReferences
                    )
                |> FastSet.union
                    (letIn.declaration1Up
                        |> listMapToFastSetsAndUnify
                            (\letDeclarationNode ->
                                letDeclarationNode.declaration
                                    |> inferredLetDeclarationUsedLocalReferences
                            )
                    )


inferredLetDeclarationUsedLocalReferences : ElmSyntaxTypeInfer.LetDeclaration -> FastSet.Set String
inferredLetDeclarationUsedLocalReferences inferredLetDeclaration =
    case inferredLetDeclaration of
        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
            inferredLetValueOrFunctionDeclaration.result.value
                |> inferredExpressionUsedLocalReferences

        ElmSyntaxTypeInfer.LetDestructuring inferredLetDestructuring ->
            inferredLetDestructuring.expression.value
                |> inferredExpressionUsedLocalReferences


inferredLetDeclarationsInsertLetDestructurings :
    List
        { range : Elm.Syntax.Range.Range
        , declaration :
            { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
            , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            }
        }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationsInsertLetDestructurings inferredLetDestructuringsToInsert existingLetDeclarations =
    inferredLetDestructuringsToInsert
        |> List.foldl
            (\inferredLetDestructuringToInsert soFar ->
                soFar
                    |> inferredLetDeclarationsInsertInferredLetDestructuring
                        inferredLetDestructuringToInsert
            )
            existingLetDeclarations


inferredLetDeclarationsInsertInferredLetDestructuring :
    { range : Elm.Syntax.Range.Range
    , declaration :
        { pattern : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern
        , expression : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
        }
    }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
    ->
        List
            { declaration : ElmSyntaxTypeInfer.LetDeclaration
            , range : Elm.Syntax.Range.Range
            }
inferredLetDeclarationsInsertInferredLetDestructuring inferredLetDestructuringToInsert existingLetDeclarationsMostToLeastDependedOn =
    let
        variablesIntroducedInDestructuringPattern : FastSet.Set String
        variablesIntroducedInDestructuringPattern =
            inferredLetDestructuringToInsert.declaration.pattern
                |> patternTypedNodeIntroducedVariables
                |> FastDict.foldl
                    (\variable _ soFar ->
                        soFar |> FastSet.insert variable
                    )
                    FastSet.empty

        withLetDestructuring :
            { destructuringHasBeenInserted : Bool
            , leastToMostDependedOn :
                List
                    { declaration : ElmSyntaxTypeInfer.LetDeclaration
                    , range : Elm.Syntax.Range.Range
                    }
            }
        withLetDestructuring =
            existingLetDeclarationsMostToLeastDependedOn
                |> List.foldl
                    (\existingLetDeclaration soFar ->
                        if soFar.destructuringHasBeenInserted then
                            { destructuringHasBeenInserted = True
                            , leastToMostDependedOn =
                                existingLetDeclaration
                                    :: soFar.leastToMostDependedOn
                            }

                        else
                            let
                                existingLetDeclarationUsedLocalReferences : FastSet.Set String
                                existingLetDeclarationUsedLocalReferences =
                                    existingLetDeclaration.declaration
                                        |> inferredLetDeclarationUsedLocalReferences
                            in
                            if fastSetsIntersect variablesIntroducedInDestructuringPattern existingLetDeclarationUsedLocalReferences then
                                { destructuringHasBeenInserted = True
                                , leastToMostDependedOn =
                                    existingLetDeclaration
                                        :: { declaration =
                                                ElmSyntaxTypeInfer.LetDestructuring
                                                    inferredLetDestructuringToInsert.declaration
                                           , range = inferredLetDestructuringToInsert.range
                                           }
                                        :: soFar.leastToMostDependedOn
                                }

                            else
                                { destructuringHasBeenInserted = False
                                , leastToMostDependedOn =
                                    existingLetDeclaration
                                        :: soFar.leastToMostDependedOn
                                }
                    )
                    destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty
    in
    if withLetDestructuring.destructuringHasBeenInserted then
        withLetDestructuring.leastToMostDependedOn |> List.reverse

    else
        { declaration =
            ElmSyntaxTypeInfer.LetDestructuring
                inferredLetDestructuringToInsert.declaration
        , range = inferredLetDestructuringToInsert.range
        }
            :: withLetDestructuring.leastToMostDependedOn
            |> List.reverse


destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty :
    { destructuringHasBeenInserted : Bool
    , leastToMostDependedOn : List a_
    }
destructuringHasBeenInsertedFalseLeastToMostDependedOnListEmpty =
    { destructuringHasBeenInserted = False
    , leastToMostDependedOn = []
    }


fastSetsIntersect : FastSet.Set comparable -> FastSet.Set comparable -> Bool
fastSetsIntersect aSet bSet =
    aSet
        |> fastSetAny
            (\aElement ->
                bSet |> FastSet.member aElement
            )


fastSetAny : (a -> Bool) -> FastSet.Set a -> Bool
fastSetAny isFound fastSet =
    fastSet
        |> FastSet.foldl
            (\element soFar ->
                soFar || (element |> isFound)
            )
            False


inferredTypeIsConcreteMoonbitType : ElmSyntaxTypeInfer.Type -> Bool
inferredTypeIsConcreteMoonbitType inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            -- number gets "specialized" away to Int64/Double
            String.startsWith "number" variable.name

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypNotVariable ->
            inferredTypeNotVariableIsConcreteMoonbitType inferredTypNotVariable


inferredTypeNotVariableIsConcreteMoonbitType : ElmSyntaxTypeInfer.TypeNotVariable -> Bool
inferredTypeNotVariableIsConcreteMoonbitType inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            True

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            (typeFunction.input |> inferredTypeIsConcreteMoonbitType)
                && (typeFunction.output |> inferredTypeIsConcreteMoonbitType)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            (parts.part0 |> inferredTypeIsConcreteMoonbitType)
                && (parts.part1 |> inferredTypeIsConcreteMoonbitType)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            (parts.part0 |> inferredTypeIsConcreteMoonbitType)
                && (parts.part1 |> inferredTypeIsConcreteMoonbitType)
                && (parts.part2 |> inferredTypeIsConcreteMoonbitType)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.all inferredTypeIsConcreteMoonbitType

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeIsConcreteMoonbitType
                    )

        ElmSyntaxTypeInfer.TypeRecordExtension recordExtension ->
            -- extended record variable will get specialized away
            recordExtension.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeIsConcreteMoonbitType
                    )


generatedAccessedStructVariableName : String
generatedAccessedStructVariableName =
    "generated_record"


generatedFieldValueParameterName : String -> String
generatedFieldValueParameterName fieldName =
    "generated_" ++ (fieldName |> toSnakeCase)


inferredReferenceToInfoString :
    { qualification : String, moduleOrigin : String, name : String }
    -> String
inferredReferenceToInfoString reference =
    case reference.moduleOrigin of
        "" ->
            reference.name

        moduleOriginNotEmpty ->
            moduleOriginNotEmpty
                ++ "."
                ++ reference.name


moonbitExpressionStringStringOneToLiteral : MoonbitExpression -> Maybe MoonbitExpression
moonbitExpressionStringStringOneToLiteral moonbitExpression =
    case moonbitExpression of
        MoonbitExpressionCall call ->
            case call.called of
                MoonbitExpressionReferenceVariant variant ->
                    case variant.originTypeName of
                        [ "StringString" ] ->
                            case variant.name of
                                "One" ->
                                    call.arguments |> List.head

                                _ ->
                                    Nothing

                        _ ->
                            Nothing

                _ ->
                    Nothing

        _ ->
            Nothing


moonbitExpressionIsEmptyStringString : MoonbitExpression -> Bool
moonbitExpressionIsEmptyStringString moonbitExpression =
    moonbitExpression == moonbitExpressionStringStringEmpty


moonbitExpressionStringStringEmpty : MoonbitExpression
moonbitExpressionStringStringEmpty =
    MoonbitExpressionReference
        { qualification = [], name = "string_rope_empty" }


inferredTypeExpandFunction :
    ElmSyntaxTypeInfer.Type
    ->
        { inputs : List ElmSyntaxTypeInfer.Type
        , output : ElmSyntaxTypeInfer.Type
        }
inferredTypeExpandFunction inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
            let
                outputExpanded :
                    { inputs : List ElmSyntaxTypeInfer.Type
                    , output : ElmSyntaxTypeInfer.Type
                    }
                outputExpanded =
                    typeFunction.output |> inferredTypeExpandFunction
            in
            { inputs = typeFunction.input :: outputExpanded.inputs
            , output = outputExpanded.output
            }

        typeNotFunction ->
            { inputs = [], output = typeNotFunction }


listOfFastDictsUnify :
    List (FastDict.Dict comparableKey value)
    -> FastDict.Dict comparableKey value
listOfFastDictsUnify list =
    list
        |> List.foldl
            FastDict.union
            FastDict.empty


listMapToFastDictsAndUnify :
    (element -> FastDict.Dict comparableKey value)
    -> List element
    -> FastDict.Dict comparableKey value
listMapToFastDictsAndUnify elementToFastDict list =
    list
        |> List.foldl
            (\element soFar ->
                FastDict.union soFar (element |> elementToFastDict)
            )
            FastDict.empty


listMapToFastSetsAndUnify :
    (listElement -> FastSet.Set comparableFastSetElement)
    -> List listElement
    -> FastSet.Set comparableFastSetElement
listMapToFastSetsAndUnify elementToSet list =
    list
        |> List.foldl
            (\element soFar ->
                FastSet.union
                    (element |> elementToSet)
                    soFar
            )
            FastSet.empty


moonbitExpressionCallCondense :
    { called : MoonbitExpression
    , argument : MoonbitExpression
    }
    -> MoonbitExpression
moonbitExpressionCallCondense call =
    let
        calledDereferenced : MoonbitExpression
        calledDereferenced =
            call.called
    in
    case calledDereferenced of
        MoonbitExpressionClosure calledLambda ->
            case calledLambda.parameters |> List.map .binding of
                [ Just parameterBindingName ] ->
                    if
                        (call.argument |> moonbitExpressionIsConstant)
                            || (((calledDereferenced
                                    |> moonbitExpressionCountUsesOfReference
                                        { qualification = [], name = parameterBindingName }
                                 )
                                    == 1
                                )
                                    && Basics.not
                                        (let
                                            -- this is a bit awkward. potentially
                                            -- try nested condensing call
                                            calledLambdaResultInnermostLambdaResult : { statements : List MoonbitStatement, result : MoonbitExpression }
                                            calledLambdaResultInnermostLambdaResult =
                                                calledDereferenced
                                                    |> moonbitExpressionInnermostLambdaResult
                                         in
                                         (calledLambdaResultInnermostLambdaResult.result
                                            |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration
                                                { qualification = [], name = parameterBindingName }
                                         )
                                            || (calledLambdaResultInnermostLambdaResult.statements
                                                    |> List.any
                                                        (\statement ->
                                                            statement
                                                                |> moonbitStatementUsesReferenceInLambdaOrFnDeclaration
                                                                    { qualification = [], name = parameterBindingName }
                                                        )
                                               )
                                        )
                               )
                    then
                        let
                            substituteReferences : { qualification : List String, name : String } -> MoonbitExpression
                            substituteReferences existingReference =
                                if
                                    case existingReference.qualification of
                                        _ :: _ ->
                                            False

                                        [] ->
                                            existingReference.name == parameterBindingName
                                then
                                    call.argument

                                else
                                    MoonbitExpressionReference existingReference
                        in
                        calledLambda.result
                            |> moonbitExpressionSubstituteReferences substituteReferences

                    else
                        MoonbitExpressionCall
                            { called = calledDereferenced
                            , arguments = [ call.argument ]
                            }

                _ ->
                    MoonbitExpressionCall
                        { called = calledDereferenced
                        , arguments = [ call.argument ]
                        }

        MoonbitExpressionReference reference ->
            case
                case reference.name of
                    "array_from_list" ->
                        case call.argument of
                            MoonbitExpressionCall argumentCall ->
                                case argumentCall.called of
                                    MoonbitExpressionReference argumentReference ->
                                        case argumentReference.name of
                                            -- @list.of
                                            "of" ->
                                                case argumentCall.arguments of
                                                    [ MoonbitExpressionArrayLiteral elements ] ->
                                                        Just elements

                                                    _ ->
                                                        Nothing

                                            _ ->
                                                Nothing

                                    _ ->
                                        Nothing

                            _ ->
                                Nothing

                    _ ->
                        Nothing
            of
                Just elements ->
                    MoonbitExpressionCall
                        { called =
                            MoonbitExpressionReference
                                { qualification = [ "immut", "array" ]
                                , name = "of"
                                }
                        , arguments = elements
                        }

                Nothing ->
                    MoonbitExpressionCall
                        { called = calledDereferenced
                        , arguments = [ call.argument ]
                        }

        MoonbitExpressionCall _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionAs _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionUnit ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionSelf ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionReferenceVariant _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionReferenceMethod _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionInt64 _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionDouble _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionChar _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionString _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionNegateOperation _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionStructAccess _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionBinaryOperation _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionTuple _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionIfElse _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionArrayLiteral _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionStruct _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionMatch _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }

        MoonbitExpressionAfterStatement _ ->
            MoonbitExpressionCall
                { called = calledDereferenced
                , arguments = [ call.argument ]
                }


moonbitExpressionUsesReferenceInLambdaOrFnDeclaration :
    { qualification : List String, name : String }
    -> MoonbitExpression
    -> Bool
moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck moonbitExpression =
    -- IGNORE TCO
    case moonbitExpression of
        MoonbitExpressionUnit ->
            False

        MoonbitExpressionInt64 _ ->
            False

        MoonbitExpressionDouble _ ->
            False

        MoonbitExpressionChar _ ->
            False

        MoonbitExpressionString _ ->
            False

        MoonbitExpressionSelf ->
            False

        MoonbitExpressionReference _ ->
            False

        MoonbitExpressionReferenceVariant _ ->
            False

        MoonbitExpressionNegateOperation inNegation ->
            moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                inNegation

        MoonbitExpressionStructAccess recordAccess ->
            moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                recordAccess.struct

        MoonbitExpressionReferenceMethod method ->
            moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                method.subject

        MoonbitExpressionAs moonbitExpressionAs ->
            moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                moonbitExpressionAs.expression

        MoonbitExpressionBinaryOperation binaryOperation ->
            (binaryOperation.left
                |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
            )
                || (binaryOperation.right
                        |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )

        MoonbitExpressionTuple parts ->
            (parts.part0
                |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
            )
                || (parts.part1
                        |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )
                || (parts.part2Up
                        |> List.any
                            (\part ->
                                part |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        MoonbitExpressionArrayLiteral elements ->
            elements
                |> List.any
                    (\element ->
                        element
                            |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                    )

        MoonbitExpressionStruct moonbitExpressionStruct ->
            moonbitExpressionStruct.fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue
                            |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                    )

        MoonbitExpressionCall call ->
            (call.called |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (call.arguments
                        |> List.any
                            (\argument ->
                                argument
                                    |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        MoonbitExpressionClosure lambda ->
            (lambda.result |> moonbitExpressionCountUsesOfReference referenceToCheck)
                >= 1

        MoonbitExpressionIfElse ifElse ->
            (ifElse.condition |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (ifElse.onTrue
                        |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )
                || (ifElse.onFalse
                        |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )

        MoonbitExpressionMatch match ->
            (match.matched |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck)
                || (match.cases
                        |> List.any
                            (\matchCase ->
                                matchCase.result
                                    |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                            )
                   )

        MoonbitExpressionAfterStatement moonbitExpressionAfterStatement ->
            (moonbitExpressionAfterStatement.statement
                |> moonbitStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck
            )
                || (moonbitExpressionAfterStatement.result
                        |> moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                   )


moonbitExpressionInnermostLambdaResult :
    MoonbitExpression
    -> { statements : List MoonbitStatement, result : MoonbitExpression }
moonbitExpressionInnermostLambdaResult moonbitExpression =
    -- IGNORE TCO
    case moonbitExpression of
        MoonbitExpressionAs moonbitExpressionAs ->
            moonbitExpressionInnermostLambdaResult moonbitExpressionAs.expression

        MoonbitExpressionClosure lambda ->
            let
                resultInnermostLambdaResult : { statements : List MoonbitStatement, result : MoonbitExpression }
                resultInnermostLambdaResult =
                    moonbitExpressionInnermostLambdaResult lambda.result
            in
            { statements = resultInnermostLambdaResult.statements
            , result = resultInnermostLambdaResult.result
            }

        MoonbitExpressionCall _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionUnit ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionInt64 _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionDouble _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionChar _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionString _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionSelf ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionReference _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionReferenceVariant _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionReferenceMethod _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionNegateOperation _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionStructAccess _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionBinaryOperation _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionTuple _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionArrayLiteral _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionStruct _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionIfElse _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionMatch _ ->
            { statements = [], result = moonbitExpression }

        MoonbitExpressionAfterStatement moonbitExpressionAfterStatement ->
            let
                inner : { statements : List MoonbitStatement, result : MoonbitExpression }
                inner =
                    moonbitExpressionInnermostLambdaResult
                        moonbitExpressionAfterStatement.result
            in
            { statements =
                moonbitExpressionAfterStatement.statement :: inner.statements
            , result = inner.result
            }


moonbitStatementUsesReferenceInLambdaOrFnDeclaration :
    { qualification : List String, name : String }
    -> MoonbitStatement
    -> Bool
moonbitStatementUsesReferenceInLambdaOrFnDeclaration referenceToCheck moonbitStatement =
    -- IGNORE TCO
    case moonbitStatement of
        MoonbitStatementLetDeclarationUninitialized _ ->
            False

        MoonbitStatementFnDeclaration fn ->
            (fn.result |> moonbitExpressionCountUsesOfReference referenceToCheck)
                >= 1

        MoonbitStatementLetDestructuring destructuring ->
            moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                destructuring.expression

        MoonbitStatementBindingAssignment assignment ->
            moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                assignment.assignedValue

        MoonbitStatementLetDeclaration moonbitStatementLetDeclaration ->
            moonbitExpressionUsesReferenceInLambdaOrFnDeclaration referenceToCheck
                moonbitStatementLetDeclaration.result


{-| Does not require computation, not to be confused with `moonbitExpressionIsConst`
-}
moonbitExpressionIsConstant : MoonbitExpression -> Bool
moonbitExpressionIsConstant moonbitExpression =
    case moonbitExpression of
        MoonbitExpressionUnit ->
            True

        MoonbitExpressionInt64 _ ->
            True

        MoonbitExpressionDouble _ ->
            True

        MoonbitExpressionChar _ ->
            True

        MoonbitExpressionString _ ->
            True

        MoonbitExpressionSelf ->
            True

        MoonbitExpressionReference _ ->
            True

        MoonbitExpressionReferenceVariant _ ->
            True

        MoonbitExpressionNegateOperation _ ->
            False

        MoonbitExpressionStructAccess _ ->
            False

        MoonbitExpressionAs _ ->
            False

        MoonbitExpressionBinaryOperation _ ->
            False

        MoonbitExpressionTuple _ ->
            False

        MoonbitExpressionArrayLiteral elements ->
            elements |> List.isEmpty

        MoonbitExpressionStruct moonbitExpressionStruct ->
            moonbitExpressionStruct.fields |> FastDict.isEmpty

        MoonbitExpressionCall _ ->
            False

        MoonbitExpressionClosure _ ->
            False

        MoonbitExpressionIfElse _ ->
            False

        MoonbitExpressionMatch _ ->
            False

        MoonbitExpressionAfterStatement _ ->
            False

        MoonbitExpressionReferenceMethod reference ->
            moonbitExpressionIsConstant reference.subject


moonbitExpressionCountUsesOfReference :
    { qualification : List String, name : String }
    -> MoonbitExpression
    -> Int
moonbitExpressionCountUsesOfReference referenceToCountUsesOf moonbitExpression =
    -- IGNORE TCO
    case moonbitExpression of
        MoonbitExpressionReference reference ->
            if
                (reference.qualification == referenceToCountUsesOf.qualification)
                    && (reference.name == referenceToCountUsesOf.name)
            then
                1

            else
                0

        MoonbitExpressionUnit ->
            0

        MoonbitExpressionSelf ->
            0

        MoonbitExpressionReferenceVariant _ ->
            0

        MoonbitExpressionInt64 _ ->
            0

        MoonbitExpressionDouble _ ->
            0

        MoonbitExpressionString _ ->
            0

        MoonbitExpressionChar _ ->
            0

        MoonbitExpressionNegateOperation inNegation ->
            moonbitExpressionCountUsesOfReference referenceToCountUsesOf inNegation

        MoonbitExpressionStructAccess recordAccess ->
            moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                recordAccess.struct

        MoonbitExpressionReferenceMethod method ->
            moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                method.subject

        MoonbitExpressionAs moonbitExpressionAs ->
            moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                moonbitExpressionAs.expression

        MoonbitExpressionClosure lambda ->
            moonbitExpressionCountUsesOfReference referenceToCountUsesOf lambda.result

        MoonbitExpressionBinaryOperation binaryOperation ->
            (binaryOperation.left
                |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (binaryOperation.right
                    |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                  )

        MoonbitExpressionIfElse ifThenElse ->
            (ifThenElse.condition
                |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (ifThenElse.onTrue
                    |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                  )
                + (ifThenElse.onFalse
                    |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                  )

        MoonbitExpressionCall call ->
            (call.called
                |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (call.arguments
                    |> listMapAndSum
                        (\argument ->
                            argument
                                |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        MoonbitExpressionArrayLiteral elements ->
            elements
                |> listMapAndSum
                    (\element ->
                        element |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                    )

        MoonbitExpressionStruct moonbitExpressionStruct ->
            moonbitExpressionStruct.fields
                |> FastDict.foldl
                    (\_ fieldValue soFar ->
                        soFar
                            + (fieldValue |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf)
                    )
                    0

        MoonbitExpressionMatch match ->
            (match.matched
                |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (match.cases
                    |> listMapAndSum
                        (\moonbitCase ->
                            moonbitCase.result |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        MoonbitExpressionTuple parts ->
            (parts.part0
                |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
            )
                + (parts.part1
                    |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                  )
                + (parts.part2Up
                    |> listMapAndSum
                        (\part ->
                            part |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                        )
                  )

        MoonbitExpressionAfterStatement moonbitExpressionAfterStatement ->
            (moonbitExpressionAfterStatement.statement
                |> moonbitStatementCountUsesOfReference referenceToCountUsesOf
            )
                + (moonbitExpressionAfterStatement.result
                    |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                  )


moonbitStatementCountUsesOfReference :
    { qualification : List String, name : String }
    -> MoonbitStatement
    -> Int
moonbitStatementCountUsesOfReference referenceToCountUsesOf moonbitStatement =
    -- IGNORE TCO
    case moonbitStatement of
        MoonbitStatementLetDeclarationUninitialized _ ->
            0

        MoonbitStatementLetDestructuring destructuring ->
            moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                destructuring.expression

        MoonbitStatementLetDeclaration moonbitStatementLetDeclaration ->
            moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                moonbitStatementLetDeclaration.result

        MoonbitStatementFnDeclaration fnDeclaration ->
            fnDeclaration.result
                |> moonbitExpressionCountUsesOfReference referenceToCountUsesOf

        MoonbitStatementBindingAssignment assignment ->
            moonbitExpressionCountUsesOfReference referenceToCountUsesOf
                assignment.assignedValue


listMapAndSum : (a -> Int) -> List a -> Int
listMapAndSum elementToInt list =
    listMapAndSumPlus 0 elementToInt list


listMapAndSumPlus : Int -> (a -> Int) -> List a -> Int
listMapAndSumPlus soFar elementToInt list =
    case list of
        [] ->
            soFar

        head :: tail ->
            listMapAndSumPlus (soFar + (head |> elementToInt))
                elementToInt
                tail


moonbitExpressionUsedLocalBindings : MoonbitExpression -> FastSet.Set String
moonbitExpressionUsedLocalBindings moonbitExpression =
    -- IGNORE TCO
    case moonbitExpression of
        MoonbitExpressionUnit ->
            FastSet.empty

        MoonbitExpressionChar _ ->
            FastSet.empty

        MoonbitExpressionString _ ->
            FastSet.empty

        MoonbitExpressionInt64 _ ->
            FastSet.empty

        MoonbitExpressionDouble _ ->
            FastSet.empty

        MoonbitExpressionSelf ->
            FastSet.empty

        MoonbitExpressionReferenceVariant _ ->
            FastSet.empty

        MoonbitExpressionReference reference ->
            case reference.qualification of
                _ :: _ ->
                    FastSet.empty

                [] ->
                    FastSet.singleton reference.name

        MoonbitExpressionClosure closure ->
            moonbitExpressionUsedLocalBindings closure.result

        MoonbitExpressionReferenceMethod referenceMethod ->
            moonbitExpressionUsedLocalBindings referenceMethod.subject

        MoonbitExpressionNegateOperation inNegation ->
            moonbitExpressionUsedLocalBindings inNegation

        MoonbitExpressionStructAccess structAccess ->
            moonbitExpressionUsedLocalBindings structAccess.struct

        MoonbitExpressionAs moonbitExpressionAs ->
            moonbitExpressionUsedLocalBindings
                moonbitExpressionAs.expression

        MoonbitExpressionBinaryOperation binaryOperation ->
            binaryOperation.left
                |> moonbitExpressionUsedLocalBindings
                |> FastSet.union
                    (binaryOperation.right
                        |> moonbitExpressionUsedLocalBindings
                    )

        MoonbitExpressionTuple parts ->
            parts.part0
                |> moonbitExpressionUsedLocalBindings
                |> FastSet.union
                    (parts.part1 |> moonbitExpressionUsedLocalBindings)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify moonbitExpressionUsedLocalBindings
                    )

        MoonbitExpressionArrayLiteral elements ->
            elements
                |> listMapToFastSetsAndUnify moonbitExpressionUsedLocalBindings

        MoonbitExpressionStruct struct ->
            struct.fields
                |> FastDict.foldl
                    (\_ fieldValue soFar ->
                        soFar
                            |> FastSet.union
                                (moonbitExpressionUsedLocalBindings fieldValue)
                    )
                    FastSet.empty

        MoonbitExpressionCall call ->
            call.called
                |> moonbitExpressionUsedLocalBindings
                |> FastSet.union
                    (call.arguments
                        |> listMapToFastSetsAndUnify moonbitExpressionUsedLocalBindings
                    )

        MoonbitExpressionIfElse ifElse ->
            ifElse.condition
                |> moonbitExpressionUsedLocalBindings
                |> FastSet.union
                    (ifElse.onTrue |> moonbitExpressionUsedLocalBindings)
                |> FastSet.union
                    (ifElse.onFalse
                        |> moonbitExpressionUsedLocalBindings
                    )

        MoonbitExpressionMatch match ->
            match.matched
                |> moonbitExpressionUsedLocalBindings
                |> FastSet.union
                    (match.cases
                        |> listMapToFastSetsAndUnify
                            (\matchCase ->
                                matchCase.result
                                    |> moonbitExpressionUsedLocalBindings
                            )
                    )

        MoonbitExpressionAfterStatement expressionAfterStatement ->
            expressionAfterStatement.statement
                |> moonbitStatementUsedLocalBindingsOutsideOfFnsAndClosures
                |> FastSet.union
                    (expressionAfterStatement.result
                        |> moonbitExpressionUsedLocalBindings
                    )


moonbitStatementUsedLocalBindingsOutsideOfFnsAndClosures : MoonbitStatement -> FastSet.Set String
moonbitStatementUsedLocalBindingsOutsideOfFnsAndClosures moonbitStatement =
    -- IGNORE TCO
    case moonbitStatement of
        MoonbitStatementFnDeclaration fnDeclaration ->
            moonbitExpressionUsedLocalBindings fnDeclaration.result

        MoonbitStatementLetDeclarationUninitialized _ ->
            FastSet.empty

        MoonbitStatementLetDestructuring letDestructuring ->
            moonbitExpressionUsedLocalBindings
                letDestructuring.expression

        MoonbitStatementLetDeclaration statementLetDeclaration ->
            moonbitExpressionUsedLocalBindings
                statementLetDeclaration.result

        MoonbitStatementBindingAssignment assignment ->
            moonbitExpressionUsedLocalBindings
                assignment.assignedValue


moonbitExpressionSubstituteReferences :
    ({ qualification : List String, name : String } -> MoonbitExpression)
    -> MoonbitExpression
    -> MoonbitExpression
moonbitExpressionSubstituteReferences referenceToExpression moonbitExpression =
    -- IGNORE TCO
    case moonbitExpression of
        MoonbitExpressionUnit ->
            MoonbitExpressionUnit

        MoonbitExpressionInt64 _ ->
            moonbitExpression

        MoonbitExpressionDouble _ ->
            moonbitExpression

        MoonbitExpressionChar _ ->
            moonbitExpression

        MoonbitExpressionString _ ->
            moonbitExpression

        MoonbitExpressionReferenceVariant _ ->
            moonbitExpression

        MoonbitExpressionSelf ->
            moonbitExpression

        MoonbitExpressionReference reference ->
            reference |> referenceToExpression

        MoonbitExpressionNegateOperation inNegation ->
            MoonbitExpressionNegateOperation
                (inNegation
                    |> moonbitExpressionSubstituteReferences referenceToExpression
                )

        MoonbitExpressionStructAccess recordAccess ->
            MoonbitExpressionStructAccess
                { struct =
                    recordAccess.struct
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                , field = recordAccess.field
                }

        MoonbitExpressionReferenceMethod reference ->
            MoonbitExpressionReferenceMethod
                { method = reference.method
                , subject =
                    reference.subject
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                }

        MoonbitExpressionAs moonbitExpressionAs ->
            MoonbitExpressionAs
                { type_ = moonbitExpressionAs.type_
                , expression =
                    moonbitExpressionAs.expression
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                }

        MoonbitExpressionClosure lambda ->
            MoonbitExpressionClosure
                { parameters = lambda.parameters
                , resultType = lambda.resultType
                , result =
                    lambda.result
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                }

        MoonbitExpressionBinaryOperation binaryOperation ->
            MoonbitExpressionBinaryOperation
                { operator = binaryOperation.operator
                , left =
                    binaryOperation.left
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                , right =
                    binaryOperation.right
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                }

        MoonbitExpressionIfElse ifElse ->
            MoonbitExpressionIfElse
                { condition =
                    ifElse.condition
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                , onTrue =
                    ifElse.onTrue
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                , onFalse =
                    ifElse.onFalse
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                }

        MoonbitExpressionTuple parts ->
            MoonbitExpressionTuple
                { part0 =
                    parts.part0
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                , part1 =
                    parts.part1
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                , part2Up =
                    parts.part2Up
                        |> List.map
                            (\part ->
                                part |> moonbitExpressionSubstituteReferences referenceToExpression
                            )
                }

        MoonbitExpressionArrayLiteral elements ->
            MoonbitExpressionArrayLiteral
                (elements
                    |> List.map
                        (\element ->
                            element |> moonbitExpressionSubstituteReferences referenceToExpression
                        )
                )

        MoonbitExpressionStruct moonbitExpressionStruct ->
            MoonbitExpressionStruct
                { name = moonbitExpressionStruct.name
                , fields =
                    moonbitExpressionStruct.fields
                        |> FastDict.map
                            (\_ fieldValue ->
                                fieldValue |> moonbitExpressionSubstituteReferences referenceToExpression
                            )
                }

        MoonbitExpressionCall call ->
            MoonbitExpressionCall
                { called =
                    call.called
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                , arguments =
                    call.arguments
                        |> List.map
                            (\argument ->
                                argument
                                    |> moonbitExpressionSubstituteReferences referenceToExpression
                            )
                }

        MoonbitExpressionMatch match ->
            MoonbitExpressionMatch
                { matched =
                    match.matched
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                , cases =
                    match.cases
                        |> List.map
                            (\matchCase ->
                                { pattern = matchCase.pattern
                                , guardConditions = matchCase.guardConditions
                                , result =
                                    matchCase.result
                                        |> moonbitExpressionSubstituteReferences referenceToExpression
                                }
                            )
                }

        MoonbitExpressionAfterStatement moonbitExpressionAfterStatement ->
            MoonbitExpressionAfterStatement
                { statement =
                    moonbitExpressionAfterStatement.statement
                        |> moonbitStatementSubstituteReferences referenceToExpression
                , result =
                    moonbitExpressionAfterStatement.result
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                }


moonbitStatementSubstituteReferences :
    ({ qualification : List String, name : String } -> MoonbitExpression)
    -> MoonbitStatement
    -> MoonbitStatement
moonbitStatementSubstituteReferences referenceToExpression moonbitStatement =
    -- IGNORE TCO
    case moonbitStatement of
        MoonbitStatementLetDeclarationUninitialized _ ->
            moonbitStatement

        MoonbitStatementLetDestructuring letDestructuring ->
            MoonbitStatementLetDestructuring
                { pattern = letDestructuring.pattern
                , expression =
                    letDestructuring.expression
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                }

        MoonbitStatementBindingAssignment assignment ->
            MoonbitStatementBindingAssignment
                { name = assignment.name
                , assignedValue =
                    assignment.assignedValue
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                }

        MoonbitStatementLetDeclaration moonbitStatementLetDeclaration ->
            MoonbitStatementLetDeclaration
                { name = moonbitStatementLetDeclaration.name
                , resultType = moonbitStatementLetDeclaration.resultType
                , result =
                    moonbitStatementLetDeclaration.result
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                }

        MoonbitStatementFnDeclaration fnDeclaration ->
            MoonbitStatementFnDeclaration
                { name = fnDeclaration.name
                , parameters = fnDeclaration.parameters
                , resultType = fnDeclaration.resultType
                , typeParameters = fnDeclaration.typeParameters
                , result =
                    fnDeclaration.result
                        |> moonbitExpressionSubstituteReferences referenceToExpression
                }


letDeclaration :
    ExpressionToMoonbitContext
    ->
        { range : Elm.Syntax.Range.Range
        , declaration : ElmSyntaxTypeInfer.LetDeclaration
        }
    -> Result String (List MoonbitStatement)
letDeclaration context syntaxLetDeclarationNode =
    case syntaxLetDeclarationNode.declaration of
        ElmSyntaxTypeInfer.LetDestructuring letDestructuring ->
            Result.map
                (\destructuredExpression ->
                    let
                        moonbitPattern :
                            { pattern : MoonbitPattern
                            , guardConditions : List MoonbitExpression
                            }
                        moonbitPattern =
                            letDestructuring.pattern
                                |> pattern
                                    { typeAliasesInModule =
                                        \moduleNameToAccess ->
                                            context.moduleInfo
                                                |> FastDict.get moduleNameToAccess
                                                |> Maybe.map .typeAliases
                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                    }
                    in
                    [ MoonbitStatementLetDestructuring
                        { pattern = moonbitPattern.pattern
                        , expression = destructuredExpression
                        }
                    ]
                )
                (letDestructuring.expression
                    |> expression
                        { moduleInfo = context.moduleInfo
                        , localElmBindingsInScope =
                            context.localElmBindingsInScope
                        , functionDeclaredMoonbitParameterEquivalentBindings =
                            context.functionDeclaredMoonbitParameterEquivalentBindings
                        , letDeclaredValueAndFunctionTypes =
                            context.letDeclaredValueAndFunctionTypes
                        , moonbitEnumTypes = context.moonbitEnumTypes
                        , moonbitConsts = context.moonbitConsts
                        , path =
                            -- intentional as there is only one sub-expression
                            context.path
                        }
                )

        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration letValueOrFunction ->
            { declaration = letValueOrFunction
            , range = syntaxLetDeclarationNode.range
            }
                |> letValueOrFunctionDeclaration context
                |> Result.map List.singleton


letValueOrFunctionDeclarationToMoonbitKindAndParameters :
    { localElmBindingsInScope : FastDict.Dict String ElmSyntaxTypeInfer.Type
    , letDeclaredValueAndFunctionTypes :
        FastDict.Dict
            String
            (Maybe
                -- Nothing means value, Just means function
                { parameters : List ElmSyntaxTypeInfer.Type
                }
            )
    , moduleInfo :
        FastDict.Dict
            {- module origin -} String
            { portsIncoming : FastSet.Set String
            , portsOutgoing : FastSet.Set String
            , -- TODO rename to valueAndFunctionTypesWithExpandedAliases
              valueAndFunctionAnnotations :
                FastDict.Dict
                    String
                    ElmSyntaxTypeInfer.Type
            , typeAliases :
                FastDict.Dict
                    String
                    { parameters : List String
                    , recordFieldOrder : Maybe (List String)
                    , type_ : ElmSyntaxTypeInfer.Type
                    }
            }
    }
    ->
        { range : Elm.Syntax.Range.Range
        , declaration :
            { signature :
                Maybe
                    { range : Elm.Syntax.Range.Range
                    , nameRange : Elm.Syntax.Range.Range
                    , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                    , annotationTypeRange : Elm.Syntax.Range.Range
                    }
            , nameRange : Elm.Syntax.Range.Range
            , name : String
            , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
            , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            , type_ : ElmSyntaxTypeInfer.Type
            }
        }
    ->
        Maybe
            -- Nothing means value, Just means function
            { parameters : List ElmSyntaxTypeInfer.Type
            }
letValueOrFunctionDeclarationToMoonbitKindAndParameters context inferredLetDeclarationValueOrFunctionNode =
    let
        introducedTypeParameters : List String
        introducedTypeParameters =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeContainedVariables
                |> FastDict.foldl
                    (\variableName variableUseRange soFar ->
                        if
                            Basics.not (variableName |> String.startsWith "number")
                                && (inferredLetDeclarationValueOrFunctionNode.range
                                        |> rangeIncludesRange variableUseRange
                                   )
                        then
                            (variableName |> toPascalCaseMoonbitName) :: soFar

                        else
                            soFar
                    )
                    []

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeExpandInnerAliases
                    (\moduleNameToAccess ->
                        context.moduleInfo
                            |> FastDict.get moduleNameToAccess
                            |> Maybe.map .typeAliases
                    )

        moonbitFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        moonbitFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction
    in
    if
        (moonbitFullTypeAsFunction.inputs |> List.isEmpty)
            && (introducedTypeParameters |> List.isEmpty)
    then
        -- using lifetime parameters from the outer scope _is_ allowed
        Nothing

    else
        let
            syntaxParameterCount : Int
            syntaxParameterCount =
                inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.length

            additionalGeneratedParameters : List ElmSyntaxTypeInfer.Type
            additionalGeneratedParameters =
                moonbitFullTypeAsFunction.inputs
                    |> List.drop syntaxParameterCount

            parameters : List ElmSyntaxTypeInfer.Type
            parameters =
                (inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.map
                        (\parameter ->
                            parameter.type_
                        )
                )
                    ++ additionalGeneratedParameters
        in
        Just
            { parameters = parameters
            }


letValueOrFunctionDeclaration :
    ExpressionToMoonbitContext
    ->
        { range : Elm.Syntax.Range.Range
        , declaration :
            { signature :
                Maybe
                    { range : Elm.Syntax.Range.Range
                    , nameRange : Elm.Syntax.Range.Range
                    , annotationType : Elm.Syntax.TypeAnnotation.TypeAnnotation
                    , annotationTypeRange : Elm.Syntax.Range.Range
                    }
            , nameRange : Elm.Syntax.Range.Range
            , name : String
            , parameters : List (ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Pattern)
            , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
            , type_ : ElmSyntaxTypeInfer.Type
            }
        }
    -> Result String MoonbitStatement
letValueOrFunctionDeclaration context inferredLetDeclarationValueOrFunctionNode =
    let
        typeAliasesInModule : String -> Maybe (FastDict.Dict String { parameters : List String, recordFieldOrder : Maybe (List String), type_ : ElmSyntaxTypeInfer.Type })
        typeAliasesInModule moduleNameToAccess =
            context.moduleInfo
                |> FastDict.get moduleNameToAccess
                |> Maybe.map .typeAliases

        allTypeParameters : List { name : String, useRange : Elm.Syntax.Range.Range }
        allTypeParameters =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeContainedVariables
                |> FastDict.foldl
                    (\variableName variableUseRange soFar ->
                        if variableName |> String.startsWith "number" then
                            soFar

                        else
                            { name = variableName |> toPascalCaseMoonbitName
                            , useRange = variableUseRange
                            }
                                :: soFar
                    )
                    []

        typeWithExpandedAliases : ElmSyntaxTypeInfer.Type
        typeWithExpandedAliases =
            inferredLetDeclarationValueOrFunctionNode.declaration.type_
                |> inferredTypeExpandInnerAliases typeAliasesInModule

        moonbitFullTypeAsFunction :
            { inputs : List ElmSyntaxTypeInfer.Type
            , output : ElmSyntaxTypeInfer.Type
            }
        moonbitFullTypeAsFunction =
            typeWithExpandedAliases
                |> inferredTypeExpandFunction

        moonbitName : String
        moonbitName =
            inferredLetDeclarationValueOrFunctionNode.declaration.name
                |> toSnakeCaseMoonbitName
    in
    if
        (moonbitFullTypeAsFunction.inputs |> List.isEmpty)
            && Basics.not
                (List.any
                    (\variable ->
                        inferredLetDeclarationValueOrFunctionNode.range
                            |> rangeIncludesRange variable.useRange
                    )
                    allTypeParameters
                )
    then
        -- using lifetime parameters from the outer scope _is_ allowed
        Result.map
            (\result ->
                MoonbitStatementLetDeclaration
                    { name = moonbitName
                    , resultType =
                        Just
                            (inferredLetDeclarationValueOrFunctionNode.declaration.type_
                                |> type_
                                    { typeAliasesInModule = typeAliasesInModule
                                    , moonbitEnumTypes = context.moonbitEnumTypes
                                    }
                            )
                    , result = result
                    }
            )
            (inferredLetDeclarationValueOrFunctionNode.declaration.result
                |> expression
                    { moduleInfo = context.moduleInfo
                    , path = context.path
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                    , localElmBindingsInScope =
                        context.localElmBindingsInScope
                    , functionDeclaredMoonbitParameterEquivalentBindings =
                        context.functionDeclaredMoonbitParameterEquivalentBindings
                    , moonbitEnumTypes = context.moonbitEnumTypes
                    , moonbitConsts = context.moonbitConsts
                    }
            )

    else
        let
            syntaxParameterCount : Int
            syntaxParameterCount =
                inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.length

            additionalGeneratedParameters : List { name : String, type_ : MoonbitType }
            additionalGeneratedParameters =
                moonbitFullTypeAsFunction.inputs
                    |> List.drop syntaxParameterCount
                    |> List.indexedMap
                        (\additionalParameterIndex additionalParameterInferredType ->
                            { name =
                                generatedParameterNameForIndexAtPath
                                    (syntaxParameterCount + additionalParameterIndex)
                                    context.path
                            , type_ =
                                additionalParameterInferredType
                                    |> type_
                                        { typeAliasesInModule = typeAliasesInModule
                                        , moonbitEnumTypes = context.moonbitEnumTypes
                                        }
                            }
                        )

            elmParametersAsMoonbit :
                { patterns : List { pattern : MoonbitPattern, type_ : MoonbitType }
                }
            elmParametersAsMoonbit =
                inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                    |> List.foldr
                        (\parameter soFar ->
                            let
                                moonbitParameter :
                                    { pattern : MoonbitPattern
                                    , guardConditions : List MoonbitExpression
                                    }
                                moonbitParameter =
                                    parameter
                                        |> pattern
                                            { typeAliasesInModule = typeAliasesInModule
                                            , moonbitEnumTypes = context.moonbitEnumTypes
                                            }
                            in
                            { patterns =
                                ({ pattern = moonbitParameter.pattern
                                 , type_ =
                                    parameter.type_
                                        |> type_
                                            { typeAliasesInModule = typeAliasesInModule
                                            , moonbitEnumTypes = context.moonbitEnumTypes
                                            }
                                 }
                                    |> moonbitParameterUnnestFn
                                )
                                    :: soFar.patterns
                            }
                        )
                        { patterns = []
                        }

            allMoonbitParameters : List { pattern : MoonbitPattern, type_ : MoonbitType }
            allMoonbitParameters =
                elmParametersAsMoonbit.patterns
                    ++ (additionalGeneratedParameters
                            |> List.map
                                (\generatedAdditionalParameter ->
                                    let
                                        parameterTypeUnnestedFn : MoonbitType
                                        parameterTypeUnnestedFn =
                                            generatedAdditionalParameter.type_
                                                |> moonbitTypeUnnestFn
                                    in
                                    { type_ = parameterTypeUnnestedFn
                                    , pattern =
                                        MoonbitPatternVariable
                                            { name = generatedAdditionalParameter.name
                                            , type_ = parameterTypeUnnestedFn
                                            }
                                    }
                                )
                       )
        in
        Result.map
            (\result ->
                let
                    resultWithAdditionalParameters : MoonbitExpression
                    resultWithAdditionalParameters =
                        additionalGeneratedParameters
                            |> List.foldl
                                (\additionalGeneratedParameter soFar ->
                                    moonbitExpressionCallCondense
                                        { called = soFar
                                        , argument =
                                            MoonbitExpressionReference
                                                { qualification = []
                                                , name = additionalGeneratedParameter.name
                                                }
                                        }
                                )
                                result

                    resultType : MoonbitType
                    resultType =
                        moonbitFullTypeAsFunction.output
                            |> type_
                                { typeAliasesInModule = typeAliasesInModule
                                , moonbitEnumTypes = context.moonbitEnumTypes
                                }
                in
                MoonbitStatementFnDeclaration
                    { name = moonbitName
                    , parameters =
                        allMoonbitParameters
                            |> List.indexedMap
                                (\parameterIndex parameter ->
                                    { binding =
                                        case parameter.pattern of
                                            MoonbitPatternVariable parameterVariable ->
                                                Just parameterVariable.name

                                            MoonbitPatternIgnore ->
                                                Nothing

                                            _ ->
                                                Just (generatedParameterNameForIndex parameterIndex)
                                    , type_ = parameter.type_
                                    }
                                )
                    , resultType = resultType
                    , typeParameters =
                        allTypeParameters
                            |> List.foldl
                                (\typeParameter soFar ->
                                    if
                                        inferredLetDeclarationValueOrFunctionNode.range
                                            |> rangeIncludesRange typeParameter.useRange
                                    then
                                        soFar |> FastSet.insert typeParameter.name

                                    else
                                        soFar
                                )
                                FastSet.empty
                            |> FastSet.toList
                    , result =
                        resultWithAdditionalParameters
                            |> moonbitExpressionPrependStatements
                                (allMoonbitParameters
                                    |> List.indexedMap Tuple.pair
                                    |> List.filterMap
                                        (\( parameterIndex, parameter ) ->
                                            case parameter.pattern of
                                                MoonbitPatternVariable _ ->
                                                    Nothing

                                                MoonbitPatternIgnore ->
                                                    Nothing

                                                parameterPatternThatNeedsToBeDestructured ->
                                                    Just
                                                        (MoonbitStatementLetDestructuring
                                                            { pattern = parameterPatternThatNeedsToBeDestructured
                                                            , expression =
                                                                MoonbitExpressionReference
                                                                    { qualification = []
                                                                    , name = generatedParameterNameForIndex parameterIndex
                                                                    }
                                                            }
                                                        )
                                        )
                                )
                    }
            )
            (inferredLetDeclarationValueOrFunctionNode.declaration.result
                |> expression
                    { moduleInfo = context.moduleInfo
                    , localElmBindingsInScope =
                        context.localElmBindingsInScope
                            |> FastDict.union
                                (inferredLetDeclarationValueOrFunctionNode.declaration.parameters
                                    |> listMapToFastDictsAndUnify patternTypedNodeIntroducedVariables
                                )
                    , functionDeclaredMoonbitParameterEquivalentBindings =
                        context.functionDeclaredMoonbitParameterEquivalentBindings
                            |> FastSet.union
                                (allMoonbitParameters
                                    |> listMapToFastSetsAndUnify
                                        (\moonbitParameter ->
                                            moonbitParameter.pattern
                                                |> moonbitPatternDirectlyCapturingBindings
                                        )
                                )
                    , letDeclaredValueAndFunctionTypes =
                        context.letDeclaredValueAndFunctionTypes
                    , moonbitEnumTypes = context.moonbitEnumTypes
                    , moonbitConsts = context.moonbitConsts
                    , path = "result" :: context.path
                    }
            )


{-| E.g. in

    (a @ ((b) @ ( first, second @ third )))

the "directly capturing" bindings are `a` and `b`
as they reference the whole matched expression.

-}
moonbitPatternDirectlyCapturingBindings : MoonbitPattern -> FastSet.Set String
moonbitPatternDirectlyCapturingBindings moonbitPattern =
    -- IGNORE TCO
    case moonbitPattern of
        MoonbitPatternIgnore ->
            FastSet.empty

        MoonbitPatternChar _ ->
            FastSet.empty

        MoonbitPatternString _ ->
            FastSet.empty

        MoonbitPatternInteger _ ->
            FastSet.empty

        MoonbitPatternTuple _ ->
            FastSet.empty

        MoonbitPatternVariant _ ->
            FastSet.empty

        MoonbitPatternStructNotExhaustive _ ->
            FastSet.empty

        MoonbitPatternVariable binding ->
            FastSet.singleton binding.name

        MoonbitPatternAlias patternAlias ->
            FastSet.insert patternAlias.variable
                (moonbitPatternDirectlyCapturingBindings patternAlias.pattern)


rangeIncludesRange : Elm.Syntax.Range.Range -> Elm.Syntax.Range.Range -> Bool
rangeIncludesRange toCheckForInclusion baseRange =
    ((baseRange.start.row - toCheckForInclusion.start.row < 0)
        || ((baseRange.start.row - toCheckForInclusion.start.row == 0)
                && (baseRange.start.column - toCheckForInclusion.start.column <= 0)
           )
    )
        && ((baseRange.end.row - toCheckForInclusion.end.row > 0)
                || ((baseRange.end.row - toCheckForInclusion.end.row == 0)
                        && (baseRange.end.column - toCheckForInclusion.end.column >= 0)
                   )
           )


inferredTypeContainedVariables :
    ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String Elm.Syntax.Range.Range
inferredTypeContainedVariables inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            FastDict.singleton variable.name variable.useRange

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainedVariables inferredTypeNotVariable


inferredTypeNotVariableContainedVariables :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> FastDict.Dict String Elm.Syntax.Range.Range
inferredTypeNotVariableContainedVariables inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            FastDict.union
                (typeFunction.input |> inferredTypeContainedVariables)
                (typeFunction.output |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeTuple typeTuple ->
            FastDict.union
                (typeTuple.part0 |> inferredTypeContainedVariables)
                (typeTuple.part1 |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeTriple typeTriple ->
            (typeTriple.part0 |> inferredTypeContainedVariables)
                |> FastDict.union
                    (typeTriple.part1 |> inferredTypeContainedVariables)
                |> FastDict.union
                    (typeTriple.part2 |> inferredTypeContainedVariables)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastDictsAndUnify inferredTypeContainedVariables

        ElmSyntaxTypeInfer.TypeRecord typeRecordFields ->
            typeRecordFields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeContainedVariables)
                    )
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeContainedVariables)
                    )
                    (FastDict.singleton typeRecordExtension.recordVariable.name
                        typeRecordExtension.recordVariable.useRange
                    )


expressionOperatorToMoonbitFunctionReference :
    { symbol : String
    , moduleOrigin : String
    , type_ : ElmSyntaxTypeInfer.Type
    }
    ->
        Result
            String
            { qualification : List String
            , name : String
            }
expressionOperatorToMoonbitFunctionReference operator =
    case operator.symbol of
        "+" ->
            okReferenceAdd

        "-" ->
            okReferenceSub

        "*" ->
            okReferenceMul

        "/" ->
            okReferenceFdiv

        "//" ->
            okReferenceIdiv

        "^" ->
            Ok
                (case
                    case operator.type_ of
                        ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                            typeFunction.input |> inferredTypeCheckOrGuessIntOrFloat

                        _ ->
                            -- assume Int
                            IntNotFloat
                 of
                    FloatNotInt ->
                        { qualification = [ "math" ]
                        , name = "pow"
                        }

                    IntNotFloat ->
                        { qualification = []
                        , name = "basics_pow_int"
                        }
                )

        "==" ->
            okReferenceEq

        "/=" ->
            okReferenceNeq

        "||" ->
            okReferenceOr

        "&&" ->
            okReferenceAnd

        "<" ->
            okReferenceLt

        ">" ->
            okReferenceGt

        "<=" ->
            okReferenceLe

        ">=" ->
            okReferenceGe

        "::" ->
            okReferenceListCons

        "++" ->
            case operator.type_ of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction typeFunction) ->
                    if typeFunction.input == inferredTypeString then
                        okReferenceStringAppend

                    else
                        -- assume List
                        okReferenceListAppend

                _ ->
                    -- assume List
                    okReferenceListAppend

        "|>" ->
            okReferenceApR

        "<|" ->
            okReferenceApL

        ">>" ->
            okReferenceComposeR

        "<<" ->
            okReferenceComposeL

        "|=" ->
            okReferenceParserAdvancedKeeper

        "|." ->
            okReferenceParserAdvancedIgnorer

        "</>" ->
            okReferenceUrlParserSlash

        "<?>" ->
            okReferenceUrlParserQuestionMark

        unknownOrUnsupportedOperator ->
            Err ("unknown/unsupported operator " ++ unknownOrUnsupportedOperator)


okReferenceNeq :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceNeq =
    Ok
        { qualification = []
        , name = "basics_neq"
        }


okReferenceEq :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceEq =
    Ok
        { qualification = []
        , name = "basics_eq"
        }


okReferenceOr :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceOr =
    Ok
        { qualification = []
        , name = "basics_or"
        }


okReferenceAnd :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceAnd =
    Ok
        { qualification = []
        , name = "basics_and"
        }


okReferenceLt :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceLt =
    Ok
        { qualification = []
        , name = "basics_lt"
        }


okReferenceGt :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceGt =
    Ok
        { qualification = []
        , name = "basics_gt"
        }


okReferenceLe :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceLe =
    Ok
        { qualification = []
        , name = "basics_le"
        }


okReferenceGe :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceGe =
    Ok
        { qualification = []
        , name = "basics_ge"
        }


okReferenceMul :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceMul =
    Ok
        { qualification = []
        , name = "basics_mul"
        }


okReferenceIdiv :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceIdiv =
    Ok
        { qualification = []
        , name = "basics_idiv"
        }


okReferenceFdiv :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceFdiv =
    Ok
        { qualification = []
        , name = "basics_fdiv"
        }


okReferenceSub :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceSub =
    Ok
        { qualification = []
        , name = "basics_sub"
        }


okReferenceAdd :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceAdd =
    Ok
        { qualification = []
        , name = "basics_add"
        }


okReferenceApR :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceApR =
    Ok
        { qualification = []
        , name = "basics_apr"
        }


okReferenceApL :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceApL =
    Ok
        { qualification = []
        , name = "basics_apl"
        }


okReferenceComposeR :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceComposeR =
    Ok
        { qualification = []
        , name = "basics_composer"
        }


okReferenceComposeL :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceComposeL =
    Ok
        { qualification = []
        , name = "basics_composel"
        }


okReferenceParserAdvancedKeeper :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceParserAdvancedKeeper =
    Ok
        { qualification = []
        , name = "parser_advanced_keeper"
        }


okReferenceParserAdvancedIgnorer :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceParserAdvancedIgnorer =
    Ok
        { qualification = []
        , name = "parser_advanced_ignorer"
        }


okReferenceUrlParserSlash :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceUrlParserSlash =
    Ok
        { qualification = []
        , name = "url_parser_slash"
        }


okReferenceUrlParserQuestionMark :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceUrlParserQuestionMark =
    Ok
        { qualification = []
        , name = "url_parser_question_mark"
        }


okReferenceListCons :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceListCons =
    Ok
        { qualification = []
        , name = "list_cons"
        }


okReferenceStringAppend :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceStringAppend =
    Ok
        { qualification = []
        , name = "string_append"
        }


okReferenceListAppend :
    Result
        error_
        { qualification : List String
        , name : String
        }
okReferenceListAppend =
    Ok
        { qualification = []
        , name = "list_append"
        }


inferredTypeString : ElmSyntaxTypeInfer.Type
inferredTypeString =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "String"
            , name = "String"
            , arguments = []
            }
        )


printMoonbitFnGenerics :
    { typeParameters : List String
    }
    -> Print
printMoonbitFnGenerics typeVariablesToDeclare =
    case typeVariablesToDeclare.typeParameters of
        [] ->
            Print.empty

        typeParameter0 :: typeParameter1Up ->
            Print.exactly
                ("["
                    ++ listFilledMapAndStringJoinWith ", "
                        (\typeParameter ->
                            typeParameter
                                ++ (if typeParameter |> String.startsWith "Comparable" then
                                        ": Compare"

                                    else
                                        ""
                                   )
                        )
                        typeParameter0
                        typeParameter1Up
                    ++ "]"
                )


printMoonbitFnDeclaration :
    { name : String
    , parameters : List { binding : Maybe String, type_ : MoonbitType }
    , result : MoonbitExpression
    , resultType : MoonbitType
    }
    -> Print
printMoonbitFnDeclaration moonbitValueOrFunctionDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printMoonbitTypeNotParenthesized
                moonbitValueOrFunctionDeclaration.resultType

        parameterPrints : List Print
        parameterPrints =
            moonbitValueOrFunctionDeclaration.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printMoonbitDeclarationParameterTypeNotParenthesized
                                    parameter.type_
                        in
                        (case parameter.binding of
                            Nothing ->
                                Print.exactly "_"

                            Just parameterName ->
                                Print.exactly parameterName
                        )
                            |> Print.followedBy printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (parameterTypePrint |> Print.lineSpread)
                                        |> Print.followedBy
                                            parameterTypePrint
                                    )
                                )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread

        headerLineSpread : Print.LineSpread
        headerLineSpread =
            parametersLineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> resultTypePrint |> Print.lineSpread)

        typeVariablesToDeclare : List String
        typeVariablesToDeclare =
            moonbitValueOrFunctionDeclaration.resultType
                |> moonbitTypeContainedVariables
                |> FastSet.union
                    (moonbitValueOrFunctionDeclaration.parameters
                        |> listMapToFastSetsAndUnify
                            (\parameter ->
                                parameter.type_ |> moonbitTypeContainedVariables
                            )
                    )
                |> FastSet.toList
    in
    Print.exactly "pub fn"
        |> Print.followedBy
            (printMoonbitFnGenerics
                { typeParameters = typeVariablesToDeclare
                }
            )
        |> Print.followedBy
            (Print.exactly (" " ++ moonbitValueOrFunctionDeclaration.name))
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (printParenthesized
                    (Print.emptyOrLinebreakIndented parametersLineSpread
                        |> Print.followedBy
                            (parameterPrints
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\parameterPrint -> parameterPrint)
                                    (printExactlyComma
                                        |> Print.followedBy
                                            (Print.spaceOrLinebreakIndented parametersLineSpread)
                                    )
                            )
                        |> Print.followedBy
                            (Print.emptyOrLinebreakIndented parametersLineSpread)
                    )
                    |> Print.followedBy printExactlySpaceMinusGreaterThan
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented headerLineSpread)
                    |> Print.followedBy
                        resultTypePrint
                    |> Print.followedBy printExactlySpaceCurlyOpening
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            moonbitValueOrFunctionDeclaration.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printMoonbitDeclarationParameterTypeNotParenthesized : MoonbitType -> Print
printMoonbitDeclarationParameterTypeNotParenthesized parameterType =
    case parameterType of
        MoonbitTypeFunction parameterTypeFunction ->
            printMoonbitTypeFunction
                parameterTypeFunction

        _ ->
            printMoonbitTypeNotParenthesized parameterType


printMoonbitTypeFunction :
    { input : List MoonbitType, output : MoonbitType }
    -> Print
printMoonbitTypeFunction typeFunction =
    let
        inputPrint : Print
        inputPrint =
            typeFunction.input
                |> printMoonbitTypeFunctionInput

        outputPrint : Print
        outputPrint =
            printMoonbitTypeNotParenthesized
                typeFunction.output

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            inputPrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> outputPrint |> Print.lineSpread)
    in
    inputPrint
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented fullLineSpread)
        |> Print.followedBy
            (Print.exactly " ->")
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented fullLineSpread)
        |> Print.followedBy outputPrint


printMoonbitLetDeclaration :
    { name : String
    , result : MoonbitExpression
    , resultType : MoonbitType
    }
    -> Print
printMoonbitLetDeclaration moonbitLetDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printMoonbitTypeNotParenthesized
                moonbitLetDeclaration.resultType

        resultTypeFullLineSpread : Print.LineSpread
        resultTypeFullLineSpread =
            resultTypePrint |> Print.lineSpread
    in
    Print.exactly
        ("pub let " ++ moonbitLetDeclaration.name)
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (printExactlyColon
                    |> Print.followedBy
                        (Print.withIndentAtNextMultipleOf4
                            (Print.spaceOrLinebreakIndented resultTypeFullLineSpread
                                |> Print.followedBy resultTypePrint
                            )
                        )
                    |> Print.followedBy
                        (Print.exactly " =")
                    |> Print.followedBy
                        Print.linebreakIndented
                    |> Print.followedBy
                        (printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            moonbitLetDeclaration.result
                        )
                )
            )


listFilledMapAndStringJoinWith : String -> (a -> String) -> a -> List a -> String
listFilledMapAndStringJoinWith separator elementChange head tail =
    List.foldl
        (\element leftSoFar ->
            leftSoFar ++ separator ++ (element |> elementChange) ++ ""
        )
        (head |> elementChange)
        tail


moonbitTypeContainedVariables : MoonbitType -> FastSet.Set String
moonbitTypeContainedVariables moonbitType =
    -- IGNORE TCO
    case moonbitType of
        MoonbitTypeInfer ->
            FastSet.empty

        MoonbitTypeVariable variable ->
            FastSet.singleton variable

        MoonbitTypeTuple parts ->
            (parts.part0 |> moonbitTypeContainedVariables)
                |> FastSet.union
                    (parts.part1 |> moonbitTypeContainedVariables)
                |> FastSet.union
                    (parts.part2Up
                        |> listMapToFastSetsAndUnify
                            moonbitTypeContainedVariables
                    )

        MoonbitTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastSetsAndUnify moonbitTypeContainedVariables

        MoonbitTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictMapToFastSetsAndUnify
                    (\_ fieldValue ->
                        fieldValue |> moonbitTypeContainedVariables
                    )

        MoonbitTypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input
                    |> listMapToFastSetsAndUnify moonbitTypeContainedVariables
                )
                (typeFunction.output |> moonbitTypeContainedVariables)


fastDictMapToFastSetsAndUnify :
    (k -> v -> FastSet.Set comparable)
    -> FastDict.Dict k v
    -> FastSet.Set comparable
fastDictMapToFastSetsAndUnify keyValueToFastSet fastDict =
    fastDict
        |> FastDict.foldr
            (\key value soFar ->
                FastSet.union
                    soFar
                    (keyValueToFastSet key value)
            )
            FastSet.empty


{-| Does it contain no type variables. E.g

    ( Int, { a : (), b : List Int -> Never } )

is concrete but

    nothing : Maybe a

is not concrete.

-}
moonbitTypeIsConcrete : MoonbitType -> Bool
moonbitTypeIsConcrete moonbitType =
    -- IGNORE TCO
    case moonbitType of
        MoonbitTypeInfer ->
            -- not decide-able at least
            False

        MoonbitTypeVariable _ ->
            False

        MoonbitTypeTuple parts ->
            (parts.part0 |> moonbitTypeIsConcrete)
                && (parts.part1 |> moonbitTypeIsConcrete)
                && (parts.part2Up
                        |> List.all moonbitTypeIsConcrete
                   )

        MoonbitTypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.all moonbitTypeIsConcrete

        MoonbitTypeRecordStruct recordStruct ->
            recordStruct.fields
                |> fastDictAll
                    (\_ fieldValue ->
                        fieldValue |> moonbitTypeIsConcrete
                    )

        MoonbitTypeFunction typeFunction ->
            (typeFunction.input
                |> List.all moonbitTypeIsConcrete
            )
                && (typeFunction.output |> moonbitTypeIsConcrete)


printMoonbitStatementFnDeclaration :
    { name : String
    , parameters : List { binding : Maybe String, type_ : MoonbitType }
    , result : MoonbitExpression
    , resultType : MoonbitType
    , typeParameters : List String
    }
    -> Print
printMoonbitStatementFnDeclaration moonbitFnDeclaration =
    let
        resultTypePrint : Print
        resultTypePrint =
            printMoonbitTypeNotParenthesized
                moonbitFnDeclaration.resultType

        parameterPrints : List Print
        parameterPrints =
            moonbitFnDeclaration.parameters
                |> List.map
                    (\parameter ->
                        let
                            parameterTypePrint : Print
                            parameterTypePrint =
                                printMoonbitDeclarationParameterTypeNotParenthesized
                                    parameter.type_
                        in
                        (case parameter.binding of
                            Nothing ->
                                Print.exactly "_"

                            Just parameterName ->
                                Print.exactly parameterName
                        )
                            |> Print.followedBy printExactlyColon
                            |> Print.followedBy
                                (Print.withIndentAtNextMultipleOf4
                                    (Print.spaceOrLinebreakIndented
                                        (parameterTypePrint |> Print.lineSpread)
                                        |> Print.followedBy
                                            parameterTypePrint
                                    )
                                )
                    )

        parametersLineSpread : Print.LineSpread
        parametersLineSpread =
            parameterPrints
                |> Print.lineSpreadListMapAndCombine
                    Print.lineSpread

        headerLineSpread : Print.LineSpread
        headerLineSpread =
            parametersLineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> resultTypePrint |> Print.lineSpread)
    in
    Print.exactly "fn"
        |> Print.followedBy
            (printMoonbitFnGenerics
                { typeParameters = moonbitFnDeclaration.typeParameters
                }
            )
        |> Print.followedBy (Print.exactly (" " ++ moonbitFnDeclaration.name))
        |> Print.followedBy
            (Print.withIndentIncreasedBy 4
                (printParenthesized
                    (Print.emptyOrLinebreakIndented parametersLineSpread
                        |> Print.followedBy
                            (parameterPrints
                                |> Print.listMapAndIntersperseAndFlatten
                                    (\parameterPrint -> parameterPrint)
                                    (printExactlyComma
                                        |> Print.followedBy
                                            (Print.spaceOrLinebreakIndented parametersLineSpread)
                                    )
                            )
                        |> Print.followedBy
                            (Print.emptyOrLinebreakIndented parametersLineSpread)
                    )
                    |> Print.followedBy printExactlySpaceMinusGreaterThan
                    |> Print.followedBy
                        (Print.spaceOrLinebreakIndented headerLineSpread)
                    |> Print.followedBy
                        resultTypePrint
                    |> Print.followedBy printExactlySpaceCurlyOpening
                    |> Print.followedBy Print.linebreakIndented
                    |> Print.followedBy
                        (printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                            moonbitFnDeclaration.result
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printMoonbitStatementLetDeclaration :
    { name : String
    , result : MoonbitExpression
    , resultType : Maybe MoonbitType
    }
    -> Print
printMoonbitStatementLetDeclaration moonbitLetDeclaration =
    Print.exactly
        ("let " ++ moonbitLetDeclaration.name)
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                ((case moonbitLetDeclaration.resultType of
                    Nothing ->
                        Print.empty

                    Just resultType ->
                        let
                            resultTypePrint : Print
                            resultTypePrint =
                                printMoonbitDeclarationParameterTypeNotParenthesized
                                    resultType
                        in
                        Print.exactly ":"
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented
                                    (resultTypePrint |> Print.lineSpread)
                                    |> Print.followedBy resultTypePrint
                                )
                 )
                    |> Print.followedBy printExactlySpaceEqualsLinebreakIndented
                    |> Print.followedBy
                        (printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            moonbitLetDeclaration.result
                        )
                )
            )


printExactlySpaceEqualsLinebreakIndented : Print
printExactlySpaceEqualsLinebreakIndented =
    printExactlySpaceEquals
        |> Print.followedBy Print.linebreakIndented


printExactlySpaceMinusGreaterThan : Print
printExactlySpaceMinusGreaterThan =
    Print.exactly " ->"


inferredValueOrFunctionDeclarationsToMostToLeastDependedOn :
    { moduleOrigin : String }
    -> List InferredValueOrFunctionDeclaration
    -> List (Graph.SCC InferredValueOrFunctionDeclaration)
inferredValueOrFunctionDeclarationsToMostToLeastDependedOn context inferredValueOrFunctionDeclarations =
    inferredValueOrFunctionDeclarations
        |> List.map
            (\inferredValueOrFunctionDeclaration ->
                ( inferredValueOrFunctionDeclaration
                , ( context.moduleOrigin, inferredValueOrFunctionDeclaration.name )
                , inferredValueOrFunctionDeclaration.result
                    |> inferredExpressionTypedNodeUsedReferences
                    |> FastSet.toList
                )
            )
        |> Graph.stronglyConnComponents


inferredExpressionTypedNodeUsedReferences :
    ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    -> FastSet.Set ( {- module origin -} String, String )
inferredExpressionTypedNodeUsedReferences expressionTypedNode =
    -- IGNORE TCO
    case expressionTypedNode.value of
        ElmSyntaxTypeInfer.ExpressionUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionInteger _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionFloat _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionString _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionChar _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceVariant _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReferenceRecordTypeAliasConstructorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionOperatorFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionRecordAccessFunction _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.ExpressionReference reference ->
            FastSet.singleton ( reference.moduleOrigin, reference.name )

        ElmSyntaxTypeInfer.ExpressionNegation negated ->
            inferredExpressionTypedNodeUsedReferences negated

        ElmSyntaxTypeInfer.ExpressionParenthesized inParens ->
            inferredExpressionTypedNodeUsedReferences inParens

        ElmSyntaxTypeInfer.ExpressionRecordAccess expressionRecordAccess ->
            inferredExpressionTypedNodeUsedReferences
                expressionRecordAccess.record

        ElmSyntaxTypeInfer.ExpressionLambda expressionLambda ->
            inferredExpressionTypedNodeUsedReferences
                expressionLambda.result

        ElmSyntaxTypeInfer.ExpressionInfixOperation expressionInfixOperation ->
            expressionInfixOperation.left
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionInfixOperation.right
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTuple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (parts.part1
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionTriple parts ->
            parts.part0
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (parts.part1
                        |> inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (parts.part2
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionIfThenElse expressionIfThenElse ->
            expressionIfThenElse.condition
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionIfThenElse.onTrue
                        |> inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (expressionIfThenElse.onFalse
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionList elements ->
            elements
                |> listMapToFastSetsAndUnify
                    inferredExpressionTypedNodeUsedReferences

        ElmSyntaxTypeInfer.ExpressionRecord fields ->
            fields
                |> listMapToFastSetsAndUnify
                    (\field ->
                        field.value
                            |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionCall expressionCall ->
            expressionCall.called
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionCall.argument1Up
                        |> listMapToFastSetsAndUnify
                            inferredExpressionTypedNodeUsedReferences
                    )
                |> FastSet.union
                    (expressionCall.argument0
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionRecordUpdate expressionRecordUpdate ->
            FastSet.insert
                ( expressionRecordUpdate.recordVariable.value.moduleOrigin
                , expressionRecordUpdate.recordVariable.value.name
                )
                (expressionRecordUpdate.field1Up
                    |> listMapToFastSetsAndUnify
                        (\field ->
                            field.value
                                |> inferredExpressionTypedNodeUsedReferences
                        )
                )
                |> FastSet.union
                    (expressionRecordUpdate.field0.value
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionCaseOf expressionCaseOf ->
            expressionCaseOf.matched
                |> inferredExpressionTypedNodeUsedReferences
                |> FastSet.union
                    (expressionCaseOf.case1Up
                        |> listMapToFastSetsAndUnify
                            (\caseOfCase ->
                                caseOfCase.result
                                    |> inferredExpressionTypedNodeUsedReferences
                            )
                    )
                |> FastSet.union
                    (expressionCaseOf.case0.result
                        |> inferredExpressionTypedNodeUsedReferences
                    )

        ElmSyntaxTypeInfer.ExpressionLetIn expressionLetIn ->
            expressionLetInUsesOfLocalReferences expressionLetIn


expressionLetInUsesOfLocalReferences :
    { declaration1Up :
        List
            { range : Elm.Syntax.Range.Range
            , declaration : ElmSyntaxTypeInfer.LetDeclaration
            }
    , declaration0 :
        { range : Elm.Syntax.Range.Range
        , declaration : ElmSyntaxTypeInfer.LetDeclaration
        }
    , result : ElmSyntaxTypeInfer.TypedNode ElmSyntaxTypeInfer.Expression
    }
    -> FastSet.Set ( {- module origin -} String, String )
expressionLetInUsesOfLocalReferences expressionLetIn =
    FastSet.union
        (expressionLetIn.declaration1Up
            |> List.foldl
                (\inferredLetDeclaration soFar ->
                    FastSet.union
                        soFar
                        (inferredLetDeclaration.declaration
                            |> letDeclarationUsesOfLocalReferences
                        )
                )
                (expressionLetIn.declaration0.declaration
                    |> letDeclarationUsesOfLocalReferences
                )
        )
        (expressionLetIn.result
            |> inferredExpressionTypedNodeUsedReferences
        )


letDeclarationUsesOfLocalReferences :
    ElmSyntaxTypeInfer.LetDeclaration
    -> FastSet.Set ( {- module origin -} String, String )
letDeclarationUsesOfLocalReferences inferredLetDeclaration =
    case inferredLetDeclaration of
        ElmSyntaxTypeInfer.LetDestructuring letDestructuring ->
            letDestructuring.expression
                |> inferredExpressionTypedNodeUsedReferences

        ElmSyntaxTypeInfer.LetValueOrFunctionDeclaration inferredLetValueOrFunctionDeclaration ->
            inferredLetValueOrFunctionDeclaration.result
                |> inferredExpressionTypedNodeUsedReferences


type InferredChoiceTypeOrTypeAliasDeclaration
    = InferredChoiceTypeDeclaration
        { name : String
        , parameters : List String
        , variants :
            FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
        }
    | InferredTypeAliasDeclaration
        { name : String
        , parameters : List String
        , type_ : ElmSyntaxTypeInfer.Type
        }


inferredTypeDeclarationsToMostToLeastDependedOn :
    { moduleOrigin : String
    , typeAliases :
        List
            { name : String
            , parameters : List String
            , type_ : ElmSyntaxTypeInfer.Type
            }
    , choiceTypes :
        List
            { name : String
            , parameters : List String
            , variants :
                FastDict.Dict String (List ElmSyntaxTypeInfer.Type)
            }
    }
    -> List (Graph.SCC InferredChoiceTypeOrTypeAliasDeclaration)
inferredTypeDeclarationsToMostToLeastDependedOn moonbitTypeDeclarations =
    moonbitTypeDeclarations.typeAliases
        |> List.foldl
            (\aliasDeclaration soFar ->
                ( InferredTypeAliasDeclaration aliasDeclaration
                , ( moonbitTypeDeclarations.moduleOrigin, aliasDeclaration.name )
                , aliasDeclaration.type_
                    |> inferredTypeContainedLocallyDeclaredReferences
                    |> FastSet.toList
                )
                    :: soFar
            )
            (moonbitTypeDeclarations.choiceTypes
                |> List.map
                    (\enumDeclaration ->
                        ( InferredChoiceTypeDeclaration enumDeclaration
                        , ( moonbitTypeDeclarations.moduleOrigin, enumDeclaration.name )
                        , enumDeclaration.variants
                            |> FastDict.foldl
                                (\_ variantValues soFar ->
                                    FastSet.union soFar
                                        (variantValues
                                            |> listMapToFastSetsAndUnify
                                                (\variantValue ->
                                                    variantValue
                                                        |> inferredTypeContainedLocallyDeclaredReferences
                                                )
                                        )
                                )
                                FastSet.empty
                            |> FastSet.toList
                        )
                    )
            )
        |> Graph.stronglyConnComponents


inferredTypeContainedLocallyDeclaredReferences :
    ElmSyntaxTypeInfer.Type
    -> FastSet.Set ( {- module origin -} String, String )
inferredTypeContainedLocallyDeclaredReferences inferredType =
    -- IGNORE TCO
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            FastSet.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainedLocallyDeclaredReferences inferredTypeNotVariable


inferredTypeNotVariableContainedLocallyDeclaredReferences :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> FastSet.Set ( {- module origin -} String, String )
inferredTypeNotVariableContainedLocallyDeclaredReferences inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastSet.empty

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            FastSet.insert
                ( typeConstruct.moduleOrigin, typeConstruct.name )
                (typeConstruct.arguments
                    |> listMapToFastSetsAndUnify inferredTypeContainedLocallyDeclaredReferences
                )

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            FastSet.union
                (typeFunction.input |> inferredTypeContainedLocallyDeclaredReferences)
                (typeFunction.output |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            parts.part0
                |> inferredTypeContainedLocallyDeclaredReferences
                |> FastSet.union
                    (parts.part1 |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            parts.part0
                |> inferredTypeContainedLocallyDeclaredReferences
                |> FastSet.union
                    (parts.part1 |> inferredTypeContainedLocallyDeclaredReferences)
                |> FastSet.union
                    (parts.part2 |> inferredTypeContainedLocallyDeclaredReferences)

        ElmSyntaxTypeInfer.TypeRecordExtension inferredRecordExtension ->
            inferredRecordExtension.fields
                |> FastDict.values
                |> listMapToFastSetsAndUnify
                    inferredTypeContainedLocallyDeclaredReferences

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> FastDict.values
                |> listMapToFastSetsAndUnify
                    inferredTypeContainedLocallyDeclaredReferences


{-| Choose one element in the list for each key.
List all possibilities
-}
fastDictPermutations :
    FastDict.Dict comparableKey (List option)
    -> List (FastDict.Dict comparableKey option)
fastDictPermutations specializations =
    specializations
        |> FastDict.foldl
            (\variable variableSpecializations soFar ->
                variableSpecializations
                    |> List.concatMap
                        (\variableSpecialization ->
                            soFar
                                |> List.map
                                    (\permutationSoFar ->
                                        permutationSoFar
                                            |> FastDict.insert variable variableSpecialization
                                    )
                        )
            )
            listSingletonFastDictEmpty


listSingletonFastDictEmpty : List (FastDict.Dict k_ v_)
listSingletonFastDictEmpty =
    [ FastDict.empty ]


createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable :
    ElmSyntaxTypeInfer.Type
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String String
createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable inferredType (Elm.Syntax.Node.Node _ syntaxTypePotentiallyParenthesized) =
    let
        syntaxType : Elm.Syntax.TypeAnnotation.TypeAnnotation
        syntaxType =
            syntaxTypePotentiallyParenthesized |> syntaxTypeToNotParenthesized
    in
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable inferredVariable ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType syntaxVariable ->
                    FastDict.singleton inferredVariable.name syntaxVariable

                Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) _ ->
                    FastDict.singleton inferredVariable.name syntaxRecordVariable

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable
                inferredTypeNotVariable
                syntaxType


syntaxTypeToNotParenthesized :
    Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeToNotParenthesized syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Typed _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Record _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
            syntaxType

        Elm.Syntax.TypeAnnotation.Tupled tupleParts ->
            case tupleParts of
                [ Elm.Syntax.Node.Node _ inParens ] ->
                    syntaxTypeToNotParenthesized inParens

                [] ->
                    syntaxType

                _ :: _ :: _ ->
                    syntaxType


createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> FastDict.Dict String String
createSynchronizationFromInferredTypeNotVariableVariableToSyntaxTypeVariable inferredTypeNotVariable syntaxType =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction inferredTypeFunction ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation syntaxInput syntaxOutput ->
                    createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                        inferredTypeFunction.output
                        syntaxOutput
                        |> FastDict.union
                            (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredTypeFunction.input
                                syntaxInput
                            )

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTuple inferredParts ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
                    case syntaxParts of
                        [ syntaxPart0, syntaxPart1 ] ->
                            createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredParts.part0
                                syntaxPart0
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part1
                                        syntaxPart1
                                    )

                        [] ->
                            FastDict.empty

                        [ _ ] ->
                            FastDict.empty

                        _ :: _ :: _ :: _ ->
                            FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTriple inferredParts ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Tupled syntaxParts ->
                    case syntaxParts of
                        [ syntaxPart0, syntaxPart1, syntaxPart2 ] ->
                            createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                inferredParts.part0
                                syntaxPart0
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part1
                                        syntaxPart1
                                    )
                                |> FastDict.union
                                    (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                        inferredParts.part2
                                        syntaxPart2
                                    )

                        [] ->
                            FastDict.empty

                        [ _ ] ->
                            FastDict.empty

                        [ _, _ ] ->
                            FastDict.empty

                        _ :: _ :: _ :: _ :: _ ->
                            FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Typed _ syntaxArguments ->
                    listFoldl2From FastDict.empty
                        inferredTypeConstruct.arguments
                        syntaxArguments
                        (\inferredArgument syntaxArgument soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredArgument
                                    syntaxArgument
                                )
                        )

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Record _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecord inferredFields ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.Record syntaxFields ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredFields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericRecord _ (Elm.Syntax.Node.Node _ syntaxFields) ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredFields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension inferredTypeRecordExtension ->
            case syntaxType of
                Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ syntaxRecordVariable) (Elm.Syntax.Node.Node _ syntaxFields) ->
                    FastDict.merge
                        (\_ _ soFar -> soFar)
                        (\_ inferredFieldValue syntaxFieldValue soFar ->
                            FastDict.union soFar
                                (createSynchronizationFromInferredTypeVariableToSyntaxTypeVariable
                                    inferredFieldValue
                                    syntaxFieldValue
                                )
                        )
                        (\_ _ soFar -> soFar)
                        inferredTypeRecordExtension.fields
                        (syntaxFields
                            |> List.foldl
                                (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                    soFar |> FastDict.insert fieldName fieldValue
                                )
                                FastDict.empty
                        )
                        (FastDict.singleton
                            inferredTypeRecordExtension.recordVariable.name
                            syntaxRecordVariable
                        )

                Elm.Syntax.TypeAnnotation.Record _ ->
                    -- invalid type inference
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Typed _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Tupled _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.Unit ->
                    FastDict.empty

                Elm.Syntax.TypeAnnotation.GenericType _ ->
                    FastDict.empty


type MoonbitTypeVariableSpecialization
    = MoonbitTypeVariableSpecializationToInt
    | MoonbitTypeVariableSpecializationToFloat
    | MoonbitTypeVariableSpecializationToRecord (List String)


inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes :
    { allElmRecords : FastSet.Set (List String) }
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String (List MoonbitTypeVariableSpecialization)
inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            if variable.name |> String.startsWith "number" then
                FastDict.singleton variable.name
                    moonbitTypeVariableSpecializationsToIntAndFloat

            else
                FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes
                context
                inferredTypeNotVariable


moonbitTypeVariableSpecializationsToIntAndFloat : List MoonbitTypeVariableSpecialization
moonbitTypeVariableSpecializationsToIntAndFloat =
    [ MoonbitTypeVariableSpecializationToInt
    , MoonbitTypeVariableSpecializationToFloat
    ]


inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes :
    { allElmRecords : FastSet.Set (List String) }
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> FastDict.Dict String (List MoonbitTypeVariableSpecialization)
inferredTypeNotVariableWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            (typeFunction.input |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context)
                |> FastDict.union
                    (typeFunction.output |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            (parts.part0 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context)
                |> FastDict.union
                    (parts.part1 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context)

        ElmSyntaxTypeInfer.TypeTriple parts ->
            (parts.part0 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context)
                |> FastDict.union
                    (parts.part1 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context)
                |> FastDict.union
                    (parts.part2 |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context)

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> listMapToFastDictsAndUnify
                    (\argument ->
                        argument |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context
                    )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context)
                    )
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            typeRecordExtension.fields
                |> FastDict.foldl
                    (\_ value soFar ->
                        FastDict.union soFar
                            (value |> inferredTypeWithExpandedInnerAliasesSplitIntoSpecializedMoonbitTypes context)
                    )
                    FastDict.empty
                |> FastDict.insert typeRecordExtension.recordVariable.name
                    (context.allElmRecords
                        |> FastSet.foldl
                            (\elmRecord moonbitRecordsThatContainAllSyntaxFieldsSoFar ->
                                if
                                    typeRecordExtension.fields
                                        |> fastDictAll
                                            (\fieldName _ ->
                                                elmRecord |> List.member fieldName
                                            )
                                then
                                    MoonbitTypeVariableSpecializationToRecord elmRecord
                                        :: moonbitRecordsThatContainAllSyntaxFieldsSoFar

                                else
                                    moonbitRecordsThatContainAllSyntaxFieldsSoFar
                            )
                            []
                    )


listFoldl2From :
    state
    -> List a
    -> List b
    -> (a -> b -> state -> state)
    -> state
listFoldl2From initialState aList bList reduce =
    case aList of
        [] ->
            initialState

        aHead :: aTail ->
            case bList of
                [] ->
                    initialState

                bHead :: bTail ->
                    listFoldl2From
                        (reduce aHead bHead initialState)
                        aTail
                        bTail
                        reduce


fastDictAll :
    (comparableKey -> value -> Bool)
    -> FastDict.Dict comparableKey value
    -> Bool
fastDictAll keyValueToIsUsual fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                soFar && keyValueToIsUsual key value
            )
            True


fastDictAny :
    (comparableKey -> value -> Bool)
    -> FastDict.Dict comparableKey value
    -> Bool
fastDictAny keyValueToIsUsual fastDict =
    fastDict
        |> FastDict.foldl
            (\key value soFar ->
                soFar || keyValueToIsUsual key value
            )
            False


syntaxTypeNodeApplySpecialization :
    FastDict.Dict String MoonbitTypeVariableSpecialization
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeNodeApplySpecialization specialization syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType
                    |> syntaxTypeApplySpecialization
                        specialization
            )


syntaxTypeBasicsInt : Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeBasicsInt =
    Elm.Syntax.TypeAnnotation.Typed
        (Elm.Syntax.Node.empty ( [ "Basics" ], "Int" ))
        []


syntaxTypeBasicsFloat : Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeBasicsFloat =
    Elm.Syntax.TypeAnnotation.Typed
        (Elm.Syntax.Node.empty ( [ "Basics" ], "Float" ))
        []


syntaxTypeApplySpecialization :
    FastDict.Dict String MoonbitTypeVariableSpecialization
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
syntaxTypeApplySpecialization specialization syntaxType =
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case specialization |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just specificSpecialization ->
                    case specificSpecialization of
                        MoonbitTypeVariableSpecializationToInt ->
                            syntaxTypeBasicsInt

                        MoonbitTypeVariableSpecializationToFloat ->
                            syntaxTypeBasicsFloat

                        MoonbitTypeVariableSpecializationToRecord fields ->
                            Elm.Syntax.TypeAnnotation.Record
                                (fields
                                    |> List.map
                                        (\fieldName ->
                                            Elm.Syntax.Node.empty
                                                ( Elm.Syntax.Node.empty fieldName
                                                , Elm.Syntax.Node.empty
                                                    (Elm.Syntax.TypeAnnotation.GenericType
                                                        ((variable ++ "_" ++ fieldName)
                                                            |> toSnakeCaseMoonbitName
                                                        )
                                                    )
                                                )
                                        )
                                )

        Elm.Syntax.TypeAnnotation.Typed reference arguments ->
            Elm.Syntax.TypeAnnotation.Typed reference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> syntaxTypeNodeApplySpecialization specialization
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, valueNode ) ->
                                        ( nameNode
                                        , valueNode
                                            |> syntaxTypeNodeApplySpecialization specialization
                                        )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node recordVariableRange recordVariableName) (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                fieldsSpecialized : List (Elm.Syntax.Node.Node ( Elm.Syntax.Node.Node String, Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation ))
                fieldsSpecialized =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, valueNode ) ->
                                            ( nameNode
                                            , valueNode
                                                |> syntaxTypeNodeApplySpecialization specialization
                                            )
                                        )
                            )
            in
            case specialization |> FastDict.get recordVariableName of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord
                        (Elm.Syntax.Node.Node recordVariableRange recordVariableName)
                        (Elm.Syntax.Node.Node fieldsRange fieldsSpecialized)

                Just specificSpecialization ->
                    case specificSpecialization of
                        MoonbitTypeVariableSpecializationToInt ->
                            Elm.Syntax.TypeAnnotation.Record
                                fieldsSpecialized

                        MoonbitTypeVariableSpecializationToFloat ->
                            Elm.Syntax.TypeAnnotation.Record
                                fieldsSpecialized

                        MoonbitTypeVariableSpecializationToRecord allFields ->
                            let
                                additionalFields :
                                    List
                                        (Elm.Syntax.Node.Node
                                            ( Elm.Syntax.Node.Node String
                                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                                            )
                                        )
                                additionalFields =
                                    allFields
                                        |> List.filterMap
                                            (\specializationFieldName ->
                                                if
                                                    fields
                                                        |> List.any
                                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, _ )) ->
                                                                fieldName == specializationFieldName
                                                            )
                                                then
                                                    Nothing

                                                else
                                                    Just
                                                        (Elm.Syntax.Node.empty
                                                            ( Elm.Syntax.Node.empty specializationFieldName
                                                            , Elm.Syntax.Node.empty
                                                                (Elm.Syntax.TypeAnnotation.GenericType
                                                                    ((recordVariableName ++ "_" ++ specializationFieldName)
                                                                        |> toSnakeCaseMoonbitName
                                                                    )
                                                                )
                                                            )
                                                        )
                                            )
                            in
                            Elm.Syntax.TypeAnnotation.Record
                                (fieldsSpecialized
                                    ++ additionalFields
                                )

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> syntaxTypeNodeApplySpecialization specialization)
                (outType |> syntaxTypeNodeApplySpecialization specialization)


typeNodeExpand :
    FastDict.Dict String Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
typeNodeExpand expansions syntaxTypeNode =
    syntaxTypeNode
        |> Elm.Syntax.Node.map
            (\syntaxType ->
                syntaxType |> typeExpand expansions
            )


{-| *Caution!* only use when resulting type construct qualification does not matter
-}
inferredTypeToSyntax :
    Elm.Syntax.Range.Range
    -> ElmSyntaxTypeInfer.Type
    -> Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
inferredTypeToSyntax rootRange inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            Elm.Syntax.Node.Node rootRange
                (Elm.Syntax.TypeAnnotation.GenericType variable.name)

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            Elm.Syntax.Node.Node rootRange
                (inferredTypeNotVariableToSyntax rootRange inferredTypeNotVariable)


{-| *Caution!* only use when resulting type construct qualification does not matter
-}
inferredTypeNotVariableToSyntax :
    Elm.Syntax.Range.Range
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
inferredTypeNotVariableToSyntax rootRange inferredTypeNotVariable =
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            Elm.Syntax.TypeAnnotation.Unit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (typeFunction.input |> inferredTypeToSyntax rootRange)
                (typeFunction.output |> inferredTypeToSyntax rootRange)

        ElmSyntaxTypeInfer.TypeTuple parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                [ parts.part0 |> inferredTypeToSyntax rootRange
                , parts.part1 |> inferredTypeToSyntax rootRange
                ]

        ElmSyntaxTypeInfer.TypeTriple parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                [ parts.part0 |> inferredTypeToSyntax rootRange
                , parts.part1 |> inferredTypeToSyntax rootRange
                , parts.part2 |> inferredTypeToSyntax rootRange
                ]

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            Elm.Syntax.TypeAnnotation.Typed
                (Elm.Syntax.Node.Node rootRange
                    ( typeConstruct.moduleOrigin |> String.split "."
                    , typeConstruct.name
                    )
                )
                (typeConstruct.arguments
                    |> List.map
                        (\argument ->
                            argument |> inferredTypeToSyntax rootRange
                        )
                )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> FastDict.foldr
                        (\fieldName fieldValue soFar ->
                            Elm.Syntax.Node.Node rootRange
                                ( Elm.Syntax.Node.Node rootRange fieldName
                                , fieldValue |> inferredTypeToSyntax rootRange
                                )
                                :: soFar
                        )
                        []
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            Elm.Syntax.TypeAnnotation.GenericRecord
                (Elm.Syntax.Node.Node rootRange
                    typeRecordExtension.recordVariable.name
                )
                (Elm.Syntax.Node.Node rootRange
                    (typeRecordExtension.fields
                        |> FastDict.foldr
                            (\fieldName fieldValue soFar ->
                                Elm.Syntax.Node.Node rootRange
                                    ( Elm.Syntax.Node.Node rootRange fieldName
                                    , fieldValue |> inferredTypeToSyntax rootRange
                                    )
                                    :: soFar
                            )
                            []
                    )
                )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.

Resulting ranges and type construct qualifications can also be all over the place, don't rely on them

-}
typeExpand :
    FastDict.Dict String Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
    -> Elm.Syntax.TypeAnnotation.TypeAnnotation
typeExpand expansions syntaxType =
    -- IGNORE TCO
    case syntaxType of
        Elm.Syntax.TypeAnnotation.Unit ->
            Elm.Syntax.TypeAnnotation.Unit

        Elm.Syntax.TypeAnnotation.GenericType variable ->
            case expansions |> FastDict.get variable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericType variable

                Just expanded ->
                    expanded

        Elm.Syntax.TypeAnnotation.Tupled parts ->
            Elm.Syntax.TypeAnnotation.Tupled
                (parts
                    |> List.map
                        (\part ->
                            part |> typeNodeExpand expansions
                        )
                )

        Elm.Syntax.TypeAnnotation.Typed typeReference arguments ->
            Elm.Syntax.TypeAnnotation.Typed typeReference
                (arguments
                    |> List.map
                        (\argument ->
                            argument |> typeNodeExpand expansions
                        )
                )

        Elm.Syntax.TypeAnnotation.Record fields ->
            Elm.Syntax.TypeAnnotation.Record
                (fields
                    |> List.map
                        (\fieldNode ->
                            fieldNode
                                |> Elm.Syntax.Node.map
                                    (\( nameNode, value ) ->
                                        ( nameNode, value |> typeNodeExpand expansions )
                                    )
                        )
                )

        Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode (Elm.Syntax.Node.Node fieldsRange fields) ->
            let
                (Elm.Syntax.Node.Node recordVariableRange recordVariable) =
                    recordVariableNode

                fieldsExpanded :
                    List
                        (Elm.Syntax.Node.Node
                            ( Elm.Syntax.Node.Node String
                            , Elm.Syntax.Node.Node Elm.Syntax.TypeAnnotation.TypeAnnotation
                            )
                        )
                fieldsExpanded =
                    fields
                        |> List.map
                            (\fieldNode ->
                                fieldNode
                                    |> Elm.Syntax.Node.map
                                        (\( nameNode, value ) ->
                                            ( nameNode, value |> typeNodeExpand expansions )
                                        )
                            )
            in
            case expansions |> FastDict.get recordVariable of
                Nothing ->
                    Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                        (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                Just expanded ->
                    case expanded of
                        Elm.Syntax.TypeAnnotation.Unit ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation _ _ ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.Tupled _ ->
                            -- invalid expansion
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.GenericType expandedRecordVariable ->
                            Elm.Syntax.TypeAnnotation.GenericRecord
                                (Elm.Syntax.Node.Node recordVariableRange expandedRecordVariable)
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

                        Elm.Syntax.TypeAnnotation.Record expandedFields ->
                            -- i think in reality this might keep the old field types
                            Elm.Syntax.TypeAnnotation.Record expandedFields

                        Elm.Syntax.TypeAnnotation.GenericRecord (Elm.Syntax.Node.Node _ expandedRecordVariable) (Elm.Syntax.Node.Node _ expandedFields) ->
                            Elm.Syntax.TypeAnnotation.GenericRecord
                                (Elm.Syntax.Node.Node recordVariableRange expandedRecordVariable)
                                (Elm.Syntax.Node.Node fieldsRange
                                    (expandedFields
                                        |> List.foldl
                                            (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ expandedFieldName, expandedFieldValue )) soFar ->
                                                if soFar |> FastDict.member expandedFieldName then
                                                    soFar

                                                else
                                                    soFar |> FastDict.insert expandedFieldName expandedFieldValue
                                            )
                                            (fields
                                                |> List.foldl
                                                    (\(Elm.Syntax.Node.Node _ ( Elm.Syntax.Node.Node _ fieldName, fieldValue )) soFar ->
                                                        soFar |> FastDict.insert fieldName fieldValue
                                                    )
                                                    FastDict.empty
                                            )
                                        |> FastDict.foldr
                                            (\name value soFar ->
                                                Elm.Syntax.Node.Node fieldsRange
                                                    ( Elm.Syntax.Node.Node fieldsRange name
                                                    , value
                                                    )
                                                    :: soFar
                                            )
                                            []
                                    )
                                )

                        Elm.Syntax.TypeAnnotation.Typed _ _ ->
                            Elm.Syntax.TypeAnnotation.GenericRecord recordVariableNode
                                (Elm.Syntax.Node.Node fieldsRange fieldsExpanded)

        Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation inType outType ->
            Elm.Syntax.TypeAnnotation.FunctionTypeAnnotation
                (inType |> typeNodeExpand expansions)
                (outType |> typeNodeExpand expansions)


inferredTypeExpand :
    FastDict.Dict String ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeExpand expansions inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable variable ->
            case expansions |> FastDict.get variable.name of
                Nothing ->
                    ElmSyntaxTypeInfer.TypeVariable variable

                Just expanded ->
                    expanded

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (inferredTypeNotVariable
                    |> inferredTypeNotVariableExpand expansions
                )


inferredTypeNotVariableExpand :
    FastDict.Dict String ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.TypeNotVariable
inferredTypeNotVariableExpand expansions syntaxType =
    -- IGNORE TCO
    case syntaxType of
        ElmSyntaxTypeInfer.TypeUnit ->
            ElmSyntaxTypeInfer.TypeUnit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            ElmSyntaxTypeInfer.TypeFunction
                { input = typeFunction.input |> inferredTypeExpand expansions
                , output = typeFunction.output |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeTuple parts ->
            ElmSyntaxTypeInfer.TypeTuple
                { part0 = parts.part0 |> inferredTypeExpand expansions
                , part1 = parts.part1 |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeTriple parts ->
            ElmSyntaxTypeInfer.TypeTriple
                { part0 = parts.part0 |> inferredTypeExpand expansions
                , part1 = parts.part1 |> inferredTypeExpand expansions
                , part2 = parts.part2 |> inferredTypeExpand expansions
                }

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            ElmSyntaxTypeInfer.TypeConstruct
                { moduleOrigin = typeConstruct.moduleOrigin
                , name = typeConstruct.name
                , arguments =
                    typeConstruct.arguments
                        |> List.map
                            (\value ->
                                value |> inferredTypeExpand expansions
                            )
                }

        ElmSyntaxTypeInfer.TypeRecord fields ->
            ElmSyntaxTypeInfer.TypeRecord
                (fields
                    |> FastDict.map
                        (\_ value ->
                            value |> inferredTypeExpand expansions
                        )
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            let
                fieldsExpanded : FastDict.Dict String ElmSyntaxTypeInfer.Type
                fieldsExpanded =
                    typeRecordExtension.fields
                        |> FastDict.map
                            (\_ value ->
                                value |> inferredTypeExpand expansions
                            )
            in
            case expansions |> FastDict.get typeRecordExtension.recordVariable.name of
                Nothing ->
                    ElmSyntaxTypeInfer.TypeRecordExtension
                        { recordVariable = typeRecordExtension.recordVariable
                        , fields = fieldsExpanded
                        }

                Just expanded ->
                    case expanded of
                        ElmSyntaxTypeInfer.TypeVariable expandedRecordVariable ->
                            ElmSyntaxTypeInfer.TypeRecordExtension
                                { recordVariable = expandedRecordVariable
                                , fields = fieldsExpanded
                                }

                        ElmSyntaxTypeInfer.TypeNotVariable expandedTypeNotVariable ->
                            case expandedTypeNotVariable of
                                ElmSyntaxTypeInfer.TypeUnit ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeFunction _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeTuple _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeTriple _ ->
                                    -- invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeRecord expandedFields ->
                                    ElmSyntaxTypeInfer.TypeRecord
                                        (FastDict.union
                                            typeRecordExtension.fields
                                            expandedFields
                                        )

                                ElmSyntaxTypeInfer.TypeConstruct _ ->
                                    -- should already be expanded, which means it is a choice type
                                    --  invalid expansion
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = typeRecordExtension.recordVariable
                                        , fields = fieldsExpanded
                                        }

                                ElmSyntaxTypeInfer.TypeRecordExtension expandedRecordExtension ->
                                    ElmSyntaxTypeInfer.TypeRecordExtension
                                        { recordVariable = expandedRecordExtension.recordVariable
                                        , fields =
                                            FastDict.union
                                                typeRecordExtension.fields
                                                expandedRecordExtension.fields
                                        }


{-| Make sure to expand inner aliases first
-}
inferredTypeContainsExtensibleRecord : ElmSyntaxTypeInfer.Type -> Bool
inferredTypeContainsExtensibleRecord inferredType =
    case inferredType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            False

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableContainsExtensibleRecord
                inferredTypeNotVariable


{-| Make sure to expand inner aliases first
-}
inferredTypeNotVariableContainsExtensibleRecord : ElmSyntaxTypeInfer.TypeNotVariable -> Bool
inferredTypeNotVariableContainsExtensibleRecord inferredTypeNotVariable =
    -- IGNORE TCO
    case inferredTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            False

        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
            True

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            inferredTypeContainsExtensibleRecord
                typeFunction.input
                || inferredTypeContainsExtensibleRecord
                    typeFunction.output

        ElmSyntaxTypeInfer.TypeTuple parts ->
            inferredTypeContainsExtensibleRecord
                parts.part0
                || inferredTypeContainsExtensibleRecord
                    parts.part1

        ElmSyntaxTypeInfer.TypeTriple parts ->
            inferredTypeContainsExtensibleRecord
                parts.part0
                || inferredTypeContainsExtensibleRecord
                    parts.part1
                || inferredTypeContainsExtensibleRecord
                    parts.part2

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            typeConstruct.arguments
                |> List.any inferredTypeContainsExtensibleRecord

        ElmSyntaxTypeInfer.TypeRecord fields ->
            fields
                |> fastDictAny
                    (\_ fieldValue ->
                        fieldValue |> inferredTypeContainsExtensibleRecord
                    )


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.
-}
inferredTypeExpandInnerAliases :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeExpandInnerAliases typeAliasesInModule syntaxType =
    case syntaxType of
        ElmSyntaxTypeInfer.TypeVariable _ ->
            syntaxType

        ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable ->
            inferredTypeNotVariableExpandInnerAliases typeAliasesInModule
                inferredTypeNotVariable


{-| Caution! This is only an approximation that's good enough for
resolving type aliases for specialization but not much else.
-}
inferredTypeNotVariableExpandInnerAliases :
    (String
     ->
        Maybe
            (FastDict.Dict
                String
                { parameters : List String
                , recordFieldOrder : Maybe (List String)
                , type_ : ElmSyntaxTypeInfer.Type
                }
            )
    )
    -> ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.Type
inferredTypeNotVariableExpandInnerAliases typeAliasesInModule syntaxType =
    -- IGNORE TCO
    case syntaxType of
        ElmSyntaxTypeInfer.TypeUnit ->
            inferredTypeUnit

        ElmSyntaxTypeInfer.TypeFunction typeFunction ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = typeFunction.input |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , output = typeFunction.output |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeTuple parts ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeTuple
                    { part0 = parts.part0 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part1 = parts.part1 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeTriple parts ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeTriple
                    { part0 = parts.part0 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part1 = parts.part1 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    , part2 = parts.part2 |> inferredTypeExpandInnerAliases typeAliasesInModule
                    }
                )

        ElmSyntaxTypeInfer.TypeRecord fields ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeRecord
                    (fields
                        |> FastDict.map
                            (\_ value ->
                                value |> inferredTypeExpandInnerAliases typeAliasesInModule
                            )
                    )
                )

        ElmSyntaxTypeInfer.TypeRecordExtension typeRecordExtension ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeRecordExtension
                    { recordVariable = typeRecordExtension.recordVariable
                    , fields =
                        typeRecordExtension.fields
                            |> FastDict.map
                                (\_ value ->
                                    value |> inferredTypeExpandInnerAliases typeAliasesInModule
                                )
                    }
                )

        ElmSyntaxTypeInfer.TypeConstruct typeConstruct ->
            let
                argumentsExpanded : List ElmSyntaxTypeInfer.Type
                argumentsExpanded =
                    typeConstruct.arguments
                        |> List.map
                            (\argument ->
                                argument |> inferredTypeExpandInnerAliases typeAliasesInModule
                            )
            in
            case
                typeAliasesInModule typeConstruct.moduleOrigin
                    |> Maybe.andThen (\byName -> byName |> FastDict.get typeConstruct.name)
            of
                Just aliasedType ->
                    aliasedType.type_
                        |> inferredTypeExpand
                            (listFoldl2From FastDict.empty
                                aliasedType.parameters
                                argumentsExpanded
                                (\parameter argument soFar ->
                                    soFar |> FastDict.insert parameter argument
                                )
                            )

                Nothing ->
                    ElmSyntaxTypeInfer.TypeNotVariable
                        (ElmSyntaxTypeInfer.TypeConstruct
                            { moduleOrigin = typeConstruct.moduleOrigin
                            , name = typeConstruct.name
                            , arguments = argumentsExpanded
                            }
                        )


inferredTypeUnit : ElmSyntaxTypeInfer.Type
inferredTypeUnit =
    ElmSyntaxTypeInfer.TypeNotVariable
        ElmSyntaxTypeInfer.TypeUnit


{-| moonbit does not have a concept of the following elm types:

  - `number` type variable
  - `{ extendedRecord | some : field }' extended record

to accommodate, we split elm values/functions that use these in their annotation
into specialized moonbit functions. For example

    Array.Extra.sum : Array number -> number

will be split into and used as

    let ArrayExtra_sum__number_Int : array<int64> -> int64
    let ArrayExtra_sum__number_Float : array<double> -> double

and similarly

    Fields.setX : x -> { p | x : x } -> { p | x : x }
    --
    type alias Point = { x : Int, y : Int }
    someOtherUsage = Fields.setX 3.0 { x = 0, y = 0, z = 0 }

will be split into and used as

    fn fields_set_x_p_x_y<X, PY>(:X, :GeneratedXY<X, PY>) -> GeneratedXY<X, PY>
    fn fields_set_x_p_x_y_z<X, PY, PZ>(:X, :GeneratedXYZ<x, PY, PZ>) -> GeneratedXYZ<x, PY, PZ>

for all elm records in types and expressions that contain the field `x`

These specializations can also stack.

-}
moonbitNameWithSpecializedTypes :
    FastDict.Dict String MoonbitTypeVariableSpecialization
    -> String
    -> String
moonbitNameWithSpecializedTypes specializedTypes name =
    specializedTypes
        |> FastDict.foldl
            (\variable specializedType nameSoFar ->
                nameSoFar
                    ++ "_"
                    ++ variable
                    ++ "_"
                    ++ (case specializedType of
                            MoonbitTypeVariableSpecializationToInt ->
                                "int"

                            MoonbitTypeVariableSpecializationToFloat ->
                                "float"

                            MoonbitTypeVariableSpecializationToRecord specializedTypeRecordFields ->
                                case specializedTypeRecordFields of
                                    [] ->
                                        ""

                                    specializedTypeRecordField0 :: specializedTypeRecordField1Up ->
                                        listFilledMapAndStringJoinWith "_"
                                            toSnakeCaseMoonbitName
                                            specializedTypeRecordField0
                                            specializedTypeRecordField1Up
                       )
            )
            name


{-| Which variables of a type are more concrete in the inferred type
-}
inferredTypeSpecializedVariablesFrom :
    ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String MoonbitTypeVariableSpecialization
inferredTypeSpecializedVariablesFrom originalInferredType specializedInferredType =
    -- IGNORE TCO
    case originalInferredType of
        ElmSyntaxTypeInfer.TypeVariable originalVariable ->
            if originalVariable.name |> String.startsWith "number" then
                case specializedInferredType of
                    ElmSyntaxTypeInfer.TypeVariable _ ->
                        FastDict.empty

                    ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                        case inferredTypeNotVariable_ of
                            ElmSyntaxTypeInfer.TypeConstruct specializedTypeConstruct ->
                                case specializedTypeConstruct.moduleOrigin of
                                    "Basics" ->
                                        case specializedTypeConstruct.name of
                                            "Int" ->
                                                FastDict.singleton originalVariable.name
                                                    MoonbitTypeVariableSpecializationToInt

                                            "Float" ->
                                                FastDict.singleton originalVariable.name
                                                    MoonbitTypeVariableSpecializationToFloat

                                            _ ->
                                                FastDict.empty

                                    _ ->
                                        FastDict.empty

                            ElmSyntaxTypeInfer.TypeUnit ->
                                FastDict.empty

                            ElmSyntaxTypeInfer.TypeTuple _ ->
                                FastDict.empty

                            ElmSyntaxTypeInfer.TypeTriple _ ->
                                FastDict.empty

                            ElmSyntaxTypeInfer.TypeRecord _ ->
                                FastDict.empty

                            ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                                FastDict.empty

                            ElmSyntaxTypeInfer.TypeFunction _ ->
                                FastDict.empty

            else
                FastDict.empty

        ElmSyntaxTypeInfer.TypeNotVariable originalTypeNotVariable ->
            inferredTypeSpecializedVariablesFromNotVariable
                originalTypeNotVariable
                specializedInferredType


inferredTypeSpecializedVariablesFromNotVariable :
    ElmSyntaxTypeInfer.TypeNotVariable
    -> ElmSyntaxTypeInfer.Type
    -> FastDict.Dict String MoonbitTypeVariableSpecialization
inferredTypeSpecializedVariablesFromNotVariable originalTypeNotVariable specializedInferredType =
    case originalTypeNotVariable of
        ElmSyntaxTypeInfer.TypeUnit ->
            FastDict.empty

        ElmSyntaxTypeInfer.TypeFunction originalTypeFunction ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeFunction inferredFunction) ->
                    inferredTypeSpecializedVariablesFrom
                        originalTypeFunction.input
                        inferredFunction.input
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalTypeFunction.output
                                inferredFunction.output
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTuple originalParts ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTuple inferredTuple) ->
                    inferredTypeSpecializedVariablesFrom
                        originalParts.part0
                        inferredTuple.part0
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part1
                                inferredTuple.part1
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeTriple originalParts ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeTriple inferredTriple) ->
                    inferredTypeSpecializedVariablesFrom
                        originalParts.part0
                        inferredTriple.part0
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part1
                                inferredTriple.part1
                            )
                        |> FastDict.union
                            (inferredTypeSpecializedVariablesFrom
                                originalParts.part2
                                inferredTriple.part2
                            )

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeConstruct originalTypeConstruct ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty

                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeConstruct inferredTypeConstruct ->
                            List.map2 inferredTypeSpecializedVariablesFrom
                                originalTypeConstruct.arguments
                                inferredTypeConstruct.arguments
                                |> listOfFastDictsUnify

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecordExtension _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

        ElmSyntaxTypeInfer.TypeRecord originalFields ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable (ElmSyntaxTypeInfer.TypeRecord inferredRecord) ->
                    List.map2 inferredTypeSpecializedVariablesFrom
                        (originalFields |> FastDict.values)
                        (inferredRecord |> FastDict.values)
                        |> listOfFastDictsUnify

                _ ->
                    -- incorrectly inferred
                    FastDict.empty

        ElmSyntaxTypeInfer.TypeRecordExtension originalTypeRecordExtension ->
            case specializedInferredType of
                ElmSyntaxTypeInfer.TypeNotVariable inferredTypeNotVariable_ ->
                    case inferredTypeNotVariable_ of
                        ElmSyntaxTypeInfer.TypeRecordExtension inferredRecordExtension ->
                            FastDict.merge
                                (\_ _ soFar -> soFar)
                                (\_ originalValue specializedValue soFar ->
                                    FastDict.union soFar
                                        (inferredTypeSpecializedVariablesFrom originalValue specializedValue)
                                )
                                (\_ _ soFar -> soFar)
                                originalTypeRecordExtension.fields
                                inferredRecordExtension.fields
                                FastDict.empty

                        ElmSyntaxTypeInfer.TypeRecord inferredRecordFields ->
                            FastDict.merge
                                (\_ _ soFar -> soFar)
                                (\_ originalValue specializedValue soFar ->
                                    FastDict.union soFar
                                        (inferredTypeSpecializedVariablesFrom originalValue specializedValue)
                                )
                                (\_ _ soFar -> soFar)
                                originalTypeRecordExtension.fields
                                inferredRecordFields
                                FastDict.empty
                                |> FastDict.insert originalTypeRecordExtension.recordVariable.name
                                    (MoonbitTypeVariableSpecializationToRecord
                                        (inferredRecordFields |> FastDict.keys)
                                    )

                        ElmSyntaxTypeInfer.TypeUnit ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeConstruct _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTuple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeTriple _ ->
                            FastDict.empty

                        ElmSyntaxTypeInfer.TypeFunction _ ->
                            FastDict.empty

                ElmSyntaxTypeInfer.TypeVariable _ ->
                    -- incorrectly inferred
                    FastDict.empty


qualifiedMoonbitReferenceToString :
    { qualification : List String
    , name : String
    }
    -> String
qualifiedMoonbitReferenceToString reference =
    case reference.qualification of
        [] ->
            reference.name

        qualificationPart0 :: qualificationPart1Up ->
            "@"
                ++ ((qualificationPart0 :: qualificationPart1Up) |> String.join "/")
                ++ "."
                ++ reference.name


qualifiedMoonbitVariantReferenceToString :
    { originTypeName : List String
    , name : String
    }
    -> String
qualifiedMoonbitVariantReferenceToString reference =
    case reference.originTypeName of
        [] ->
            reference.name

        [ originTypeName ] ->
            originTypeName
                ++ "::"
                ++ reference.name

        qualificationPart0 :: qualificationPart1 :: qualificationPart2UpAndOriginTypeName ->
            let
                qualificationPart1UpAndOriginTypeName : { beforeLast : List String, last : String }
                qualificationPart1UpAndOriginTypeName =
                    listSplitOffLast ( qualificationPart1, qualificationPart2UpAndOriginTypeName )
            in
            "@"
                ++ ((qualificationPart0 :: qualificationPart1UpAndOriginTypeName.beforeLast)
                        |> String.join "/"
                   )
                ++ "."
                ++ qualificationPart1UpAndOriginTypeName.last
                ++ "::"
                ++ reference.name


listSplitOffLast : ( a, List a ) -> { beforeLast : List a, last : a }
listSplitOffLast ( head, tail ) =
    listSplitOffLastInto { beforeLastReverse = [], last = head } tail


listSplitOffLastInto : { beforeLastReverse : List a, last : a } -> List a -> { beforeLast : List a, last : a }
listSplitOffLastInto soFar list =
    case list of
        [] ->
            { last = soFar.last
            , beforeLast = soFar.beforeLastReverse |> List.reverse
            }

        head :: tail ->
            listSplitOffLastInto
                { last = head
                , beforeLastReverse = soFar.last :: soFar.beforeLastReverse
                }
                tail


printMoonbitExpressionParenthesizedIfSpaceSeparated : MoonbitExpression -> Print
printMoonbitExpressionParenthesizedIfSpaceSeparated moonbitExpression =
    let
        notParenthesizedPrint : Print
        notParenthesizedPrint =
            printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                moonbitExpression
    in
    case moonbitExpression of
        MoonbitExpressionUnit ->
            notParenthesizedPrint

        MoonbitExpressionChar _ ->
            notParenthesizedPrint

        MoonbitExpressionInt64 _ ->
            notParenthesizedPrint

        MoonbitExpressionDouble _ ->
            notParenthesizedPrint

        MoonbitExpressionString _ ->
            notParenthesizedPrint

        MoonbitExpressionSelf ->
            notParenthesizedPrint

        MoonbitExpressionReference _ ->
            notParenthesizedPrint

        MoonbitExpressionReferenceVariant _ ->
            notParenthesizedPrint

        MoonbitExpressionReferenceMethod _ ->
            notParenthesizedPrint

        MoonbitExpressionNegateOperation _ ->
            notParenthesizedPrint

        MoonbitExpressionStructAccess _ ->
            notParenthesizedPrint

        MoonbitExpressionTuple _ ->
            notParenthesizedPrint

        MoonbitExpressionArrayLiteral _ ->
            notParenthesizedPrint

        MoonbitExpressionStruct _ ->
            notParenthesizedPrint

        MoonbitExpressionCall _ ->
            notParenthesizedPrint

        MoonbitExpressionAs _ ->
            printParenthesized notParenthesizedPrint

        MoonbitExpressionBinaryOperation _ ->
            printParenthesized notParenthesizedPrint

        MoonbitExpressionIfElse _ ->
            printParenthesized notParenthesizedPrint

        MoonbitExpressionMatch _ ->
            printParenthesized notParenthesizedPrint

        MoonbitExpressionClosure _ ->
            printParenthesized notParenthesizedPrint

        MoonbitExpressionAfterStatement _ ->
            printCurlyEmbraced notParenthesizedPrint


{-| Print a [`MoonbitExpression`](#MoonbitExpression)
-}
printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement : MoonbitExpression -> Print
printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement moonbitExpression =
    -- IGNORE TCO
    case moonbitExpression of
        MoonbitExpressionUnit ->
            Print.exactly "()"

        MoonbitExpressionChar charValue ->
            printMoonbitCharLiteral charValue

        MoonbitExpressionInt64 int ->
            Print.exactly (int |> int64Literal)

        MoonbitExpressionDouble double ->
            Print.exactly (double |> doubleLiteral)

        MoonbitExpressionString string ->
            printMoonbitStringLiteral string

        MoonbitExpressionSelf ->
            printMoonbitExpressionSelf

        MoonbitExpressionReference reference ->
            Print.exactly
                (reference |> qualifiedMoonbitReferenceToString)

        MoonbitExpressionReferenceVariant reference ->
            Print.exactly
                (qualifiedMoonbitVariantReferenceToString reference)

        MoonbitExpressionReferenceMethod reference ->
            printMoonbitExpressionParenthesizedIfSpaceSeparated
                reference.subject
                |> Print.followedBy
                    (Print.exactly
                        ("." ++ reference.method)
                    )

        MoonbitExpressionCall call ->
            printMoonbitExpressionCall call

        MoonbitExpressionBinaryOperation binaryOperation ->
            let
                leftPrint : Print
                leftPrint =
                    printMoonbitExpressionParenthesizedIfSpaceSeparated
                        binaryOperation.left

                rightPrint : Print
                rightPrint =
                    printMoonbitExpressionParenthesizedIfSpaceSeparated
                        binaryOperation.right

                lineSpread : Print.LineSpread
                lineSpread =
                    leftPrint
                        |> Print.lineSpread
                        |> Print.lineSpreadMergeWith
                            (\() -> rightPrint |> Print.lineSpread)
            in
            leftPrint
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        lineSpread
                    )
                |> Print.followedBy
                    (Print.exactly binaryOperation.operator)
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.spaceOrLinebreakIndented
                            lineSpread
                            |> Print.followedBy rightPrint
                        )
                    )

        MoonbitExpressionIfElse ifElse ->
            printMoonbitExpressionIfElse ifElse

        MoonbitExpressionTuple parts ->
            printMoonbitExpressionTuple parts

        MoonbitExpressionClosure moonbitClosure ->
            printMoonbitExpressionClosure moonbitClosure

        MoonbitExpressionAfterStatement moonbitExpressionAfterStatement ->
            printMoonbitExpressionAfterStatement moonbitExpressionAfterStatement

        MoonbitExpressionStruct moonbitExpressionStruct ->
            printMoonbitExpressionStruct moonbitExpressionStruct

        MoonbitExpressionArrayLiteral elements ->
            printMoonbitExpressionArrayLiteral elements

        MoonbitExpressionNegateOperation inNegation ->
            printExactlyMinus
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 1
                        (printMoonbitExpressionParenthesizedIfSpaceSeparated
                            inNegation
                        )
                    )

        MoonbitExpressionStructAccess syntaxRecordAccess ->
            printMoonbitExpressionParenthesizedIfSpaceSeparated
                syntaxRecordAccess.struct
                |> Print.followedBy
                    (Print.exactly
                        ("." ++ syntaxRecordAccess.field)
                    )

        MoonbitExpressionAs moonbitExpressionAs ->
            printMoonbitExpressionAs moonbitExpressionAs

        MoonbitExpressionMatch match ->
            printMoonbitExpressionMatch match


printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement : MoonbitExpression -> Print
printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement moonbitExpression =
    let
        notCurlyEmbracedPrint : Print
        notCurlyEmbracedPrint =
            printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                moonbitExpression
    in
    case moonbitExpression of
        MoonbitExpressionAfterStatement _ ->
            printCurlyEmbraced notCurlyEmbracedPrint

        _ ->
            notCurlyEmbracedPrint


printMoonbitExpressionAs : { type_ : MoonbitType, expression : MoonbitExpression } -> Print
printMoonbitExpressionAs moonbitExpressionAs =
    let
        typePrint : Print
        typePrint =
            printMoonbitTypeNotParenthesized moonbitExpressionAs.type_
    in
    printMoonbitExpressionParenthesizedIfSpaceSeparated
        moonbitExpressionAs.expression
        |> Print.followedBy
            (Print.exactly " as")
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented
                (typePrint |> Print.lineSpread)
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                typePrint
            )


printMoonbitExpressionSelf : Print
printMoonbitExpressionSelf =
    Print.exactly "self"


printExactlyMinus : Print
printExactlyMinus =
    Print.exactly "-"


printMoonbitExpressionTuple :
    { part0 : MoonbitExpression
    , part1 : MoonbitExpression
    , part2Up : List MoonbitExpression
    }
    -> Print
printMoonbitExpressionTuple parts =
    let
        part0Print : Print
        part0Print =
            printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                parts.part0

        part1Print : Print
        part1Print =
            printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                parts.part1

        part2UpPrints : List Print
        part2UpPrints =
            parts.part2Up
                |> List.map printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement

        lineSpread : Print.LineSpread
        lineSpread =
            part0Print
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() -> part1Print |> Print.lineSpread)
                |> Print.lineSpreadMergeWith
                    (\() ->
                        part2UpPrints
                            |> Print.lineSpreadListMapAndCombine
                                Print.lineSpread
                    )
    in
    printExactlyParenOpening
        |> Print.followedBy
            ((part0Print :: part1Print :: part2UpPrints)
                |> Print.listMapAndIntersperseAndFlatten
                    (\partPrint ->
                        Print.withIndentIncreasedBy 1 partPrint
                    )
                    (Print.emptyOrLinebreakIndented lineSpread
                        |> Print.followedBy
                            printExactlyCommaSpace
                    )
            )
        |> Print.followedBy
            (Print.emptyOrLinebreakIndented lineSpread)
        |> Print.followedBy
            printExactlyParenClosing


printExactlyParenOpeningParenClosing : Print
printExactlyParenOpeningParenClosing =
    Print.exactly "()"


printMoonbitExpressionCall :
    { called : MoonbitExpression
    , arguments : List MoonbitExpression
    }
    -> Print
printMoonbitExpressionCall call =
    let
        calledNotParenthesizedPrint : Print
        calledNotParenthesizedPrint =
            printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                call.called

        calledPrint : Print
        calledPrint =
            case call.called of
                MoonbitExpressionUnit ->
                    calledNotParenthesizedPrint

                MoonbitExpressionChar _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionInt64 _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionDouble _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionString _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionSelf ->
                    calledNotParenthesizedPrint

                MoonbitExpressionReference _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionReferenceVariant _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionReferenceMethod _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionTuple _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionArrayLiteral _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionStruct _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionCall _ ->
                    calledNotParenthesizedPrint

                MoonbitExpressionNegateOperation _ ->
                    printParenthesized calledNotParenthesizedPrint

                MoonbitExpressionStructAccess _ ->
                    printParenthesized calledNotParenthesizedPrint

                MoonbitExpressionAs _ ->
                    printParenthesized calledNotParenthesizedPrint

                MoonbitExpressionBinaryOperation _ ->
                    printParenthesized calledNotParenthesizedPrint

                MoonbitExpressionIfElse _ ->
                    printParenthesized calledNotParenthesizedPrint

                MoonbitExpressionMatch _ ->
                    printParenthesized calledNotParenthesizedPrint

                MoonbitExpressionClosure _ ->
                    printParenthesized calledNotParenthesizedPrint

                MoonbitExpressionAfterStatement _ ->
                    printParenthesized (printCurlyEmbraced calledNotParenthesizedPrint)
    in
    case call.arguments of
        [] ->
            calledPrint
                |> Print.followedBy
                    printExactlyParenOpeningParenClosing

        argument0 :: argument1Up ->
            let
                argumentPrints : List Print
                argumentPrints =
                    (argument0 :: argument1Up)
                        |> List.map printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement

                argumentsLineSpread : Print.LineSpread
                argumentsLineSpread =
                    argumentPrints
                        |> Print.lineSpreadListMapAndCombine Print.lineSpread
            in
            calledPrint
                |> Print.followedBy printExactlyParenOpening
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.emptyOrLinebreakIndented argumentsLineSpread
                            |> Print.followedBy
                                (argumentPrints
                                    |> Print.listIntersperseAndFlatten
                                        (printExactlyComma
                                            |> Print.followedBy
                                                (Print.spaceOrLinebreakIndented argumentsLineSpread)
                                        )
                                )
                        )
                    )
                |> Print.followedBy
                    (Print.emptyOrLinebreakIndented argumentsLineSpread)
                |> Print.followedBy printExactlyParenClosing


printExactlyCommaLinebreakIndented : Print
printExactlyCommaLinebreakIndented =
    Print.exactly ","
        |> Print.followedBy Print.linebreakIndented


printExactlyAngledOpeningSpace : Print
printExactlyAngledOpeningSpace =
    Print.exactly "[ "


printExactlyAngledClosing : Print
printExactlyAngledClosing =
    Print.exactly "]"


printMoonbitExpressionArrayLiteral : List MoonbitExpression -> Print
printMoonbitExpressionArrayLiteral elements =
    case elements of
        [] ->
            printMoonbitExpressionArrayLiteralEmpty

        element0 :: element1Up ->
            let
                elementsPrint : Print
                elementsPrint =
                    (element0 :: element1Up)
                        |> Print.listMapAndIntersperseAndFlatten
                            printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                            printExactlyCommaLinebreakIndented
            in
            printExactlyAngledOpeningSpace
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 2
                        elementsPrint
                    )
                |> Print.followedBy
                    (Print.spaceOrLinebreakIndented
                        (elementsPrint |> Print.lineSpread)
                    )
                |> Print.followedBy
                    printExactlyAngledClosing


printMoonbitExpressionArrayLiteralEmpty : Print
printMoonbitExpressionArrayLiteralEmpty =
    Print.exactly "[]"


printExactlyCurlyOpening : Print
printExactlyCurlyOpening =
    Print.exactly "{"


printMoonbitExpressionClosure :
    { parameters :
        List
            { binding : Maybe String
            , type_ : Maybe MoonbitType
            }
    , resultType : Maybe MoonbitType
    , result : MoonbitExpression
    }
    -> Print
printMoonbitExpressionClosure lambda =
    let
        resultTypePrint : Print
        resultTypePrint =
            case lambda.resultType of
                Nothing ->
                    Print.empty

                Just resultType ->
                    resultType |> printMoonbitTypeNotParenthesized

        resultPrint : Print
        resultPrint =
            printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                lambda.result

        parameterPrints : List Print
        parameterPrints =
            lambda.parameters
                |> List.map
                    (\lambdaParameter ->
                        (case lambdaParameter.binding of
                            Just binding ->
                                Print.exactly binding

                            Nothing ->
                                Print.exactly "_"
                        )
                            |> Print.followedBy
                                (case lambdaParameter.type_ of
                                    Nothing ->
                                        Print.empty

                                    Just parameterType ->
                                        let
                                            parameterTypePrint : Print
                                            parameterTypePrint =
                                                printMoonbitTypeNotParenthesized
                                                    parameterType
                                        in
                                        printExactlyColon
                                            |> Print.followedBy
                                                (Print.withIndentAtNextMultipleOf4
                                                    (Print.spaceOrLinebreakIndented
                                                        (parameterTypePrint |> Print.lineSpread)
                                                        |> Print.followedBy
                                                            parameterTypePrint
                                                    )
                                                )
                                )
                    )

        parametersAndResultTypeLineSpread : Print.LineSpread
        parametersAndResultTypeLineSpread =
            resultTypePrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith
                    (\() ->
                        parameterPrints
                            |> Print.lineSpreadListMapAndCombine Print.lineSpread
                    )

        fullLineSpread : Print.LineSpread
        fullLineSpread =
            resultPrint
                |> Print.lineSpread
                |> Print.lineSpreadMergeWith (\() -> parametersAndResultTypeLineSpread)
    in
    Print.exactly "fn("
        |> Print.followedBy
            (Print.withIndentIncreasedBy 3
                (parameterPrints
                    |> Print.listMapAndIntersperseAndFlatten
                        (\lambdaParameter -> lambdaParameter)
                        (printExactlyComma
                            |> Print.followedBy
                                (Print.spaceOrLinebreakIndented
                                    parametersAndResultTypeLineSpread
                                )
                        )
                    |> Print.followedBy (Print.exactly ")")
                    |> Print.followedBy
                        (case lambda.resultType of
                            Nothing ->
                                Print.empty

                            Just _ ->
                                Print.exactly " ->"
                                    |> Print.followedBy
                                        (Print.spaceOrLinebreakIndented
                                            parametersAndResultTypeLineSpread
                                        )
                                    |> Print.followedBy resultTypePrint
                        )
                    |> Print.followedBy (Print.exactly " {")
                )
            )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented fullLineSpread
                    |> Print.followedBy
                        resultPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented fullLineSpread)
        |> Print.followedBy printExactlyCurlyClosing


printMoonbitExpressionAfterStatement :
    { statement : MoonbitStatement
    , result : MoonbitExpression
    }
    -> Print
printMoonbitExpressionAfterStatement moonbitExpressionAfterStatement =
    printMoonbitStatement moonbitExpressionAfterStatement.statement
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy
            (printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement
                moonbitExpressionAfterStatement.result
            )


printMoonbitExpressionIfElse :
    { condition : MoonbitExpression
    , onTrue : MoonbitExpression
    , onFalse : MoonbitExpression
    }
    -> Print
printMoonbitExpressionIfElse syntaxIfElse =
    let
        conditionPrint : Print
        conditionPrint =
            printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                syntaxIfElse.condition

        conditionLineSpread : Print.LineSpread
        conditionLineSpread =
            conditionPrint |> Print.lineSpread
    in
    printExactlyIf
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented conditionLineSpread
                    |> Print.followedBy conditionPrint
                )
            )
        |> Print.followedBy
            (Print.spaceOrLinebreakIndented conditionLineSpread)
        |> Print.followedBy printExactlyCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement syntaxIfElse.onTrue)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosingSpaceElseSpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printMoonbitExpressionNotParenthesizedNotCurlyEmbracedIfAfterStatement syntaxIfElse.onFalse)
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printExactlyIf : Print
printExactlyIf =
    Print.exactly "if"


printExactlyCurlyClosingSpaceElseSpaceCurlyOpening : Print
printExactlyCurlyClosingSpaceElseSpaceCurlyOpening =
    Print.exactly "} else {"


printExactlyMatch : Print
printExactlyMatch =
    Print.exactly "match"


printMoonbitExpressionMatch :
    { matched : MoonbitExpression
    , cases :
        List
            { pattern : MoonbitPattern
            , guardConditions : List MoonbitExpression
            , result : MoonbitExpression
            }
    }
    -> Print
printMoonbitExpressionMatch moonbitMatch =
    let
        matchedPrint : Print
        matchedPrint =
            printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                moonbitMatch.matched

        matchedPrintLineSpread : Print.LineSpread
        matchedPrintLineSpread =
            matchedPrint |> Print.lineSpread
    in
    printExactlyMatch
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented matchedPrintLineSpread
                    |> Print.followedBy matchedPrint
                )
            )
        |> Print.followedBy printExactlySpaceCurlyOpening
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (moonbitMatch.cases
                            |> Print.listMapAndIntersperseAndFlatten
                                printMoonbitExpressionMatchCase
                                Print.linebreakIndented
                        )
                )
            )
        |> Print.followedBy Print.linebreakIndented
        |> Print.followedBy printExactlyCurlyClosing


printMoonbitExpressionMatchCase :
    { pattern : MoonbitPattern
    , guardConditions : List MoonbitExpression
    , result : MoonbitExpression
    }
    -> Print
printMoonbitExpressionMatchCase arm =
    let
        patternPrint : Print
        patternPrint =
            printMoonbitPattern arm.pattern
    in
    Print.withIndentIncreasedBy 2
        (patternPrint
            |> Print.followedBy
                (printWithMoonbitGuardConditions arm.guardConditions)
        )
        |> Print.followedBy (Print.exactly " =>")
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.linebreakIndented
                    |> Print.followedBy
                        (printMoonbitExpressionParenthesizedIfSpaceSeparated
                            arm.result
                        )
                )
            )


printWithMoonbitGuardConditions : List MoonbitExpression -> Print
printWithMoonbitGuardConditions guardConditions =
    case guardConditions of
        [] ->
            Print.empty

        guardCondition0 :: guardCondition1Up ->
            Print.exactly " if "
                |> Print.followedBy
                    (Print.withIndentIncreasedBy 4
                        ((guardCondition0 :: guardCondition1Up)
                            |> Print.listMapAndIntersperseAndFlatten
                                printMoonbitExpressionParenthesizedIfSpaceSeparated
                                (Print.linebreakIndented
                                    |> Print.followedBy
                                        (Print.exactly " && ")
                                )
                        )
                    )


printMoonbitStatement : MoonbitStatement -> Print
printMoonbitStatement moonbitStatement =
    case moonbitStatement of
        MoonbitStatementLetDestructuring letDestructuring ->
            letDestructuring |> printMoonbitLetDestructuring

        MoonbitStatementFnDeclaration letValueOrFunction ->
            letValueOrFunction |> printMoonbitStatementFnDeclaration

        MoonbitStatementLetDeclaration moonbitLetDeclaration ->
            moonbitLetDeclaration |> printMoonbitStatementLetDeclaration

        MoonbitStatementLetDeclarationUninitialized letDeclarationUnassigned ->
            printMoonbitStatementLetDeclarationUninitialized letDeclarationUnassigned

        MoonbitStatementBindingAssignment assignment ->
            Print.exactly (assignment.name ++ " =")
                |> Print.followedBy
                    (Print.withIndentAtNextMultipleOf4
                        (Print.linebreakIndented
                            |> Print.followedBy
                                (printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                    assignment.assignedValue
                                )
                        )
                    )


printMoonbitStatementLetDeclarationUninitialized :
    { type_ : MoonbitType, name : String }
    -> Print
printMoonbitStatementLetDeclarationUninitialized letDeclarationUnassigned =
    let
        typePrint : Print
        typePrint =
            printMoonbitTypeNotParenthesized
                letDeclarationUnassigned.type_
    in
    Print.exactly
        ("let "
            ++ letDeclarationUnassigned.name
            ++ ":"
        )
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (Print.spaceOrLinebreakIndented
                    (typePrint |> Print.lineSpread)
                    |> Print.followedBy typePrint
                )
            )


printMoonbitLetDestructuring :
    { pattern : MoonbitPattern
    , expression : MoonbitExpression
    }
    -> Print
printMoonbitLetDestructuring letDestructuring =
    printExactlyLetSpace
        |> Print.followedBy
            (Print.withIndentAtNextMultipleOf4
                (letDestructuring.pattern
                    |> printMoonbitPattern
                    |> Print.followedBy printExactlySpaceEquals
                    |> Print.followedBy
                        (Print.linebreakIndented
                            |> Print.followedBy
                                (printMoonbitExpressionNotParenthesizedCurlyEmbracedIfAfterStatement
                                    letDestructuring.expression
                                )
                        )
                )
            )


printExactlyLetSpace : Print
printExactlyLetSpace =
    Print.exactly "let "


printExactlyColon : Print
printExactlyColon =
    Print.exactly ":"


printExactlySpaceEquals : Print
printExactlySpaceEquals =
    Print.exactly " ="


printExactlySpaceCurlyOpening : Print
printExactlySpaceCurlyOpening =
    Print.exactly " {"


{-| Print value/function declarations into
an moonbit module called `Elm` in the global namespace that exposes all members.
Will also add some internal wrapper declarations.
-}
moonbitDeclarationsToModuleString :
    { fns :
        List
            { name : String
            , parameters : List { binding : Maybe String, type_ : MoonbitType }
            , result : MoonbitExpression
            , resultType : MoonbitType
            }
    , lets :
        List
            { name : String
            , result : MoonbitExpression
            , resultType : MoonbitType
            }
    , typeAliases :
        List
            { name : String
            , parameters : List String
            , type_ : MoonbitType
            }
    , enumTypes :
        List
            { name : String
            , parameters : List String
            , variants :
                FastDict.Dict String (List MoonbitType)
            }
    , structs :
        List
            { name : String
            , parameters : List String
            , fields : FastDict.Dict String MoonbitType
            }
    }
    -> String
moonbitDeclarationsToModuleString moonbitDeclarations =
    defaultDeclarations
        ++ """

"""
        ++ (moonbitDeclarations.structs
                |> Print.listMapAndIntersperseAndFlatten
                    printMoonbitStructDeclaration
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """

"""
        ++ (moonbitDeclarations.enumTypes
                |> Print.listMapAndIntersperseAndFlatten
                    printMoonbitEnumDeclaration
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """

"""
        ++ (moonbitDeclarations.typeAliases
                |> Print.listMapAndIntersperseAndFlatten
                    printMoonbitTypeAliasDeclaration
                    printLinebreakLinebreakIndented
                |> Print.toString
           )
        ++ """


"""
        ++ ((moonbitDeclarations.lets
                |> List.map printMoonbitLetDeclaration
            )
                ++ (moonbitDeclarations.fns
                        |> List.map printMoonbitFnDeclaration
                   )
                |> Print.listMapAndIntersperseAndFlatten
                    (\moonbitValueOrFunctionPrint ->
                        moonbitValueOrFunctionPrint
                            |> Print.followedBy printLinebreakLinebreakIndented
                    )
                    Print.empty
                |> Print.toString
                |> -- TODO hacky way to make stil4m/elm-syntax & miniBill/elm-fast-dict & elm-syntax-type-infer
                   -- compile because we have no way to find out which type variable is equatable
                   String.replace
                    "list_extra_unique_help<'a, A: Clone + 'a>"
                    "list_extra_unique_help<'a, A: Clone + Eq + 'a>"
                |> String.replace
                    "list_extra_unique<'a, A: Clone + 'a>"
                    "list_extra_unique<'a, A: Clone + Eq + 'a>"
                |> String.replace
                    "dict_by_type_variable_from_context_equals<'a, V: Clone + 'a>"
                    "dict_by_type_variable_from_context_equals<'a, V: Clone + Eq + 'a>"
                |> String.replace
                    "dict_by_type_variable_from_context_equals_help<'a, V: Clone + 'a>"
                    "dict_by_type_variable_from_context_equals_help<'a, V: Clone + Eq + 'a>"
                |> String.replace
                    """pub fn fast_dict_equals<'a, Comparable: Clone + Compare + 'a, V: Clone + 'a>(generated_allocator: &'a bumpalo::Bump, InternalDict::Dict(lsz, l_root): InternalDict<'a, Comparable, V>, InternalDict::Dict(rsz, r_root): InternalDict<'a, Comparable, V>) -> bool {
    fn go<'a, Comparable1: Clone + Compare + 'a, V1: Clone + 'a>"""
                    """pub fn fast_dict_equals<'a, Comparable: Clone + Compare + 'a, V: Clone + Eq + 'a>(generated_allocator: &'a bumpalo::Bump, InternalDict::Dict(lsz, l_root): InternalDict<'a, Comparable, V>, InternalDict::Dict(rsz, r_root): InternalDict<'a, Comparable, V>) -> bool {
    fn go<'a, Comparable1: Clone + Compare + 'a, V1: Clone + Eq + 'a>"""
           )
        ++ "\n"


listMapAndCombineJust : (a -> Maybe ok) -> List a -> Maybe (List ok)
listMapAndCombineJust elementToResult list =
    listMapAndCombineJustFrom [] elementToResult list


listMapAndCombineJustFrom : List ok -> (a -> Maybe ok) -> List a -> Maybe (List ok)
listMapAndCombineJustFrom soFarReverse elementToResult list =
    case list of
        [] ->
            Just (soFarReverse |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Nothing ->
                    Nothing

                Just headOk ->
                    listMapAndCombineJustFrom (headOk :: soFarReverse)
                        elementToResult
                        tail


listMapAndCombineOk : (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOk elementToResult list =
    listMapAndCombineOkFrom [] elementToResult list


listMapAndCombineOkFrom : List ok -> (a -> Result err ok) -> List a -> Result err (List ok)
listMapAndCombineOkFrom soFar elementToResult list =
    case list of
        [] ->
            Ok (soFar |> List.reverse)

        head :: tail ->
            case head |> elementToResult of
                Err headErr ->
                    Err headErr

                Ok headOk ->
                    listMapAndCombineOkFrom (headOk :: soFar)
                        elementToResult
                        tail


printLinebreakLinebreakIndented : Print.Print
printLinebreakLinebreakIndented =
    Print.linebreak
        |> Print.followedBy Print.linebreakIndented


printExactlyUnderscore : Print
printExactlyUnderscore =
    Print.exactly "_"


elmKernelParserTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelParserTypes =
    FastDict.singleton
        "Elm.Kernel.Parser"
        { signatures =
            FastDict.fromList
                [ ( "isSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "isSubChar"
                  , inferredTypeFunctionCreate
                        [ inferredTypeFunctionCreate [ typeChar ] typeBool, inferredTypeBasicsInt, inferredTypeString ]
                        inferredTypeBasicsInt
                  )
                , ( "isAsciiCode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        typeBool
                  )
                , ( "chompBase10"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeString ]
                        inferredTypeBasicsInt
                  )
                , ( "consumeBase"
                  , inferredTypeFunctionCreate [ inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "consumeBase16"
                  , inferredTypeFunctionCreate
                        [ inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTuple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


elmKernelUrlTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelUrlTypes =
    FastDict.singleton "Elm.Kernel.Url"
        { signatures =
            FastDict.fromList
                [ ( "percentEncode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString ]
                        inferredTypeString
                  )
                , ( "percentDecode"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Maybe"
                                , name = "Maybe"
                                , arguments = [ inferredTypeString ]
                                }
                            )
                        )
                  )
                , ( "findSubString"
                  , inferredTypeFunctionCreate
                        [ inferredTypeString, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeBasicsInt, inferredTypeString ]
                        (ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeTriple
                                { part0 = inferredTypeBasicsInt
                                , part1 = inferredTypeBasicsInt
                                , part2 = inferredTypeBasicsInt
                                }
                            )
                        )
                  )
                ]
        , typeAliases = FastDict.empty
        , choiceTypes = FastDict.empty
        }


inferredTypeFunctionCreate :
    List ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
    -> ElmSyntaxTypeInfer.Type
inferredTypeFunctionCreate inputs output =
    -- IGNORE TCO
    case inputs of
        [] ->
            output

        input :: remainingInputs ->
            ElmSyntaxTypeInfer.TypeNotVariable
                (ElmSyntaxTypeInfer.TypeFunction
                    { input = input
                    , output =
                        inferredTypeFunctionCreate remainingInputs output
                    }
                )


typeBool : ElmSyntaxTypeInfer.Type
typeBool =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Basics"
            , name = "Bool"
            , arguments = []
            }
        )


inferredTypeBasicsInt : ElmSyntaxTypeInfer.Type
inferredTypeBasicsInt =
    ElmSyntaxTypeInfer.TypeNotVariable typeNotVariableBasicsInt


typeNotVariableBasicsInt : ElmSyntaxTypeInfer.TypeNotVariable
typeNotVariableBasicsInt =
    ElmSyntaxTypeInfer.TypeConstruct
        { moduleOrigin = "Basics"
        , name = "Int"
        , arguments = []
        }


typeChar : ElmSyntaxTypeInfer.Type
typeChar =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin = "Char"
            , name = "Char"
            , arguments = []
            }
        )


typeList : ElmSyntaxTypeInfer.Type -> ElmSyntaxTypeInfer.Type
typeList elementType =
    ElmSyntaxTypeInfer.TypeNotVariable
        (ElmSyntaxTypeInfer.TypeConstruct
            { moduleOrigin =
                "List"
            , name = "List"
            , arguments =
                [ elementType ]
            }
        )


elmRandomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRandomTypes =
    FastDict.fromList
        [ ( "Random"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "constant"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "generate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Cmd"
                                                        , name = "Cmd"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "independentSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Random"
                                , name = "Generator"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "initialSeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Seed"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Int"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "c"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "d"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "e"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "f"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Generator"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Random"
                                                                                , name =
                                                                                    "Generator"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Random"
                                                                                            , name =
                                                                                                "Generator"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Random"
                                                                                                        , name =
                                                                                                            "Generator"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maxInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "minInt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Basics"
                                , name = "Int"
                                , arguments = []
                                }
                            )
                      )
                    , ( "pair"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "step"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Random"
                                            , name = "Generator"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Seed"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Random"
                                                                    , name =
                                                                        "Seed"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "uniform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "weighted"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeTuple
                                            { part0 =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , part1 =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Random"
                                                        , name = "Generator"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Generator"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Seed"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmBytesTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmBytesTypes =
    FastDict.fromList
        [ ( "Bytes"
          , { signatures =
                FastDict.fromList
                    [ ( "getHostEndianness"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "width"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Bytes"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Endianness"
                      , { parameters = []
                        , variants =
                            FastDict.fromList [ ( "LE", [] ), ( "BE", [] ) ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes"
                                                        , name = "Bytes"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "loop"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "state"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Step"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "state"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    , ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "a"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "result"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "result"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "result"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "result"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Bytes.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Bytes.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Bytes.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Bytes.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "result"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Bytes.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Step"
                      , { parameters = [ "state", "a" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Loop"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "state"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                , ( "Done"
                                  , [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Bytes.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "bytes"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Bytes"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float64"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getStringWidth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sequence"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "signedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt16"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt32"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes"
                                            , name = "Endianness"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Bytes.Encode"
                                                        , name = "Encoder"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "unsignedInt8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Bytes.Encode"
                                            , name = "Encoder"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Encoder"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmJsonTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmJsonTypes =
    FastDict.fromList
        [ ( "Json.Decode"
          , { signatures =
                FastDict.fromList
                    [ ( "andThen"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "at"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "decodeString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "decodeValue"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Result"
                                                        , name = "Result"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Error"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "Dict"
                                                        , name = "Dict"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            , ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "errorToString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fail"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "field"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "index"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "keyValuePairs"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeTuple
                                                                    { part0 =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , part1 =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    ElmSyntaxTypeInfer.TypeUnit
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin = "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "value"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "value"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "value"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "value"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "value"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "value"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "value"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Decode"
                                                                    , name =
                                                                        "Decoder"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "b"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Json.Decode"
                                                                                , name =
                                                                                    "Decoder"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "c"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Json.Decode"
                                                                                            , name =
                                                                                                "Decoder"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "d"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Json.Decode"
                                                                                                        , name =
                                                                                                            "Decoder"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "e"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "Json.Decode"
                                                                                                                    , name =
                                                                                                                        "Decoder"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "f"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "Json.Decode"
                                                                                                                                , name =
                                                                                                                                    "Decoder"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "g"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "h"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "Json.Decode"
                                                                                                                                            , name =
                                                                                                                                                "Decoder"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "value"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "maybe"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nullable"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOf"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "oneOrMore"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "a"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Decoder"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "value"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "succeed"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeVariable
                                        { name = "a"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "value"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Decode"
                                , name = "Decoder"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeConstruct
                                    { moduleOrigin = "Json.Encode"
                                    , name = "Value"
                                    , arguments = []
                                    }
                                )
                        , recordFieldOrder = Nothing
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Decoder"
                      , { parameters = [ "a" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Error"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Field"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Index"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Error"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "OneOf"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Error"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Failure"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        , ( "Json.Encode"
          , { signatures =
                FastDict.fromList
                    [ ( "array"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Array"
                                                        , name = "Array"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "bool"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Bool"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dict"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "k"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "v"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Dict"
                                                                    , name =
                                                                        "Dict"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "k"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        , ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "v"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "encode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "float"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "int"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "list"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "null"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Json.Encode"
                                , name = "Value"
                                , arguments = []
                                }
                            )
                      )
                    , ( "object"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "List"
                                            , name = "List"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Json.Encode"
                                                                    , name =
                                                                        "Value"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "set"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Set"
                                                        , name = "Set"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Encode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "string"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Encode"
                                            , name = "Value"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Value"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmKernelVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmKernelVirtualDomTypes =
    FastDict.fromList
        [ ( "Elm.Kernel.VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "noJavaScriptOrHtmlUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output = inferredTypeString
                                }
                            )
                      )
                    , ( "noJavaScriptUri"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output = inferredTypeString
                                }
                            )
                      )
                    , ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input = inferredTypeString
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                typeList
                                                    (ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "VirtualDom"
                                                            , name =
                                                                "Attribute"
                                                            , arguments =
                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                    { name =
                                                                        "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                                ]
                                                            }
                                                        )
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Node"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input = inferredTypeString
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input = inferredTypeString
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            typeList
                                                                (ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "VirtualDom"
                                                                        , name =
                                                                            "Attribute"
                                                                        , arguments =
                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                { name =
                                                                                    "msg"
                                                                                , useRange =
                                                                                    Elm.Syntax.Range.empty
                                                                                }
                                                                            ]
                                                                        }
                                                                    )
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        typeList
                                                                            (ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "VirtualDom"
                                                                                    , name =
                                                                                        "Node"
                                                                                    , arguments =
                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                            { name =
                                                                                                "msg"
                                                                                            , useRange =
                                                                                                Elm.Syntax.Range.empty
                                                                                            }
                                                                                        ]
                                                                                    }
                                                                                )
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.empty
            , choiceTypes = FastDict.empty
            }
          )
        ]


elmVirtualDomTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmVirtualDomTypes =
    FastDict.fromList
        [ ( "VirtualDom"
          , { signatures =
                FastDict.fromList
                    [ ( "attribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "attributeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNode"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeTuple
                                                                                { part0 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "String"
                                                                                            , name =
                                                                                                "String"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , part1 =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "keyedNodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeTuple
                                                                                            { part0 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "String"
                                                                                                        , name =
                                                                                                            "String"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , part1 =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy5"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "VirtualDom"
                                                                                                        , name =
                                                                                                            "Node"
                                                                                                        , arguments =
                                                                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "msg"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                            ]
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy6"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                    { moduleOrigin =
                                                                                                                        "VirtualDom"
                                                                                                                    , name =
                                                                                                                        "Node"
                                                                                                                    , arguments =
                                                                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "msg"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                        ]
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy7"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                { moduleOrigin =
                                                                                                                                    "VirtualDom"
                                                                                                                                , name =
                                                                                                                                    "Node"
                                                                                                                                , arguments =
                                                                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "msg"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                    ]
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lazy8"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "c"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "d"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "e"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                                                                        { input =
                                                                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                                                                { name =
                                                                                                                    "f"
                                                                                                                , useRange =
                                                                                                                    Elm.Syntax.Range.empty
                                                                                                                }
                                                                                                        , output =
                                                                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                    { input =
                                                                                                                        ElmSyntaxTypeInfer.TypeVariable
                                                                                                                            { name =
                                                                                                                                "g"
                                                                                                                            , useRange =
                                                                                                                                Elm.Syntax.Range.empty
                                                                                                                            }
                                                                                                                    , output =
                                                                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                                                                { input =
                                                                                                                                    ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                        { name =
                                                                                                                                            "h"
                                                                                                                                        , useRange =
                                                                                                                                            Elm.Syntax.Range.empty
                                                                                                                                        }
                                                                                                                                , output =
                                                                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                                                            { moduleOrigin =
                                                                                                                                                "VirtualDom"
                                                                                                                                            , name =
                                                                                                                                                "Node"
                                                                                                                                            , arguments =
                                                                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                                                                    { name =
                                                                                                                                                        "msg"
                                                                                                                                                    , useRange =
                                                                                                                                                        Elm.Syntax.Range.empty
                                                                                                                                                    }
                                                                                                                                                ]
                                                                                                                                            }
                                                                                                                                        )
                                                                                                                                }
                                                                                                                            )
                                                                                                                    }
                                                                                                                )
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "map"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Node"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mapAttribute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "a"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            , output =
                                                ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "b"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "a"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "b"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "node"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Attribute"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "VirtualDom"
                                                                    , name =
                                                                        "Node"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeVariable
                                                                            { name =
                                                                                "msg"
                                                                            , useRange =
                                                                                Elm.Syntax.Range.empty
                                                                            }
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "nodeNS"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Attribute"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "List"
                                                                                , name =
                                                                                    "List"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "VirtualDom"
                                                                                            , name =
                                                                                                "Node"
                                                                                            , arguments =
                                                                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                                                                    { name =
                                                                                                        "msg"
                                                                                                    , useRange =
                                                                                                        Elm.Syntax.Range.empty
                                                                                                    }
                                                                                                ]
                                                                                            }
                                                                                        )
                                                                                    ]
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "VirtualDom"
                                                                                , name =
                                                                                    "Node"
                                                                                , arguments =
                                                                                    [ ElmSyntaxTypeInfer.TypeVariable
                                                                                        { name =
                                                                                            "msg"
                                                                                        , useRange =
                                                                                            Elm.Syntax.Range.empty
                                                                                        }
                                                                                    ]
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "on"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Handler"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "property"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Json.Decode"
                                                        , name = "Value"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "style"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "VirtualDom"
                                                        , name = "Attribute"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "text"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "VirtualDom"
                                            , name = "Node"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Attribute"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    , ( "Handler"
                      , { parameters = [ "msg" ]
                        , variants =
                            FastDict.fromList
                                [ ( "Normal"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeVariable
                                                    { name = "msg"
                                                    , useRange =
                                                        Elm.Syntax.Range.empty
                                                    }
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayStopPropagation"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "MayPreventDefault"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeTuple
                                                        { part0 =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name = "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        , part1 =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Bool"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                , ( "Custom"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Json.Decode"
                                            , name = "Decoder"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeRecord
                                                        (FastDict.fromList
                                                            [ ( "message"
                                                              , ElmSyntaxTypeInfer.TypeVariable
                                                                    { name = "msg"
                                                                    , useRange =
                                                                        Elm.Syntax.Range.empty
                                                                    }
                                                              )
                                                            , ( "preventDefault"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            , ( "stopPropagation"
                                                              , ElmSyntaxTypeInfer.TypeNotVariable
                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                        { moduleOrigin =
                                                                            "Basics"
                                                                        , name =
                                                                            "Bool"
                                                                        , arguments =
                                                                            []
                                                                        }
                                                                    )
                                                              )
                                                            ]
                                                        )
                                                    )
                                                ]
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    , ( "Node"
                      , { parameters = [ "msg" ]
                        , variants = FastDict.fromList []
                        }
                      )
                    ]
            }
          )
        ]


elmTimeTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmTimeTypes =
    FastDict.fromList
        [ ( "Time"
          , { signatures =
                FastDict.fromList
                    [ ( "customZone"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeRecord
                                                                    (FastDict.fromList
                                                                        [ ( "offset"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        , ( "start"
                                                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                                    { moduleOrigin =
                                                                                        "Basics"
                                                                                    , name =
                                                                                        "Int"
                                                                                    , arguments =
                                                                                        []
                                                                                    }
                                                                                )
                                                                          )
                                                                        ]
                                                                    )
                                                                )
                                                            ]
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Zone"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "every"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Time"
                                                                    , name =
                                                                        "Posix"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Platform.Sub"
                                                        , name = "Sub"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeVariable
                                                                { name =
                                                                    "msg"
                                                                , useRange =
                                                                    Elm.Syntax.Range.empty
                                                                }
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZoneName"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "ZoneName"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "here"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "millisToPosix"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "now"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Task"
                                , name = "Task"
                                , arguments =
                                    [ ElmSyntaxTypeInfer.TypeVariable
                                        { name = "x"
                                        , useRange = Elm.Syntax.Range.empty
                                        }
                                    , ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                }
                            )
                      )
                    , ( "posixToMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Posix"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toDay"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toHour"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMillis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMinute"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toMonth"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Month"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toSecond"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toWeekday"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Weekday"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toYear"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Time"
                                            , name = "Zone"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Time"
                                                        , name = "Posix"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Int"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "utc"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Time"
                                , name = "Zone"
                                , arguments = []
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Month"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Jan", [] )
                                , ( "Feb", [] )
                                , ( "Mar", [] )
                                , ( "Apr", [] )
                                , ( "May", [] )
                                , ( "Jun", [] )
                                , ( "Jul", [] )
                                , ( "Aug", [] )
                                , ( "Sep", [] )
                                , ( "Oct", [] )
                                , ( "Nov", [] )
                                , ( "Dec", [] )
                                ]
                        }
                      )
                    , ( "Posix"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "Weekday"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Mon", [] )
                                , ( "Tue", [] )
                                , ( "Wed", [] )
                                , ( "Thu", [] )
                                , ( "Fri", [] )
                                , ( "Sat", [] )
                                , ( "Sun", [] )
                                ]
                        }
                      )
                    , ( "Zone"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    , ( "ZoneName"
                      , { parameters = []
                        , variants =
                            FastDict.fromList
                                [ ( "Name"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                , ( "Offset"
                                  , [ ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                    ]
                                  )
                                ]
                        }
                      )
                    ]
            }
          )
        ]


elmExplorationsLinearAlgebraTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmExplorationsLinearAlgebraTypes =
    FastDict.fromList
        [ ( "Math.Matrix4"
          , { signatures =
                FastDict.fromList
                    [ ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "identity"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Matrix4"
                                , name = "Mat4"
                                , arguments = []
                                }
                            )
                      )
                    , ( "inverse"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "inverseOrthonormal"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeBasis"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeFmoonbitum"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeLookAt"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeFunction
                                                                                { input =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                                            { moduleOrigin =
                                                                                                "Basics"
                                                                                            , name =
                                                                                                "Float"
                                                                                            , arguments =
                                                                                                []
                                                                                            }
                                                                                        )
                                                                                , output =
                                                                                    ElmSyntaxTypeInfer.TypeNotVariable
                                                                                        (ElmSyntaxTypeInfer.TypeFunction
                                                                                            { input =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Basics"
                                                                                                        , name =
                                                                                                            "Float"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            , output =
                                                                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                                                                        { moduleOrigin =
                                                                                                            "Math.Matrix4"
                                                                                                        , name =
                                                                                                            "Mat4"
                                                                                                        , arguments =
                                                                                                            []
                                                                                                        }
                                                                                                    )
                                                                                            }
                                                                                        )
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeOrtho2D"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makePerspective"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeRotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeScale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "makeTranslate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mul"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "mulAffine"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "rotate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Matrix4"
                                                                    , name =
                                                                        "Mat4"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "m11"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m12"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m13"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m14"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m21"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m22"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m23"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m24"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m31"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m32"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m33"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m34"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m41"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m42"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m43"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "m44"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "transform"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Matrix4"
                                                        , name = "Mat4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "translate3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Matrix4"
                                                                                , name =
                                                                                    "Mat4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "transpose"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Matrix4"
                                            , name = "Mat4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Mat4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector2"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector2"
                                            , name = "Vec2"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec2"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector2"
                                                        , name = "Vec2"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec2"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector3"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "cross"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "i"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "j"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "k"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Math.Vector3"
                                , name = "Vec3"
                                , arguments = []
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector3"
                                                        , name = "Vec3"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector3"
                                            , name = "Vec3"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec3"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Math.Vector3"
                                                                    , name =
                                                                        "Vec3"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec3"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        , ( "Math.Vector4"
          , { signatures =
                FastDict.fromList
                    [ ( "add"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "direction"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distance"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "distanceSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "dot"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "getZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "length"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "lengthSquared"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "negate"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "normalize"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                }
                            )
                      )
                    , ( "scale"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setW"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setX"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setY"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "setZ"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "sub"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Math.Vector4"
                                                        , name = "Vec4"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "toRecord"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Math.Vector4"
                                            , name = "Vec4"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeRecord
                                            (FastDict.fromList
                                                [ ( "w"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "x"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "y"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                , ( "z"
                                                  , ElmSyntaxTypeInfer.TypeNotVariable
                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                            { moduleOrigin =
                                                                "Basics"
                                                            , name = "Float"
                                                            , arguments = []
                                                            }
                                                        )
                                                  )
                                                ]
                                            )
                                        )
                                }
                            )
                      )
                    , ( "vec4"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Float"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Float"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Basics"
                                                                    , name =
                                                                        "Float"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Basics"
                                                                                , name =
                                                                                    "Float"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Math.Vector4"
                                                                                , name =
                                                                                    "Vec4"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases = FastDict.fromList []
            , choiceTypes =
                FastDict.fromList
                    [ ( "Vec4"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


elmRegexTypes : FastDict.Dict String ElmSyntaxTypeInfer.ModuleTypes
elmRegexTypes =
    FastDict.fromList
        [ ( "Regex"
          , { signatures =
                FastDict.fromList
                    [ ( "contains"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Basics"
                                                        , name = "Bool"
                                                        , arguments = []
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "find"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "findAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromString"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "String"
                                            , name = "String"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Maybe"
                                            , name = "Maybe"
                                            , arguments =
                                                [ ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                                ]
                                            }
                                        )
                                }
                            )
                      )
                    , ( "fromStringWith"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Options"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Maybe"
                                                        , name = "Maybe"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Regex"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "never"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeConstruct
                                { moduleOrigin = "Regex"
                                , name = "Regex"
                                , arguments = []
                                }
                            )
                      )
                    , ( "replace"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "Regex"
                                                                    , name =
                                                                        "Match"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "replaceAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "Regex"
                                                                                , name =
                                                                                    "Match"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeFunction
                                                                    { input =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    , output =
                                                                        ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "split"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Regex"
                                            , name = "Regex"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "String"
                                                        , name = "String"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "List"
                                                        , name = "List"
                                                        , arguments =
                                                            [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                            ]
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    , ( "splitAtMost"
                      , ElmSyntaxTypeInfer.TypeNotVariable
                            (ElmSyntaxTypeInfer.TypeFunction
                                { input =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeConstruct
                                            { moduleOrigin = "Basics"
                                            , name = "Int"
                                            , arguments = []
                                            }
                                        )
                                , output =
                                    ElmSyntaxTypeInfer.TypeNotVariable
                                        (ElmSyntaxTypeInfer.TypeFunction
                                            { input =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeConstruct
                                                        { moduleOrigin =
                                                            "Regex"
                                                        , name = "Regex"
                                                        , arguments = []
                                                        }
                                                    )
                                            , output =
                                                ElmSyntaxTypeInfer.TypeNotVariable
                                                    (ElmSyntaxTypeInfer.TypeFunction
                                                        { input =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "String"
                                                                    , name =
                                                                        "String"
                                                                    , arguments =
                                                                        []
                                                                    }
                                                                )
                                                        , output =
                                                            ElmSyntaxTypeInfer.TypeNotVariable
                                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                                    { moduleOrigin =
                                                                        "List"
                                                                    , name =
                                                                        "List"
                                                                    , arguments =
                                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                                { moduleOrigin =
                                                                                    "String"
                                                                                , name =
                                                                                    "String"
                                                                                , arguments =
                                                                                    []
                                                                                }
                                                                            )
                                                                        ]
                                                                    }
                                                                )
                                                        }
                                                    )
                                            }
                                        )
                                }
                            )
                      )
                    ]
            , typeAliases =
                FastDict.fromList
                    [ ( "Match"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "index"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "match"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "String"
                                                    , name = "String"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "number"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Int"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "submatches"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "List"
                                                    , name = "List"
                                                    , arguments =
                                                        [ ElmSyntaxTypeInfer.TypeNotVariable
                                                            (ElmSyntaxTypeInfer.TypeConstruct
                                                                { moduleOrigin =
                                                                    "Maybe"
                                                                , name =
                                                                    "Maybe"
                                                                , arguments =
                                                                    [ ElmSyntaxTypeInfer.TypeNotVariable
                                                                        (ElmSyntaxTypeInfer.TypeConstruct
                                                                            { moduleOrigin =
                                                                                "String"
                                                                            , name =
                                                                                "String"
                                                                            , arguments =
                                                                                []
                                                                            }
                                                                        )
                                                                    ]
                                                                }
                                                            )
                                                        ]
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "match", "index", "number", "submatches" ]
                        }
                      )
                    , ( "Options"
                      , { parameters = []
                        , type_ =
                            ElmSyntaxTypeInfer.TypeNotVariable
                                (ElmSyntaxTypeInfer.TypeRecord
                                    (FastDict.fromList
                                        [ ( "caseInsensitive"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        , ( "multiline"
                                          , ElmSyntaxTypeInfer.TypeNotVariable
                                                (ElmSyntaxTypeInfer.TypeConstruct
                                                    { moduleOrigin = "Basics"
                                                    , name = "Bool"
                                                    , arguments = []
                                                    }
                                                )
                                          )
                                        ]
                                    )
                                )
                        , recordFieldOrder =
                            Just [ "caseInsensitive", "multiline" ]
                        }
                      )
                    ]
            , choiceTypes =
                FastDict.fromList
                    [ ( "Regex"
                      , { parameters = [], variants = FastDict.fromList [] }
                      )
                    ]
            }
          )
        ]


defaultDeclarations : String
defaultDeclarations =
    -- update with `node src/updateDefaultDeclarations.js`
    """
// All random_* and Random* declarations are
// derived and modified from elm/random.
// All time_* and Time* declarations are
// derived and modified from elm/time.
// Both elm/random and elm/time are licensed under:
// 
// Copyright (c) 2018-present, Evan Czaplicki
// 
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
// 
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
// 
//     * Neither the name of Evan Czaplicki nor the names of other
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

///|
pub fn[S : Show] debug_to_string(thing : S) -> StringString {
  StringString::One(S::to_string(thing))
}

///|
pub fn[S : Show] debug_log(tag : StringString, thing : S) -> S {
  println("\\{string_string_to_string(tag)}: \\{thing}")
  thing
}

///|
pub fn[S] debug_todo(message : StringString) -> S {
  println("\\{string_string_to_string(message)}")
  ...
}

///|
pub fn[A] basics_identity(thing : A) -> A {
  thing
}

///|
pub fn[Keep, Ignore] basics_always(keep : Keep, _ : Ignore) -> Keep {
  keep
}

///|
pub fn[In, Out] basics_apr(food : In, eat : (In) -> Out) -> Out {
  eat(food)
}

///|
pub fn[In, Out] basics_apl(eat : (In) -> Out, food : In) -> Out {
  eat(food)
}

///|
pub fn[A, B, C] basics_composer(
  a_to_b : (A) -> B,
  b_to_c : (B) -> C,
) -> (A) -> C {
  fn(a) { b_to_c(a_to_b(a)) }
}

///|
pub fn[A, B, C] basics_composel(
  b_to_c : (B) -> C,
  a_to_b : (A) -> B,
) -> (A) -> C {
  fn(a) { b_to_c(a_to_b(a)) }
}

///|
pub fn basics_not(bool : Bool) -> Bool {
  !bool
}

///|
pub(all) enum BasicsOrder {
  LT
  EQ
  GT
}

///|
fn int_to_basics_order(as_int : Int) -> BasicsOrder {
  if as_int <= -1 {
    BasicsOrder::LT
  } else if as_int >= 1 {
    BasicsOrder::GT
  } else {
    BasicsOrder::EQ
  }
}

///|
fn basics_order_to_int(order : BasicsOrder) -> Int {
  match order {
    BasicsOrder::EQ => 0
    BasicsOrder::LT => -1
    BasicsOrder::GT => 1
  }
}

///|
pub fn[C : Compare] basics_compare(a : C, b : C) -> BasicsOrder {
  int_to_basics_order(C::compare(a, b))
}

///|
pub let basics_e : Double = @math.exp(1.0)

///|
pub fn[E : Eq] basics_neq(a : E, b : E) -> Bool {
  E::equal(a, b)
}

///|
pub fn[E : Eq] basics_eq(a : E, b : E) -> Bool {
  E::equal(a, b)
}

///|
pub fn[N : Compare] basics_lt(a : N, b : N) -> Bool {
  a < b
}

///|
pub fn[N : Compare] basics_le(a : N, b : N) -> Bool {
  a <= b
}

///|
pub fn[N : Compare] basics_gt(a : N, b : N) -> Bool {
  a > b
}

///|
pub fn[N : Compare] basics_ge(a : N, b : N) -> Bool {
  a >= b
}

///|
pub fn[N : Add] basics_add(a : N, b : N) -> N {
  a + b
}

///|
pub fn[N : Sub] basics_sub(base : N, reduction : N) -> N {
  base - reduction
}

///|
pub fn[N : Mul] basics_mul(a : N, b : N) -> N {
  a * b
}

///|
pub fnalias Int64::div as basics_idiv

///|
pub fnalias Double::div as basics_fdiv

///|
pub fn basics_remainder_by(to_divide_by : Int64, n : Int64) -> Int64 {
  n % to_divide_by
}

///|
pub fn basics_mod_by(to_divide_by : Int64, n : Int64) -> Int64 {
  // https://github.com/elm/core/blob/1.0.5/src/Elm/Kernel/Basics.js#L20
  // https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
  if to_divide_by == 0L {
    // will panic
    n % 0
  } else {
    let remainder : Int64 = n % to_divide_by
    if (remainder > 0L && to_divide_by < 0L) ||
      (remainder < 0L && to_divide_by > 0L) {
      remainder + to_divide_by
    } else {
      remainder
    }
  }
}

///|
pub fnalias Double::is_nan as basics_is_nan

///|
pub fnalias Double::sqrt as basics_sqrt

///|
pub fnalias Double::is_inf as basics_is_infinite

///|
pub fn basics_ceiling(float : Double) -> Int64 {
  Double::to_int64(Double::ceil(float))
}

///|
pub fn basics_floor(float : Double) -> Int64 {
  Double::to_int64(Double::floor(float))
}

///|
pub fn basics_round(float : Double) -> Int64 {
  Double::to_int64(Double::round(float))
}

///|
pub fn basics_truncate(float : Double) -> Int64 {
  Double::to_int64(float)
}

///|
pub fn[N : Neg] basics_negate(n : N) -> N {
  N::neg(n)
}

///|
pub fn basics_log_base(base : Double, n : Double) -> Double {
  @math.ln(n) / @math.ln(base)
}

///|
pub fn basics_to_radians(degrees : Double) -> Double {
  degrees / 180 * @math.PI
}

///|
pub fn basics_turns(turns : Double) -> Double {
  turns * 2 * @math.PI
}

///|
pub fn basics_to_polar(xy : (Double, Double)) -> (Double, Double) {
  let (x, y) = xy
  (Double::sqrt(x * x + y * y), @math.atan2(y, x))
}

///|
pub fn basics_from_polar(polar : (Double, Double)) -> (Double, Double) {
  let (radius, theta) = polar
  (radius * @math.cos(theta), radius * @math.sin(theta))
}

///|
pub fn[C : Compare] basics_clamp(minimum : C, maximum : C, n : C) -> C {
  if n < minimum {
    minimum
  } else if n > maximum {
    maximum
  } else {
    n
  }
}

///|
pub fnalias Int64::to_double as basics_to_float

///|
pub fn basics_pow_int(n : Int64, exponent : Int64) -> Int64 {
  Double::to_int64(@math.pow(Int64::to_double(n), Int64::to_double(exponent)))
}

///|
pub(all) enum BasicsNever {}

///|
pub fn[YourChoice] basics_never(ever : BasicsNever) -> YourChoice {
  match ever {

  }
}

///|
pub fn bitwise_shift_left_by(shift_bit_count : Int64, n : Int64) -> Int64 {
  Int::to_int64(Int64::to_int(n) << Int64::to_int(shift_bit_count))
}

///|
pub fn bitwise_shift_right_by(shift_bit_count : Int64, n : Int64) -> Int64 {
  Int::to_int64(Int64::to_int(n) >> Int64::to_int(shift_bit_count))
}

///|
pub fn bitwise_shift_right_zf_by(shift_bit_count : Int64, n : Int64) -> Int64 {
  UInt::to_int64(Int::reinterpret_as_uint(Int64::to_int(n))) >>
  Int64::to_int(shift_bit_count)
}

///|
pub fn bitwise_complement(n : Int64) -> Int64 {
  Int::to_int64(Int::lnot(Int64::to_int(n)))
}

///|
pub fn bitwise_xor(a : Int64, b : Int64) -> Int64 {
  Int::to_int64(Int64::to_int(a) ^ Int64::to_int(b))
}

///|
pub fn bitwise_and(a : Int64, b : Int64) -> Int64 {
  Int::to_int64(Int64::to_int(a) & Int64::to_int(b))
}

///|
pub fn bitwise_or(a : Int64, b : Int64) -> Int64 {
  Int::to_int64(Int64::to_int(a) | Int64::to_int(b))
}

///|
pub fn char_to_code(char : Char) -> Int64 {
  Int::to_int64(Char::to_int(char))
}

///|
pub fn char_from_code(code : Int64) -> Char {
  Option::unwrap_or(Int::to_char(Int64::to_int(code)), '\\u{0}')
}

///|
pub fnalias Char::is_ascii_lowercase as char_is_lower

///|
pub fnalias Char::is_ascii_uppercase as char_is_upper

///|
pub fnalias Char::is_ascii_hexdigit as char_is_hex_digit

///|
pub fnalias Char::is_ascii_octdigit as char_is_oct_digit

///|
pub fnalias Char::is_ascii_digit as char_is_digit

///|
pub fnalias Char::is_ascii_alphabetic as char_is_alpha

///|
pub fn char_is_alpha_num(char : Char) -> Bool {
  Char::is_ascii_alphabetic(char) || Char::is_ascii_digit(char)
}

///|
pub fn char_to_lower(char : Char) -> Char {
  Option::unwrap_or(
    String::get_char(String::to_lower(Char::to_string(char)), 0),
    '\\u{0}',
  )
}

///|
pub fn char_to_upper(char : Char) -> Char {
  Option::unwrap_or(
    String::get_char(String::to_upper(Char::to_string(char)), 0),
    '\\u{0}',
  )
}

///|
pub fn[A] maybe_with_default(value_on_nothing : A, maybe : A?) -> A {
  Option::unwrap_or(maybe, value_on_nothing)
}

///|
pub fn[A, B] maybe_and_then(on_value : (A) -> B?, maybe : A?) -> B? {
  Option::bind(maybe, on_value)
}

///|
pub fn[A, B] maybe_map(value_change : (A) -> B, maybe : A?) -> B? {
  Option::map(maybe, value_change)
}

///|
pub fn[A, B, Combined] maybe_map2(
  combine : (A, B) -> Combined,
  a_maybe : A?,
  b_maybe : B?,
) -> Combined? {
  match (a_maybe, b_maybe) {
    (Option::Some(a), Option::Some(b)) => Option::Some(combine(a, b))
    (Option::None, _) | (_, Option::None) => Option::None
  }
}

///|
pub fn[A, B, C, Combined] maybe_map3(
  combine : (A, B, C) -> Combined,
  a_maybe : A?,
  b_maybe : B?,
  c_maybe : C?,
) -> Combined? {
  match (a_maybe, b_maybe, c_maybe) {
    (Option::Some(a), Option::Some(b), Option::Some(c)) =>
      Option::Some(combine(a, b, c))
    (Option::None, _, _) | (_, Option::None, _) | (_, _, Option::None) =>
      Option::None
  }
}

///|
pub fn[A, B, C, D, Combined] maybe_map4(
  combine : (A, B, C, D) -> Combined,
  a_maybe : A?,
  b_maybe : B?,
  c_maybe : C?,
  d_maybe : D?,
) -> Combined? {
  match (a_maybe, b_maybe, c_maybe, d_maybe) {
    (Option::Some(a), Option::Some(b), Option::Some(c), Option::Some(d)) =>
      Option::Some(combine(a, b, c, d))
    (Option::None, _, _, _)
    | (_, Option::None, _, _)
    | (_, _, Option::None, _)
    | (_, _, _, Option::None) => Option::None
  }
}

///|
pub fn[A, B, C, D, E, Combined] maybe_map5(
  combine : (A, B, C, D, E) -> Combined,
  a_maybe : A?,
  b_maybe : B?,
  c_maybe : C?,
  d_maybe : D?,
  e_maybe : E?,
) -> Combined? {
  match (a_maybe, b_maybe, c_maybe, d_maybe, e_maybe) {
    (
      Option::Some(a),
      Option::Some(b),
      Option::Some(c),
      Option::Some(d),
      Option::Some(e),
    ) => Option::Some(combine(a, b, c, d, e))
    (Option::None, _, _, _, _)
    | (_, Option::None, _, _, _)
    | (_, _, Option::None, _, _)
    | (_, _, _, Option::None, _)
    | (_, _, _, _, Option::None) => Option::None
  }
}

///|
pub typealias Result[Err, Ok] as ResultResult[Ok, Err]

///|
pub fn[A, X] result_with_default(
  value_on_err : A,
  result : ResultResult[X, A],
) -> A {
  Result::unwrap_or(result, value_on_err)
}

///|
pub fnalias Result::to_option as result_to_maybe

///|
pub fn[A, X] result_from_maybe(
  error_on_nothing : X,
  maybe : A?,
) -> ResultResult[X, A] {
  match maybe {
    Option::None => Result::Err(error_on_nothing)
    Option::Some(value) => Result::Ok(value)
  }
}

///|
pub fn[A, B, X] result_and_then(
  on_ok : (A) -> ResultResult[X, B],
  result : ResultResult[X, A],
) -> ResultResult[X, B] {
  Result::bind(result, on_ok)
}

///|
pub fn[A, X, Y] result_map_error(
  error_change : (X) -> Y,
  result : ResultResult[X, A],
) -> ResultResult[Y, A] {
  Result::map_err(result, error_change)
}

///|
pub fn[A, B, X] result_map(
  success_change : (A) -> B,
  result : ResultResult[X, A],
) -> ResultResult[X, B] {
  Result::map(result, success_change)
}

///|
pub fn[A, B, Combined, X] result_map2(
  combine : (A, B) -> Combined,
  a_result : ResultResult[X, A],
  b_result : ResultResult[X, B],
) -> ResultResult[X, Combined] {
  match (a_result, b_result) {
    (Result::Ok(a), Result::Ok(b)) => Result::Ok(combine(a, b))
    (Result::Err(x), _) | (_, Result::Err(x)) => Result::Err(x)
  }
}

///|
pub fn[A, B, C, Combined, X] result_map3(
  combine : (A, B, C) -> Combined,
  a_result : ResultResult[X, A],
  b_result : ResultResult[X, B],
  c_result : ResultResult[X, C],
) -> ResultResult[X, Combined] {
  match (a_result, b_result, c_result) {
    (Result::Ok(a), Result::Ok(b), Result::Ok(c)) =>
      Result::Ok(combine(a, b, c))
    (Result::Err(x), _, _) | (_, Result::Err(x), _) | (_, _, Result::Err(x)) =>
      Result::Err(x)
  }
}

///|
pub fn[A, B, C, D, Combined, X] result_map4(
  combine : (A, B, C, D) -> Combined,
  a_result : ResultResult[X, A],
  b_result : ResultResult[X, B],
  c_result : ResultResult[X, C],
  d_result : ResultResult[X, D],
) -> ResultResult[X, Combined] {
  match (a_result, b_result, c_result, d_result) {
    (Result::Ok(a), Result::Ok(b), Result::Ok(c), Result::Ok(d)) =>
      Result::Ok(combine(a, b, c, d))
    (Result::Err(x), _, _, _)
    | (_, Result::Err(x), _, _)
    | (_, _, Result::Err(x), _)
    | (_, _, _, Result::Err(x)) => Result::Err(x)
  }
}

///|
pub fn[A, B, C, D, E, Combined, X] result_map5(
  combine : (A, B, C, D, E) -> Combined,
  a_result : ResultResult[X, A],
  b_result : ResultResult[X, B],
  c_result : ResultResult[X, C],
  d_result : ResultResult[X, D],
  e_result : ResultResult[X, E],
) -> ResultResult[X, Combined] {
  match (a_result, b_result, c_result, d_result, e_result) {
    (Result::Ok(a), Result::Ok(b), Result::Ok(c), Result::Ok(d), Result::Ok(e)) =>
      Result::Ok(combine(a, b, c, d, e))
    (Result::Err(x), _, _, _, _)
    | (_, Result::Err(x), _, _, _)
    | (_, _, Result::Err(x), _, _)
    | (_, _, _, Result::Err(x), _)
    | (_, _, _, _, Result::Err(x)) => Result::Err(x)
  }
}

///|
pub fn[A] list_singleton(only_element : A) -> @list.List[A] {
  @list.of([only_element])
}

///|
pub fn[A] list_cons(newHead : A, tail : @list.List[A]) -> @list.List[A] {
  @list.List::prepend(tail, newHead)
}

///|
pub fnalias @list.List::is_empty as list_is_empty

///|
pub fn[A] list_length(list : @list.List[A]) -> Int64 {
  Int::to_int64(@list.List::length(list))
}

///|
pub fn[A : Eq] list_member(needle : A, list : @list.List[A]) -> Bool {
  @list.List::contains(list, needle)
}

///|
pub fnalias @list.List::minimum as list_minimum

///|
pub fnalias @list.List::maximum as list_maximum

///|
pub fn list_sum_int(list : @list.List[Int64]) -> Int64 {
  @list.List::fold(list, init=0L, Int64::add)
}

///|
pub fn list_sum_float(list : @list.List[Double]) -> Double {
  @list.List::fold(list, init=0.0, Double::add)
}

///|
pub fn list_product_int(list : @list.List[Int64]) -> Int64 {
  @list.List::fold(list, init=1L, Int64::mul)
}

///|
pub fn list_product_float(list : @list.List[Double]) -> Double {
  @list.List::fold(list, init=1.0, Double::mul)
}

///|
pub fnalias @list.List::head as list_head

///|
pub fn[A] list_tail(list : @list.List[A]) -> @list.List[A]? {
  match list {
    @list.List::Empty => Option::None
    @list.List::More(_, tail~) => Option::Some(tail)
  }
}

///|
pub fn[A] list_repeat(count : Int64, element : A) -> @list.List[A] {
  @list.repeat(Int64::to_int(count), element)
}

///|
pub fn list_range(
  smallest_inclusive : Int64,
  greatest_inclusive : Int64,
) -> @list.List[Int64] {
  let mut result : @list.List[Int64] = @list.empty()
  for n = greatest_inclusive; n >= smallest_inclusive; n = n - 1L {
    result = result.prepend(n)
  }
  result
}

///|
pub fnalias @list.List::concat as list_append

///|
pub fnalias @list.List::flatten as list_concat

///|
pub fnalias @list.List::rev as list_reverse

///|
pub fnalias @list.List::sort as list_sort

///|
pub fn[A, Key : Compare] list_sort_by(
  element_to_key : (A) -> Key,
  list : @list.List[A],
) -> @list.List[A] {
  let as_array : Array[A] = @list.List::to_array(list)
  Array::sort_by_key(as_array, element_to_key)
  @list.from_array(as_array)
}

///|
pub fn[A] list_sort_with(
  element_compare : (A, A) -> BasicsOrder,
  list : @list.List[A],
) -> @list.List[A] {
  let as_array : Array[A] = @list.List::to_array(list)
  Array::sort_by(as_array, fn(a, b) {
    basics_order_to_int(element_compare(a, b))
  })
  @list.from_array(as_array)
}

///|
pub fn[A] list_all(is_hay : (A) -> Bool, list : @list.List[A]) -> Bool {
  @list.List::all(list, is_hay)
}

///|
pub fn[A] list_any(is_needle : (A) -> Bool, list : @list.List[A]) -> Bool {
  @list.List::any(list, is_needle)
}

///|
pub fn[A, State] list_foldl(
  reduce : (A, State) -> State,
  initial_state : State,
  list : @list.List[A],
) -> State {
  @list.List::fold(list, init=initial_state, fn(state, element) {
    reduce(element, state)
  })
}

///|
pub fn[A, State] list_foldr(
  reduce : (A, State) -> State,
  initial_state : State,
  list : @list.List[A],
) -> State {
  Array::rev_fold(@list.List::to_array(list), init=initial_state, fn(
    state,
    element,
  ) {
    reduce(element, state)
  })
}

///|
pub fn[A] list_take(keep_count : Int64, list : @list.List[A]) -> @list.List[A] {
  @list.List::take(list, Int64::to_int(keep_count))
}

///|
pub fn[A] list_drop(
  start_remove_count : Int64,
  list : @list.List[A],
) -> @list.List[A] {
  @list.List::drop(list, Int64::to_int(start_remove_count))
}

///|
pub fn[A] list_intersperse(
  in_between_element : A,
  list : @list.List[A],
) -> @list.List[A] {
  @list.List::intersperse(list, in_between_element)
}

///|
pub fn[A] list_filter(
  keep_element : (A) -> Bool,
  list : @list.List[A],
) -> @list.List[A] {
  @list.List::filter(list, keep_element)
}

///|
pub fn[A, B] list_map(
  element_change : (A) -> B,
  list : @list.List[A],
) -> @list.List[B] {
  @list.List::map(list, element_change)
}

///|
pub fn[A, B] list_indexed_map(
  element_change : (Int64, A) -> B,
  list : @list.List[A],
) -> @list.List[B] {
  @list.List::mapi(list, fn(index, element) {
    element_change(Int::to_int64(index), element)
  })
}

///|
pub fn[A, B] list_filter_map(
  element_to_maybe_new : (A) -> B?,
  list : @list.List[A],
) -> @list.List[B] {
  @list.List::filter_map(list, element_to_maybe_new)
}

///|
pub fn[A, B] list_concat_map(
  element_to_maybe_new : (A) -> @list.List[B],
  list : @list.List[A],
) -> @list.List[B] {
  @list.List::flat_map(list, element_to_maybe_new)
}

///|
pub fnalias @list.List::unzip as list_unzip

///|
pub fnalias @list.zip as list_zip

///|
pub fn[A, B, Combined] list_map2(
  elements_combine : (A, B) -> Combined,
  a_list : @list.List[A],
  b_list : @list.List[B],
) -> @list.List[Combined] {
  let mut remaining_a_list : @list.List[A] = a_list
  let mut remaining_b_list : @list.List[B] = b_list
  let combined_array : Array[Combined] = Array::new()
  for {
    match (remaining_a_list, remaining_b_list) {
      (
        @list.List::More(a_head, tail=a_tail),
        @list.List::More(b_head, tail=b_tail),
      ) => {
        remaining_a_list = a_tail
        remaining_b_list = b_tail
        combined_array.push(elements_combine(a_head, b_head))
      }
      (@list.List::Empty, _) | (_, @list.List::Empty) => break
    }
  }
  @list.from_array(combined_array)
}

///|
pub fn[A, B, C, Combined] list_map3(
  elements_combine : (A, B, C) -> Combined,
  a_list : @list.List[A],
  b_list : @list.List[B],
  c_list : @list.List[C],
) -> @list.List[Combined] {
  let mut remaining_a_list : @list.List[A] = a_list
  let mut remaining_b_list : @list.List[B] = b_list
  let mut remaining_c_list : @list.List[C] = c_list
  let combined_array : Array[Combined] = Array::new()
  for {
    match (remaining_a_list, remaining_b_list, remaining_c_list) {
      (
        @list.List::More(a_head, tail=a_tail),
        @list.List::More(b_head, tail=b_tail),
        @list.List::More(c_head, tail=c_tail),
      ) => {
        remaining_a_list = a_tail
        remaining_b_list = b_tail
        remaining_c_list = c_tail
        combined_array.push(elements_combine(a_head, b_head, c_head))
      }
      (@list.List::Empty, _, _)
      | (_, @list.List::Empty, _)
      | (_, _, @list.List::Empty) => break
    }
  }
  @list.from_array(combined_array)
}

///|
pub fn[A, B, C, D, Combined] list_map4(
  elements_combine : (A, B, C, D) -> Combined,
  a_list : @list.List[A],
  b_list : @list.List[B],
  c_list : @list.List[C],
  d_list : @list.List[D],
) -> @list.List[Combined] {
  let mut remaining_a_list : @list.List[A] = a_list
  let mut remaining_b_list : @list.List[B] = b_list
  let mut remaining_c_list : @list.List[C] = c_list
  let mut remaining_d_list : @list.List[D] = d_list
  let combined_array : Array[Combined] = Array::new()
  for {
    match
      (remaining_a_list, remaining_b_list, remaining_c_list, remaining_d_list) {
      (
        @list.List::More(a_head, tail=a_tail),
        @list.List::More(b_head, tail=b_tail),
        @list.List::More(c_head, tail=c_tail),
        @list.List::More(d_head, tail=d_tail),
      ) => {
        remaining_a_list = a_tail
        remaining_b_list = b_tail
        remaining_c_list = c_tail
        remaining_d_list = d_tail
        combined_array.push(elements_combine(a_head, b_head, c_head, d_head))
      }
      (@list.List::Empty, _, _, _)
      | (_, @list.List::Empty, _, _)
      | (_, _, @list.List::Empty, _)
      | (_, _, _, @list.List::Empty) => break
    }
  }
  @list.from_array(combined_array)
}

///|
pub fn[A, B, C, D, E, Combined] list_map5(
  elements_combine : (A, B, C, D, E) -> Combined,
  a_list : @list.List[A],
  b_list : @list.List[B],
  c_list : @list.List[C],
  d_list : @list.List[D],
  e_list : @list.List[E],
) -> @list.List[Combined] {
  let mut remaining_a_list : @list.List[A] = a_list
  let mut remaining_b_list : @list.List[B] = b_list
  let mut remaining_c_list : @list.List[C] = c_list
  let mut remaining_d_list : @list.List[D] = d_list
  let mut remaining_e_list : @list.List[E] = e_list
  let combined_array : Array[Combined] = Array::new()
  for {
    match
      (
        remaining_a_list, remaining_b_list, remaining_c_list, remaining_d_list, remaining_e_list,
      ) {
      (
        @list.List::More(a_head, tail=a_tail),
        @list.List::More(b_head, tail=b_tail),
        @list.List::More(c_head, tail=c_tail),
        @list.List::More(d_head, tail=d_tail),
        @list.List::More(e_head, tail=e_tail),
      ) => {
        remaining_a_list = a_tail
        remaining_b_list = b_tail
        remaining_c_list = c_tail
        remaining_d_list = d_tail
        remaining_e_list = e_tail
        combined_array.push(
          elements_combine(a_head, b_head, c_head, d_head, e_head),
        )
      }
      (@list.List::Empty, _, _, _, _)
      | (_, @list.List::Empty, _, _, _)
      | (_, _, @list.List::Empty, _, _)
      | (_, _, _, @list.List::Empty, _)
      | (_, _, _, _, @list.List::Empty) => break
    }
  }
  @list.from_array(combined_array)
}

///|
/// A string-rope. use `string_string_to_string` to turn it into a `String`.
/// Only use `StringString::to_string(_)` for debugging
pub(all) enum StringString {
  One(String)
  Append(StringString, StringString)
}

///|
impl Show for StringString with output(self, logger) {
  String::output(string_string_to_string(self), logger)
}

///|
impl Eq for StringString with equal(self, other) {
  String::equal(string_string_to_string(self), string_string_to_string(other))
}

///|
impl Compare for StringString with compare(self, other) -> Int {
  String::compare(string_string_to_string(self), string_string_to_string(other))
}

///|
pub fn string_string_to_string(string : StringString) -> String {
  match string {
    StringString::One(str) => str
    StringString::Append(full_left, full_right) => {
      let builder : StringBuilder = StringBuilder::new()
      let mut current_leftest : StringString = full_left
      let current_right_stack : Array[StringString] = Array::new()
      current_right_stack.push(full_right)
      for {
        match current_leftest {
          StringString::One(leftest_string) => {
            builder.write_string(leftest_string)
            match current_right_stack.pop() {
              Option::None => break
              Option::Some(next_right) => current_leftest = next_right
            }
          }
          StringString::Append(leftest_left, leftest_right) => {
            current_leftest = leftest_left
            current_right_stack.push(leftest_right)
          }
        }
      }
      StringBuilder::to_string(builder)
    }
  }
}

///|
pub fn string_is_empty(string : StringString) -> Bool {
  match string {
    StringString::One(str) => String::is_empty(str)
    StringString::Append(left, right) =>
      string_is_empty(left) && string_is_empty(right)
  }
}

///|
pub fn string_length(string : StringString) -> Int64 {
  Int::to_int64(string_length_int(string))
}

///|
pub fn string_length_int(string : StringString) -> Int {
  match string {
    StringString::One(str) => String::length(str)
    StringString::Append(left, right) =>
      string_length_int(left) + string_length_int(right)
  }
}

///|
pub fn string_contains(needle : StringString, string : StringString) -> Bool {
  String::contains(
    string_string_to_string(string),
    string_string_to_string(needle),
  )
}

///|
pub fn string_starts_with(needle : StringString, string : StringString) -> Bool {
  String::has_prefix(
    string_string_to_string(string),
    string_string_to_string(needle),
  )
}

///|
pub fn string_ends_with(needle : StringString, string : StringString) -> Bool {
  String::has_suffix(
    string_string_to_string(string),
    string_string_to_string(needle),
  )
}

///|
pub fn string_all(is_hay : (Char) -> Bool, string : StringString) -> Bool {
  Iter::all(String::iter(string_string_to_string(string)), is_hay)
}

///|
pub fn string_any(is_needle : (Char) -> Bool, string : StringString) -> Bool {
  Iter::any(String::iter(string_string_to_string(string)), is_needle)
}

///|
pub let string_empty : StringString = StringString::One("")

///|
pub fn string_from_char(char : Char) -> StringString {
  StringString::One(Char::to_string(char))
}

///|
pub fn string_from_int(int : Int64) -> StringString {
  StringString::One(Int64::to_string(int))
}

///|
pub fn string_from_float(float : Double) -> StringString {
  StringString::One(Double::to_string(float))
}

///|
pub fn string_repeat(count : Int64, to_repeat : StringString) -> StringString {
  StringString::One(
    String::repeat(string_string_to_string(to_repeat), Int64::to_int(count)),
  )
}

///|
pub fn string_from_list(chars : @list.List[Char]) -> StringString {
  StringString::One(String::from_array(@list.List::to_array(chars)))
}

///|
pub fn string_to_lower(string : StringString) -> StringString {
  StringString::One(String::to_lower(string_string_to_string(string)))
}

///|
pub fn string_to_upper(string : StringString) -> StringString {
  StringString::One(String::to_upper(string_string_to_string(string)))
}

///|
pub fn string_reverse(string : StringString) -> StringString {
  StringString::One(String::rev(string_string_to_string(string)))
}

///|
/// \\s in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Cheatsheet
let whitespacePossibilities : String = String::from_array([
  '\\n', '\\r', '\\f', '\\t', '\\u000B', ' ', '\\u00a0', '\\u1680', '\\u2000', '\\u2001',
  '\\u2002', '\\u2003', '\\u2004', '\\u2005', '\\u2006', '\\u2007', '\\u2008', '\\u2009',
  '\\u200a', '\\u2028', '\\u2029', '\\u202f', '\\u205f', '\\u3000', '\\ufeff',
])

///|
pub fn string_trim(string : StringString) -> StringString {
  StringString::One(
    StringView::to_string(
      String::trim(string_string_to_string(string), whitespacePossibilities),
    ),
  )
}

///|
pub fn string_trim_left(string : StringString) -> StringString {
  StringString::One(
    StringView::to_string(
      String::trim_start(
        string_string_to_string(string),
        whitespacePossibilities,
      ),
    ),
  )
}

///|
pub fn string_trim_right(string : StringString) -> StringString {
  StringString::One(
    StringView::to_string(
      String::trim_end(string_string_to_string(string), whitespacePossibilities),
    ),
  )
}

///|
pub fn string_pad_left(
  new_minimum_length : Int64,
  padding : Char,
  string : StringString,
) -> StringString {
  StringString::One(
    StringView::to_string(
      String::pad_start(
        string_string_to_string(string),
        Int64::to_int(new_minimum_length),
        padding,
      ),
    ),
  )
}

///|
pub fn string_pad_right(
  new_minimum_length : Int64,
  padding : Char,
  string : StringString,
) -> StringString {
  StringString::One(
    StringView::to_string(
      String::pad_end(
        string_string_to_string(string),
        Int64::to_int(new_minimum_length),
        padding,
      ),
    ),
  )
}

///|
pub fn string_pad(
  new_minimum_length : Int64,
  padding : Char,
  string : StringString,
) -> StringString {
  let as_string : String = string_string_to_string(string)
  StringString::One(
    StringView::to_string(
      String::pad_start(
        String::pad_end(
          as_string,
          (String::length(as_string) + Int64::to_int(new_minimum_length)) / 2,
          padding,
        ),
        Int64::to_int(new_minimum_length),
        padding,
      ),
    ),
  )
}

///|
pub fn string_replace(
  to_replace : StringString,
  replacement : StringString,
  string : StringString,
) -> StringString {
  StringString::One(
    StringView::to_string(
      String::replace_all(
        string_string_to_string(string),
        old=string_string_to_string(to_replace),
        new=string_string_to_string(replacement),
      ),
    ),
  )
}

///|
pub fn string_map(
  char_change : (Char) -> Char,
  string : StringString,
) -> StringString {
  StringString::One(
    String::from_iter(
      Iter::map(String::iter(string_string_to_string(string)), char_change),
    ),
  )
}

///|
pub fn string_filter(
  keep_char : (Char) -> Bool,
  string : StringString,
) -> StringString {
  StringString::One(
    String::from_iter(
      Iter::filter(String::iter(string_string_to_string(string)), keep_char),
    ),
  )
}

///|
pub fn string_append(left : StringString, right : StringString) -> StringString {
  StringString::Append(left, right)
}

///|
pub fn string_cons(left : Char, right : StringString) -> StringString {
  StringString::Append(StringString::One(Char::to_string(left)), right)
}

///|
pub fn string_concat(strings : @list.List[StringString]) -> StringString {
  @list.List::fold(strings, init=string_empty, string_append)
}

///|
pub fn string_join(
  in_between : StringString,
  strings : @list.List[StringString],
) -> StringString {
  let in_between_as_string : StringString = StringString::One(
    string_string_to_string(in_between),
  )
  match strings {
    @list.List::Empty => string_empty
    @list.List::More(head_string, tail=tail_strings) =>
      @list.List::fold(tail_strings, init=head_string, fn(so_far, element) {
        string_append(so_far, string_append(in_between_as_string, element))
      })
  }
}

///|
pub fn string_uncons(string : StringString) -> (Char, StringString)? {
  let as_string : String = string_string_to_string(string)
  match String::get_char(as_string, 0) {
    Option::None => Option::None
    Option::Some(headChar) =>
      Option::Some(
        (
          headChar,
          StringString::One(
            StringView::to_string(
              String::sub(as_string, start=Char::utf16_len(headChar)),
            ),
          ),
        ),
      ) catch {
        // should always work
        _ => Option::None
      }
  }
}

///|
pub fn string_left(
  count_to_keep : Int64,
  string : StringString,
) -> StringString {
  let as_string : String = string_string_to_string(string)
  if count_to_keep <= 0 {
    string_empty
  } else if Int64::to_int(count_to_keep) >= String::length(as_string) {
    string
  } else {
    StringString::One(
      StringView::to_string(
        String::sub(as_string, end=Int64::to_int(count_to_keep)),
      ),
    ) catch {
      IndexOutOfBounds =>
        // should not fail
        string_empty
      InvalidIndex =>
        // end position would split a UTF-16 surrogate pair
        // so we try the next UTF-16 offset
        StringString::One(
          StringView::to_string(
            String::sub(as_string, end=Int64::to_int(count_to_keep) + 1),
          ),
        ) catch {
          // should not fail
          _ => string_empty
        }
    }
  }
}

///|
pub fn string_right(
  count_to_keep : Int64,
  string : StringString,
) -> StringString {
  let as_string : String = string_string_to_string(string)
  let string_length : Int = String::length(as_string)
  if count_to_keep <= 0 {
    string_empty
  } else if Int64::to_int(count_to_keep) >= string_length {
    string
  } else {
    StringString::One(
      StringView::to_string(
        String::sub(
          as_string,
          start=string_length - Int64::to_int(count_to_keep),
        ),
      ),
    ) catch {
      IndexOutOfBounds => string_empty // should not fail
      InvalidIndex =>
        // end position would split a UTF-16 surrogate pair
        // so we try the next UTF-16 offset
        StringString::One(
          StringView::to_string(
            String::sub(
              as_string,
              start=string_length - Int64::to_int(count_to_keep) + 1,
            ),
          ),
        ) catch {
          _ => string_empty // should not fail
        }
    }
  }
}

///|
pub fn string_drop_left(
  count_to_drop : Int64,
  string : StringString,
) -> StringString {
  let as_string : String = string_string_to_string(string)
  if count_to_drop <= 0 {
    string
  } else if Int64::to_int(count_to_drop) >= String::length(as_string) {
    string_empty
  } else {
    StringString::One(
      StringView::to_string(
        String::sub(as_string, start=Int64::to_int(count_to_drop)),
      ),
    ) catch {
      IndexOutOfBounds => string_empty // should not fail
      InvalidIndex =>
        // end position would split a UTF-16 surrogate pair
        // so we try the next UTF-16 offset
        StringString::One(
          StringView::to_string(
            String::sub(as_string, start=Int64::to_int(count_to_drop) + 1),
          ),
        ) catch {
          _ => string_empty // should not fail
        }
    }
  }
}

///|
pub fn string_drop_right(
  count_to_drop : Int64,
  string : StringString,
) -> StringString {
  let as_string : String = string_string_to_string(string)
  let string_length : Int = String::length(as_string)
  if count_to_drop <= 0 {
    string
  } else if Int64::to_int(count_to_drop) >= string_length {
    string_empty
  } else {
    StringString::One(
      StringView::to_string(
        String::sub(as_string, end=string_length - Int64::to_int(count_to_drop)),
      ),
    ) catch {
      IndexOutOfBounds => string_empty // should not fail
      InvalidIndex =>
        // end position would split a UTF-16 surrogate pair
        // so we try the next UTF-16 offset
        StringString::One(
          StringView::to_string(
            String::sub(
              as_string,
              end=string_length - Int64::to_int(count_to_drop) + 1,
            ),
          ),
        ) catch {
          _ => string_empty // should not fail
        }
    }
  }
}

///|
pub fn string_slice(
  start_inclusive : Int64,
  end_exclusive : Int64,
  string : StringString,
) -> StringString {
  let as_string : String = string_string_to_string(string)
  let string_length : Int = String::length(as_string)
  if Int64::to_int(start_inclusive) >= string_length ||
    Int64::to_int(end_exclusive) <= -string_length {
    string_empty
  } else {
    let valid_start_inclusive : Int = Int::max(
      Int64::to_int(start_inclusive),
      -string_length,
    )
    let valid_end_exclusive : Int = Int::min(
      Int64::to_int(end_exclusive),
      string_length,
    )
    StringString::One(
      StringView::to_string(
        String::sub(
          as_string,
          start=valid_start_inclusive,
          end=valid_end_exclusive,
        ),
      ),
    ) catch {
      IndexOutOfBounds => string_empty // should not fail
      InvalidIndex =>
        // times are rough!
        // because we don't know if the start or end char boundaries
        // were violated (or both) so we have no choice but to try them all
        StringString::One(
          StringView::to_string(
            String::sub(
              as_string,
              start=valid_start_inclusive,
              end=valid_end_exclusive + 1,
            ),
          ),
        ) catch {
          IndexOutOfBounds => string_empty // should not fail
          InvalidIndex =>
            StringString::One(
              StringView::to_string(
                String::sub(
                  as_string,
                  start=valid_start_inclusive - 1,
                  end=valid_end_exclusive,
                ),
              ),
            ) catch {
              IndexOutOfBounds => string_empty // should not fail
              InvalidIndex =>
                StringString::One(
                  StringView::to_string(
                    String::sub(
                      as_string,
                      start=valid_start_inclusive - 1,
                      end=valid_end_exclusive + 1,
                    ),
                  ),
                ) catch {
                  // should not fail
                  _ => string_empty
                }
            }
        }
    }
  }
}

///|
pub fn string_to_int(string : StringString) -> Int64? {
  Option::Some(@strconv.parse_int64(string_string_to_string(string))) catch {
    _ => Option::None
  }
}

///|
pub fn string_to_float(string : StringString) -> Double? {
  Option::Some(@strconv.parse_double(string_string_to_string(string))) catch {
    _ => Option::None
  }
}

///|
pub fn string_to_list(string : StringString) -> @list.List[Char] {
  @list.List::from_array(String::to_array(string_string_to_string(string)))
}

///|
pub fn string_split(
  separator : StringString,
  string : StringString,
) -> @list.List[StringString] {
  @list.List::from_iter(
    Iter::map(
      String::split(
        string_string_to_string(string),
        string_string_to_string(separator),
      ),
      fn(string_view) { StringString::One(StringView::to_string(string_view)) },
    ),
  )
}

///|
pub fn string_lines(string : StringString) -> @list.List[StringString] {
  @list.List::from_iter(
    Iter::map(
      String::split(
        String::replace_all(
          string_string_to_string(string),
          old="\\r\\n",
          new="\\n",
        ),
        "\\n",
      ),
      fn(string_view) { StringString::One(StringView::to_string(string_view)) },
    ),
  )
}

///|
pub fn string_words(string : StringString) -> @list.List[StringString] {
  string_string_to_string(string)
  |> String::iter
  |> Iter::map(fn(char) {
    if String::contains_char(whitespacePossibilities, char) {
      ' '
    } else {
      char
    }
  })
  |> String::from_iter
  |> String::split(" ")
  |> Iter::filter_map(fn(string_view) {
    if StringView::is_empty(string_view) {
      Option::None
    } else {
      Option::Some(StringString::One(StringView::to_string(string_view)))
    }
  })
  |> @list.List::from_iter
}

///|
pub fn[State] string_foldl(
  initial_state : State,
  reduce : (Char, State) -> State,
  string : StringString,
) -> State {
  String::fold(string_string_to_string(string), init=initial_state, fn(
    so_far,
    char,
  ) {
    reduce(char, so_far)
  })
}

///|
pub fn[State] string_foldr(
  initial_state : State,
  reduce : (Char, State) -> State,
  string : StringString,
) -> State {
  String::rev_fold(string_string_to_string(string), init=initial_state, fn(
    so_far,
    char,
  ) {
    reduce(char, so_far)
  })
}

///|
pub fnalias @immut/array.T::is_empty as array_is_empty

///|
pub fn[A] array_length(array : @immut/array.T[A]) -> Int64 {
  Int::to_int64(@immut/array.T::length(array))
}

///|
pub fn[A] array_get(index : Int64, array : @immut/array.T[A]) -> A? {
  @immut/array.T::get(array, Int64::to_int(index))
}

///|
pub fn[A] array_singleton(only_element : A) -> @immut/array.T[A] {
  @immut/array.of([only_element])
}

///|
pub fn[A] array_repeat(length : Int64, element : A) -> @immut/array.T[A] {
  @immut/array.make(Int64::to_int(length), element)
}

///|
pub fn[A] array_from_list(list : @list.List[A]) -> @immut/array.T[A] {
  @immut/array.from_iter(@list.List::iter(list))
}

///|
pub fn[A] array_initialize(
  length : Int64,
  index_to_element : (Int64) -> A,
) -> @immut/array.T[A] {
  @immut/array.makei(Int64::to_int(length), fn(index) {
    index_to_element(Int::to_int64(index))
  })
}

///|
pub fn[A] array_push(
  new_last_element : A,
  array : @immut/array.T[A],
) -> @immut/array.T[A] {
  @immut/array.T::push(array, new_last_element)
}

///|
pub fn[A] array_set(
  index : Int64,
  new_element : A,
  array : @immut/array.T[A],
) -> @immut/array.T[A] {
  @immut/array.T::set(array, Int64::to_int(index), new_element)
}

///|
pub fn[A] array_slice(
  start_inclusive_possibly_negative : Int64,
  end_exclusive_possibly_negative : Int64,
  array : @immut/array.T[A],
) -> @immut/array.T[A] {
  // can maybe be optimized
  let start_inclusive = if start_inclusive_possibly_negative <= -1 {
    Int::max(
      0,
      Int64::to_int(start_inclusive_possibly_negative) +
      @immut/array.T::length(array),
    )
    // start_inclusive_possibly_negative >= 0
  } else {
    Int::min(
      @immut/array.T::length(array),
      Int64::to_int(start_inclusive_possibly_negative),
    )
  }
  let end_exclusive = if end_exclusive_possibly_negative <= -1 {
    Int::max(
      0,
      Int64::to_int(end_exclusive_possibly_negative) +
      @immut/array.T::length(array),
    )
    // end_exclusive_possibly_negative >= 0
  } else {
    Int::min(
      @immut/array.T::length(array),
      Int64::to_int(end_exclusive_possibly_negative),
    )
  }
  if start_inclusive >= end_exclusive {
    @immut/array.new()
  } else {
    Array::sub(
      @immut/array.T::to_array(array),
      start=start_inclusive,
      end=end_exclusive,
    )
    |> ArrayView::iter
    |> @immut/array.T::from_iter
  }
}

///|
pub fn[A] array_reverse(array : @immut/array.T[A]) -> @immut/array.T[A] {
  // can maybe be optimized
  @immut/array.T::rev_fold(array, init=@immut/array.new(), fn(so_far, element) {
    @immut/array.T::push(so_far, element)
  })
}

///|
pub fn[A] array_filter(
  keep_element : (A) -> Bool,
  array : @immut/array.T[A],
) -> @immut/array.T[A] {
  // can maybe be optimized
  array
  |> @immut/array.T::iter
  |> Iter::filter(keep_element)
  |> @immut/array.T::from_iter
}

///|
pub fn[A, B] array_map(
  element_change : (A) -> B,
  array : @immut/array.T[A],
) -> @immut/array.T[B] {
  @immut/array.T::map(array, element_change)
}

///|
pub fn[A, B] array_indexed_map(
  element_change : (Int64, A) -> B,
  array : @immut/array.T[A],
) -> @immut/array.T[B] {
  // can maybe be optimized
  array
  |> @immut/array.T::iter
  |> Iter::mapi(fn(index, element) {
    element_change(Int::to_int64(index), element)
  })
  |> @immut/array.T::from_iter
}

///|
pub fn[A, State] array_foldl(
  reduce : (A, State) -> State,
  initial_state : State,
  array : @immut/array.T[A],
) -> State {
  @immut/array.T::fold(array, init=initial_state, fn(so_far, element) {
    reduce(element, so_far)
  })
}

///|
pub fn[A, State] array_foldr(
  reduce : (A, State) -> State,
  initial_state : State,
  array : @immut/array.T[A],
) -> State {
  @immut/array.T::rev_fold(array, init=initial_state, fn(so_far, element) {
    reduce(element, so_far)
  })
}

///|
pub fnalias @immut/array.T::concat as array_append

///|
pub fn[A] array_to_list(array : @immut/array.T[A]) -> @list.List[A] {
  @list.from_iter(@immut/array.T::iter(array))
}

///|
pub fn[A] array_to_indexed_list(
  array : @immut/array.T[A],
) -> @list.List[(Int64, A)] {
  array
  |> @immut/array.T::iter
  |> Iter::mapi(fn(index, element) { (Int::to_int64(index), element) })
  |> @list.from_iter
}

///|
pub(all) struct GeneratedOffsetStart[Offset, Start] {
  offset : Offset
  start : Start
} derive(Eq, Show)

///|
struct TimeCivil {
  day : Int64
  month : Int64
  year : Int64
}

///|
pub(all) enum TimeMonth {
  Apr
  Aug
  Dec
  Feb
  Jan
  Jul
  Jun
  Mar
  May
  Nov
  Oct
  Sep
} derive(Eq, Show)

///|
pub(all) enum TimePosix {
  Posix(Int64)
} derive(Eq, Show)

///|
pub(all) enum TimeWeekday {
  Fri
  Mon
  Sat
  Sun
  Thu
  Tue
  Wed
} derive(Eq, Show)

///|
pub typealias GeneratedOffsetStart[Int64, Int64] as TimeEra

///|
pub enum TimeZone {
  Zone(Int64, @list.List[TimeEra])
} derive(Eq, Show)

///|
pub enum TimeZoneName {
  Name(StringString)
  Offset(Int64)
} derive(Eq, Show)

///|
pub fn time_custom_zone(
  default_offset_in_minutes : Int64,
  eras : @list.List[GeneratedOffsetStart[Int64, Int64]],
) -> TimeZone {
  TimeZone::Zone(default_offset_in_minutes, eras)
}

///|
pub fn time_millis_to_posix(milliseconds : Int64) -> TimePosix {
  TimePosix::Posix(milliseconds)
}

///|
pub fn time_posix_to_millis(time_posix : TimePosix) -> Int64 {
  let TimePosix::Posix(millis) = time_posix
  millis
}

///|
pub fn time_to_adjusted_minutes(
  time_zone : TimeZone,
  time : TimePosix,
) -> Int64 {
  let TimeZone::Zone(default_offset, eras) = time_zone
  time_to_adjusted_minutes_help(
    default_offset,
    time_posix_to_millis(time) / 60000L,
    eras,
  )
}

///|
pub fn time_to_adjusted_minutes_help(
  default_offset : Int64,
  posix_minutes : Int64,
  eras : @list.List[GeneratedOffsetStart[Int64, Int64]],
) -> Int64 {
  match eras {
    @list.List::Empty => posix_minutes + default_offset
    @list.List::More(era, tail=older_eras) =>
      if era.start < posix_minutes {
        posix_minutes + era.offset
      } else {
        time_to_adjusted_minutes_help(default_offset, posix_minutes, older_eras)
      }
  }
}

///|
fn time_to_civil(minutes : Int64) -> TimeCivil {
  let raw_day : Int64 = minutes / (60L * 24L) + 719468L
  let era : Int64 = (if raw_day >= 0L { raw_day } else { raw_day - 146096L }) /
    146097L
  let day_of_era : Int64 = raw_day - era * 146097L
  let year_of_era : Int64 = (
      day_of_era -
      day_of_era / 1460L +
      day_of_era / 36524L -
      day_of_era / 146096L
    ) /
    365L
  let day_of_year : Int64 = day_of_era -
    (365L * year_of_era + year_of_era / 4L - year_of_era / 100L)
  let mp : Int64 = (5L * day_of_year + 2L) / 153L
  let month : Int64 = mp + (if mp < 10L { 3L } else { -9L })
  let year : Int64 = year_of_era + era * 400L
  TimeCivil::{
    day: day_of_year - (153L * mp + 2L) / 5L + 1L,
    month,
    year: year + (if month <= 2L { 1L } else { 0L }),
  }
}

///|
pub fn time_to_day(zone : TimeZone, time : TimePosix) -> Int64 {
  time_to_civil(time_to_adjusted_minutes(zone, time)).day
}

///|
pub fn time_to_hour(zone : TimeZone, time : TimePosix) -> Int64 {
  time_to_adjusted_minutes(zone, time) / 60L % 24L
}

///|
pub fn time_to_millis(_ : TimeZone, time : TimePosix) -> Int64 {
  time_posix_to_millis(time) % 1000L
}

///|
pub fn time_to_minute(zone : TimeZone, time : TimePosix) -> Int64 {
  time_to_adjusted_minutes(zone, time) % 60L
}

///|
pub fn time_to_month(zone : TimeZone, time : TimePosix) -> TimeMonth {
  match time_to_civil(time_to_adjusted_minutes(zone, time)).month {
    1L => TimeMonth::Jan
    2L => TimeMonth::Feb
    3L => TimeMonth::Mar
    4L => TimeMonth::Apr
    5L => TimeMonth::May
    6L => TimeMonth::Jun
    7L => TimeMonth::Jul
    8L => TimeMonth::Aug
    9L => TimeMonth::Sep
    10L => TimeMonth::Oct
    11L => TimeMonth::Nov
    _ => TimeMonth::Dec
  }
}

///|
pub fn time_to_second(_ : TimeZone, time : TimePosix) -> Int64 {
  time_posix_to_millis(time) / 1000L % 60L
}

///|
pub fn time_to_weekday(zone : TimeZone, time : TimePosix) -> TimeWeekday {
  match time_to_adjusted_minutes(zone, time) / (60L * 24L) % 7L {
    0L => TimeWeekday::Thu
    1L => TimeWeekday::Fri
    2L => TimeWeekday::Sat
    3L => TimeWeekday::Sun
    4L => TimeWeekday::Mon
    5L => TimeWeekday::Tue
    _ => TimeWeekday::Wed
  }
}

///|
pub fn time_to_year(zone : TimeZone, time : TimePosix) -> Int64 {
  time_to_civil(time_to_adjusted_minutes(zone, time)).year
}

///|
pub fn time_utc() -> TimeZone {
  TimeZone::Zone(0L, @list.empty())
}
"""
